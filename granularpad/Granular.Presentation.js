/**
 * @version 0.3.0.0
 * @copyright Copyright â˜º 2016
 * @compiler Bridge.NET 16.3.2
 */
Bridge.assembly("Granular.Presentation", function ($asm, globals) {
    "use strict";

    Bridge.define("System.Windows.Markup.IUriContext", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.IResourceContainer", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.ApplicationHost", {
        statics: {
            fields: {
                current: null
            },
            props: {
                Current: {
                    get: function () {
                        if (System.Windows.ApplicationHost.current == null) {
                            System.Windows.ApplicationHost.Initialize$1();
                        }

                        return System.Windows.ApplicationHost.current;
                    }
                }
            },
            methods: {
                Initialize$1: function () {
                    if (System.Windows.ApplicationHost.current != null) {
                        return;
                    }

                    var type = System.Windows.ApplicationHost.GetApplicationHostTypeByAttribute() || System.Windows.ApplicationHost.GetApplicationHostTypeByReference();

                    if (type == null) {
                        throw new Granular.Exception("Can't find an explicit ApplicationHost assembly attribute or an implicit IApplicationHost implementation in the loaded assemblies");
                    }

                    System.Windows.ApplicationHost.Initialize(Bridge.cast(Bridge.createInstance(type), System.Windows.IApplicationHost));
                },
                Initialize: function (applicationHost) {
                    if (System.Windows.ApplicationHost.current != null && !Bridge.referenceEquals(System.Windows.ApplicationHost.current, applicationHost)) {
                        throw new Granular.Exception("ApplicationHost was already initialized");
                    }

                    System.Windows.ApplicationHost.current = applicationHost;
                },
                GetApplicationHostTypeByAttribute: function () {
                    var $t;
                    var applicationHostAttributes = System.Linq.Enumerable.from(System.AppDomain.getAssemblies()).selectMany($asm.$.System.Windows.ApplicationHost.f1).toArray(System.Windows.ApplicationHostAttribute);

                    if (applicationHostAttributes.length > 1) {
                        throw new Granular.Exception("Multiple ApplicationHost assembly attributes were found, leave only one attribute or call ApplicationHost.Initialize() at the application entry point.");
                    }

                    return ($t = System.Linq.Enumerable.from(applicationHostAttributes).firstOrDefault(null, null)) != null ? $t.Type : null;
                },
                GetApplicationHostTypeByReference: function () {
                    var types = System.Linq.Enumerable.from(System.AppDomain.getAssemblies()).selectMany($asm.$.System.Windows.ApplicationHost.f2).where($asm.$.System.Windows.ApplicationHost.f3).toArray(Function);

                    if (System.Linq.Enumerable.from(types).count() > 1) {
                        throw new Granular.Exception("Multiple types that are implementing IApplicationHost are loaded, use ApplicationHost assembly attribute or call ApplicationHost.Initialize() at the application entry point. Types found: {0}", [Bridge.toArray(System.Linq.Enumerable.from(types).select($asm.$.System.Windows.ApplicationHost.f4)).join(", ")]);
                    }

                    return System.Linq.Enumerable.from(types).firstOrDefault(null, null);
                }
            }
        }
    });

    Bridge.ns("System.Windows.ApplicationHost", $asm.$);

    Bridge.apply($asm.$.System.Windows.ApplicationHost, {
        f1: function (assembly) {
            return Granular.Extensions.AssemblyExtensions.GetCustomAttributesCached(System.Windows.ApplicationHostAttribute, assembly);
        },
        f2: function (assembly) {
            return Bridge.Reflection.getAssemblyTypes(assembly);
        },
        f3: function (type) {
            return Bridge.Reflection.isClass(type) && Bridge.Reflection.isAssignableFrom(System.Windows.IApplicationHost, type);
        },
        f4: function (type) {
            return Bridge.Reflection.getTypeFullName(type);
        }
    });

    Bridge.define("System.Windows.ApplicationHostAttribute", {
        inherits: [System.Attribute],
        props: {
            Type: null
        },
        ctors: {
            ctor: function (type) {
                this.$initialize();
                System.Attribute.ctor.call(this);
                this.Type = type;
            }
        }
    });

    Bridge.define("System.Windows.ApplicationHostExtensions", {
        statics: {
            methods: {
                GetMouseDeviceFromElement: function (applicationHost, element) {
                    var presentationSource = applicationHost.System$Windows$IApplicationHost$PresentationSourceFactory.System$Windows$IPresentationSourceFactory$GetPresentationSourceFromElement(element);
                    return presentationSource != null ? presentationSource.System$Windows$IPresentationSource$MouseDevice : null;
                },
                GetKeyboardDeviceFromElement: function (applicationHost, element) {
                    var presentationSource = applicationHost.System$Windows$IApplicationHost$PresentationSourceFactory.System$Windows$IPresentationSourceFactory$GetPresentationSourceFromElement(element);
                    return presentationSource != null ? presentationSource.System$Windows$IPresentationSource$KeyboardDevice : null;
                }
            }
        }
    });

    Bridge.define("System.Windows.BaseValueSource", {
        $kind: "enum",
        statics: {
            fields: {
                Unknown: 0,
                Default: 1,
                Inherited: 2,
                ThemeStyle: 3,
                ThemeStyleTrigger: 4,
                Style: 5,
                TemplateTrigger: 6,
                StyleTrigger: 7,
                ImplicitReference: 8,
                ParentTemplate: 9,
                ParentTemplateTrigger: 10,
                Local: 11
            }
        }
    });

    Bridge.define("System.Windows.Markup.IMarkupExtension", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.IResourceKey", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Condition", {
        props: {
            Binding: null,
            Property: null,
            SourceName: null,
            Value: null
        },
        methods: {
            CreateTriggerCondition: function (element) {
                if (this.Property == null) {
                    throw new Granular.Exception("Condition.Property cannot be null");
                }

                var dependencyProperty = System.Windows.PropertyPathElementExtensions.GetDependencyProperty(this.Property, Bridge.getType(element));

                var resolvedValue = this.Value == null || Bridge.Reflection.isInstanceOfType(this.Value, dependencyProperty.PropertyType) ? this.Value : System.Windows.Markup.TypeConverter.ConvertValue(this.Value.toString(), dependencyProperty.PropertyType, System.Windows.Markup.XamlNamespaces.Empty, null);

                var source = Granular.Extensions.StringExtensions.IsNullOrEmpty(this.SourceName) ? element : Bridge.as(System.Windows.NameScope.GetTemplateNameScope(element).System$Windows$INameScope$findName(this.SourceName), System.Windows.FrameworkElement);

                return System.Windows.TriggerCondition.Register(source, dependencyProperty, resolvedValue);
            },
            CreateDataTriggerCondition: function (element) {
                if (this.Binding == null) {
                    throw new Granular.Exception("Condition.Binding cannot be null");
                }

                return System.Windows.DataTriggerCondition.Register(element, this.Binding, this.Value);
            }
        }
    });

    Bridge.define("System.Windows.DependencyObject", {
        statics: {
            methods: {
                VerifyReadOnlyProperty: function (dependencyProperty, dependencyPropertyKey) {
                    if (dependencyProperty.IsReadOnly && (dependencyPropertyKey == null || !Bridge.referenceEquals(dependencyPropertyKey.DependencyProperty, dependencyProperty) || !System.Windows.DependencyProperty.IsValidReadOnlyKey(dependencyPropertyKey))) {
                        throw new Granular.Exception("Can't modify the readonly dependency property \"{0}\" without its key", [dependencyProperty]);
                    }
                }
            }
        },
        fields: {
            entries: null,
            readOnlyEntries: null,
            inheritanceParent: null,
            entryValueChangedEventHandler: null,
            containedEntryValueChangedEventHandler: null,
            parentPropertyChangedEventHandler: null
        },
        events: {
            PropertyChanged: null
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                this.entries = new (Granular.Collections.ConvertedStringDictionary$2(System.Windows.DependencyProperty,System.Windows.IDependencyPropertyValueEntry))($asm.$.System.Windows.DependencyObject.f1);
                this.readOnlyEntries = new (Granular.Collections.ConvertedStringDictionary$2(System.Windows.DependencyProperty,System.Windows.IDependencyPropertyValueEntry))($asm.$.System.Windows.DependencyObject.f1);

                this.entryValueChangedEventHandler = Bridge.fn.cacheBind(this, this.OnEntryValueChanged);
                this.containedEntryValueChangedEventHandler = Bridge.fn.cacheBind(this, this.OnContainedEntryValueChanged);
                this.parentPropertyChangedEventHandler = Bridge.fn.cacheBind(this, this.OnParentPropertyChanged);
            }
        },
        methods: {
            ContainsValue: function (dependencyProperty) {
                var entry = { };
                if (!this.entries.TryGetValue(dependencyProperty, entry)) {
                    return false;
                }

                return entry.v.System$Windows$IDependencyPropertyValueEntry$GetBaseValuePriority() > System.Windows.BaseValueSource.Inherited;
            },
            ContainsValue$1: function (dependencyPropertyKey) {
                return this.ContainsValue(dependencyPropertyKey.DependencyProperty);
            },
            GetValue: function (dependencyProperty) {
                var entry = { };
                if (!this.entries.TryGetValue(dependencyProperty, entry)) {
                    var propertyMetadata = dependencyProperty.GetMetadata(Bridge.getType(this));

                    // no need to create a new entry if the value is not inherited or coerced
                    if (!propertyMetadata.Inherits && (Bridge.staticEquals(propertyMetadata.CoerceValueCallback, null) || !dependencyProperty.IsAttached && !dependencyProperty.IsContainedBy(Bridge.getType(this)))) {
                        return propertyMetadata.DefaultValue;
                    }

                    entry.v = this.CreateDependencyPropertyValueEntry(dependencyProperty, propertyMetadata);
                    this.entries.Add(dependencyProperty, entry.v);
                }

                return entry.v.System$Windows$IDependencyPropertyValueEntry$Value;
            },
            GetValue$1: function (dependencyPropertyKey) {
                return this.GetValue(dependencyPropertyKey.DependencyProperty);
            },
            SetValue: function (dependencyProperty, value, source) {
                if (source === void 0) { source = 11; }
                this.SetValue$2(dependencyProperty, null, value, false, source);
            },
            SetValue$1: function (dependencyPropertyKey, value, source) {
                if (source === void 0) { source = 11; }
                this.SetValue$2(dependencyPropertyKey.DependencyProperty, dependencyPropertyKey, value, false, source);
            },
            SetValue$2: function (dependencyProperty, dependencyPropertyKey, value, setCurrentValue, source) {
                if (setCurrentValue === void 0) { setCurrentValue = false; }
                if (source === void 0) { source = 0; }
                System.Windows.DependencyObject.VerifyReadOnlyProperty(dependencyProperty, dependencyPropertyKey);

                var newExpressionProvider = Bridge.as(value, System.Windows.IExpressionProvider);
                if (newExpressionProvider == null && !dependencyProperty.IsValidValue(value)) {
                    return; // invalid value
                }

                var entry = this.GetInitializedValueEntry(dependencyProperty);

                var oldExpression = setCurrentValue ? Bridge.as(System.Windows.DependencyPropertyValueEntryExtensions.GetBaseValue(entry, false), System.Windows.IExpression) : Bridge.as(System.Windows.DependencyPropertyValueEntryExtensions.GetBaseValue$1(entry, source, false), System.Windows.IExpression);

                if (newExpressionProvider != null) {
                    value = newExpressionProvider.System$Windows$IExpressionProvider$CreateExpression(this, dependencyProperty);
                } else if (oldExpression != null && oldExpression.System$Windows$IExpression$SetValue(value)) {
                    return; // value (current or not) was set in the existing expression, nothing else to do
                }

                if (setCurrentValue) {
                    System.Windows.DependencyPropertyValueEntryExtensions.SetCurrentValue(entry, value);
                    return; // base value isn't changed
                }

                if (Bridge.is(oldExpression, System.IDisposable)) {
                    Bridge.cast(oldExpression, System.IDisposable).System$IDisposable$dispose();
                }

                System.Windows.DependencyPropertyValueEntryExtensions.SetBaseValue(entry, source, value);
                System.Windows.DependencyPropertyValueEntryExtensions.ClearCurrentValue(entry);
            },
            SetCurrentValue: function (dependencyProperty, value) {
                this.SetValue$2(dependencyProperty, null, value, true, 0);
            },
            SetCurrentValue$1: function (dependencyPropertyKey, value) {
                this.SetValue$2(dependencyPropertyKey.DependencyProperty, dependencyPropertyKey, value, true, 0);
            },
            ClearValue: function (dependencyProperty, source) {
                if (source === void 0) { source = 11; }
                this.ClearValue$2(dependencyProperty, null, source);
            },
            ClearValue$1: function (dependencyPropertyKey, source) {
                if (source === void 0) { source = 11; }
                this.ClearValue$2(dependencyPropertyKey.DependencyProperty, dependencyPropertyKey, source);
            },
            ClearValue$2: function (dependencyProperty, dependencyPropertyKey, source) {
                System.Windows.DependencyObject.VerifyReadOnlyProperty(dependencyProperty, dependencyPropertyKey);

                var entry = { };
                if (!this.entries.TryGetValue(dependencyProperty, entry)) {
                    return;
                }

                var expression = Bridge.as(System.Windows.DependencyPropertyValueEntryExtensions.GetBaseValue$1(entry.v, source, false), System.Windows.IExpression);
                if (Bridge.is(expression, System.IDisposable)) {
                    Bridge.cast(expression, System.IDisposable).System$IDisposable$dispose();
                }

                System.Windows.DependencyPropertyValueEntryExtensions.ClearBaseValue(entry.v, source);
                System.Windows.DependencyPropertyValueEntryExtensions.ClearCurrentValue(entry.v);
            },
            CoerceValue: function (dependencyProperty) {
                this.GetInitializedValueEntry(dependencyProperty).System$Windows$IDependencyPropertyValueEntry$CoerceValue();
            },
            GetValueSource: function (dependencyProperty) {
                var entry = { };
                if (this.entries.TryGetValue(dependencyProperty, entry)) {
                    return new System.Windows.ValueSource(entry.v.System$Windows$IDependencyPropertyValueEntry$GetBaseValuePriority(), Bridge.is(System.Windows.DependencyPropertyValueEntryExtensions.GetBaseValue(entry.v, false), System.Windows.IExpression) || Bridge.is(System.Windows.DependencyPropertyValueEntryExtensions.GetCurrentValue(entry.v, false), System.Windows.IExpression), !Bridge.referenceEquals(System.Windows.DependencyPropertyValueEntryExtensions.GetCurrentValue(entry.v, true), System.Windows.Data.ObservableValue.UnsetValue), !Bridge.referenceEquals(System.Windows.DependencyPropertyValueEntryExtensions.GetAnimationValue(entry.v, true), System.Windows.Data.ObservableValue.UnsetValue), !Granular.Compatibility.EqualityComparer.Default.equals2(entry.v.System$Windows$IDependencyPropertyValueEntry$Value, entry.v.System$Windows$IDependencyPropertyValueEntry$GetValue(entry.v.System$Windows$IDependencyPropertyValueEntry$ValuePriority, true)));
                }

                var propertyMetadata = dependencyProperty.GetMetadata(Bridge.getType(this));
                var baseValueSource = propertyMetadata.Inherits && this.inheritanceParent != null ? System.Windows.BaseValueSource.Inherited : System.Windows.BaseValueSource.Default;
                return new System.Windows.ValueSource(baseValueSource, false, false, false, false);
            },
            GetBaseValueSource: function (dependencyProperty) {
                var entry = { };

                if (this.entries.TryGetValue(dependencyProperty, entry)) {
                    return entry.v.System$Windows$IDependencyPropertyValueEntry$GetBaseValuePriority();
                }

                return dependencyProperty.Inherits && this.inheritanceParent != null ? System.Windows.BaseValueSource.Inherited : System.Windows.BaseValueSource.Default;
            },
            GetValueEntry: function (dependencyProperty) {
                return dependencyProperty.IsReadOnly ? this.GetInitializedReadOnlyValueEntry(dependencyProperty) : this.GetInitializedValueEntry(dependencyProperty);
            },
            GetValueEntry$1: function (dependencyPropertyKey) {
                System.Windows.DependencyObject.VerifyReadOnlyProperty(dependencyPropertyKey.DependencyProperty, dependencyPropertyKey);
                return this.GetInitializedValueEntry(dependencyPropertyKey.DependencyProperty);
            },
            GetInitializedValueEntry: function (dependencyProperty) {
                var entry = { };
                if (!this.entries.TryGetValue(dependencyProperty, entry)) {
                    entry.v = this.CreateDependencyPropertyValueEntry(dependencyProperty, dependencyProperty.GetMetadata(Bridge.getType(this)));
                    this.entries.Add(dependencyProperty, entry.v);
                }

                return entry.v;
            },
            GetInitializedReadOnlyValueEntry: function (dependencyProperty) {
                var readOnlyEntry = { };

                if (this.readOnlyEntries.TryGetValue(dependencyProperty, readOnlyEntry)) {
                    return readOnlyEntry.v;
                }

                readOnlyEntry.v = new System.Windows.ReadOnlyDependencyPropertyValueEntry(this.GetInitializedValueEntry(dependencyProperty));
                this.readOnlyEntries.Add(dependencyProperty, readOnlyEntry.v);

                return readOnlyEntry.v;
            },
            CreateDependencyPropertyValueEntry: function (dependencyProperty, propertyMetadata) {
                var isContained = dependencyProperty.IsAttached || dependencyProperty.IsContainedBy(Bridge.getType(this));

                var entry = new System.Windows.DependencyPropertyValueEntry(this, dependencyProperty, isContained ? propertyMetadata.CoerceValueCallback : null);
                System.Windows.DependencyPropertyValueEntryExtensions.SetBaseValue(entry, System.Windows.BaseValueSource.Default, propertyMetadata.DefaultValue);

                if (isContained) {
                    entry.System$Windows$IDependencyPropertyValueEntry$addValueChanged(this.containedEntryValueChangedEventHandler);
                } else {
                    entry.System$Windows$IDependencyPropertyValueEntry$addValueChanged(this.entryValueChangedEventHandler);
                }

                return entry;
            },
            OnEntryValueChanged: function (sender, e) {
                this.OnPropertyChanged(e);
                System.Windows.DependencyPropertyChangedEventHandlerExtensions.Raise(this.PropertyChanged, this, e);
            },
            OnContainedEntryValueChanged: function (sender, e) {
                e.Property.RaiseMetadataPropertyChangedCallback(this, e);
                this.OnPropertyChanged(e);
                System.Windows.DependencyPropertyChangedEventHandlerExtensions.Raise(this.PropertyChanged, this, e);
            },
            OnPropertyChanged: function (e) {
                //
            },
            SetInheritanceParent: function (parent) {
                var $t, $t1, $t2;
                if (Bridge.referenceEquals(this.inheritanceParent, parent)) {
                    return;
                }

                var oldInheritanceParent = this.inheritanceParent;

                if (this.inheritanceParent != null) {
                    this.inheritanceParent.removePropertyChanged(this.parentPropertyChangedEventHandler);
                }

                this.inheritanceParent = parent;

                if (this.inheritanceParent != null) {
                    this.inheritanceParent.addPropertyChanged(this.parentPropertyChangedEventHandler);
                }

                if (this.inheritanceParent == null) {
                    // clear inherited values
                    $t = Bridge.getEnumerator(this.entries.GetKeyValuePairs(), System.Collections.Generic.KeyValuePair$2(System.Windows.DependencyProperty,System.Windows.IDependencyPropertyValueEntry));
                    try {
                        while ($t.moveNext()) {
                            var pair = $t.Current;
                            if (pair.key.Inherits) {
                                System.Windows.DependencyPropertyValueEntryExtensions.ClearBaseValue(pair.value, System.Windows.BaseValueSource.Inherited);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$dispose();
                        }
                    }} else {
                    // update existing inherited values
                    $t1 = Bridge.getEnumerator(this.entries.GetKeyValuePairs(), System.Collections.Generic.KeyValuePair$2(System.Windows.DependencyProperty,System.Windows.IDependencyPropertyValueEntry));
                    try {
                        while ($t1.moveNext()) {
                            var pair1 = $t1.Current;
                            if (pair1.key.Inherits) {
                                System.Windows.DependencyPropertyValueEntryExtensions.SetBaseValue(pair1.value, System.Windows.BaseValueSource.Inherited, this.inheritanceParent.GetValue(pair1.key));
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$dispose();
                        }
                    }
                    // add missing inherited values
                    $t2 = Bridge.getEnumerator(this.inheritanceParent.entries.GetKeyValuePairs(), System.Collections.Generic.KeyValuePair$2(System.Windows.DependencyProperty,System.Windows.IDependencyPropertyValueEntry));
                    try {
                        while ($t2.moveNext()) {
                            var pair2 = $t2.Current;
                            if (pair2.key.Inherits) {
                                System.Windows.DependencyPropertyValueEntryExtensions.SetBaseValue(this.GetInitializedValueEntry(pair2.key), System.Windows.BaseValueSource.Inherited, pair2.value.System$Windows$IDependencyPropertyValueEntry$Value);
                            }
                        }
                    } finally {
                        if (Bridge.is($t2, System.IDisposable)) {
                            $t2.System$IDisposable$dispose();
                        }
                    }}

                this.OnInheritanceParentChanged(oldInheritanceParent, this.inheritanceParent);
            },
            OnInheritanceParentChanged: function (oldInheritanceParent, newInheritanceParent) {
                //
            },
            OnParentPropertyChanged: function (sender, e) {
                if (e.Property.Inherits) {
                    System.Windows.DependencyPropertyValueEntryExtensions.SetBaseValue(this.GetInitializedValueEntry(e.Property), System.Windows.BaseValueSource.Inherited, e.NewValue);
                }
            }
        }
    });

    Bridge.ns("System.Windows.DependencyObject", $asm.$);

    Bridge.apply($asm.$.System.Windows.DependencyObject, {
        f1: function (dependencyProperty) {
            return dependencyProperty.StringKey;
        }
    });

    Bridge.define("System.Windows.IInputElement", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Media.Animation.IAnimatable", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.IContextElement", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Controls.IItemContainer", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Controls.ClickMode", {
        $kind: "enum",
        statics: {
            fields: {
                Release: 0,
                Press: 1
            }
        }
    });

    Bridge.define("System.Windows.Controls.IDefinitionBase", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.INotifyChanged", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.IFrameworkTemplate", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Data.IValueConverter", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Controls.Dock", {
        $kind: "enum",
        statics: {
            fields: {
                Left: 0,
                Top: 1,
                Right: 2,
                Bottom: 3
            }
        }
    });

    Bridge.define("System.Windows.Controls.ExpandDirection", {
        $kind: "enum",
        statics: {
            fields: {
                Down: 0,
                Up: 1,
                Left: 2,
                Right: 3
            }
        }
    });

    Bridge.define("System.Windows.Controls.IDataTemplateSelector", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Controls.InnerCollectionView", {
        inherits: [Granular.Collections.ICollectionView,System.Collections.Generic.IList$1(System.Object)],
        fields: {
            currentItem: null,
            currentItemIndex: 0,
            innerCollection: null
        },
        events: {
            CollectionChanged: null,
            CurrentChanged: null
        },
        props: {
            SourceCollection: {
                get: function () {
                    return this;
                }
            },
            CurrentItem: {
                get: function () {
                    return this.currentItem;
                },
                set: function (value) {
                    this.SetCurrent$1(value);
                }
            },
            CurrentItemIndex: {
                get: function () {
                    return this.currentItemIndex;
                },
                set: function (value) {
                    this.SetCurrent(value);
                }
            },
            CanFilter: {
                get: function () {
                    return false;
                }
            },
            FilterPredicate: null,
            CanSort: {
                get: function () {
                    return false;
                }
            },
            SortKeySelector: null,
            SortDirection: 0,
            Count: {
                get: function () {
                    return this.innerCollection.Count;
                }
            },
            IsReadOnly: {
                get: function () {
                    return false;
                }
            }
        },
        alias: [
            "addCollectionChanged", "Granular$Collections$INotifyCollectionChanged$addCollectionChanged",
            "removeCollectionChanged", "Granular$Collections$INotifyCollectionChanged$removeCollectionChanged",
            "addCurrentChanged", "Granular$Collections$ICollectionView$addCurrentChanged",
            "removeCurrentChanged", "Granular$Collections$ICollectionView$removeCurrentChanged",
            "SourceCollection", "Granular$Collections$ICollectionView$SourceCollection",
            "CurrentItem", "Granular$Collections$ICollectionView$CurrentItem",
            "CurrentItemIndex", "Granular$Collections$ICollectionView$CurrentItemIndex",
            "CanFilter", "Granular$Collections$ICollectionView$CanFilter",
            "FilterPredicate", "Granular$Collections$ICollectionView$FilterPredicate",
            "CanSort", "Granular$Collections$ICollectionView$CanSort",
            "SortKeySelector", "Granular$Collections$ICollectionView$SortKeySelector",
            "SortDirection", "Granular$Collections$ICollectionView$SortDirection",
            "getItem", "System$Collections$Generic$IList$1$System$Object$getItem",
            "setItem", "System$Collections$Generic$IList$1$System$Object$setItem",
            "Count", "System$Collections$Generic$ICollection$1$System$Object$Count",
            "IsReadOnly", "System$Collections$Generic$ICollection$1$System$Object$IsReadOnly",
            "add", "System$Collections$Generic$ICollection$1$System$Object$add",
            "clear", "System$Collections$Generic$ICollection$1$System$Object$clear",
            "contains", "System$Collections$Generic$ICollection$1$System$Object$contains",
            "indexOf", "System$Collections$Generic$IList$1$System$Object$indexOf",
            "insert", "System$Collections$Generic$IList$1$System$Object$insert",
            "remove", "System$Collections$Generic$ICollection$1$System$Object$remove",
            "removeAt", "System$Collections$Generic$IList$1$System$Object$removeAt",
            "copyTo", "System$Collections$Generic$ICollection$1$System$Object$copyTo",
            "getEnumerator", ["System$Collections$Generic$IEnumerable$1$System$Object$getEnumerator", "System$Collections$Generic$IEnumerable$1$getEnumerator"]
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                this.innerCollection = new (Granular.Collections.ObservableCollection$1(System.Object)).ctor();
                this.innerCollection.addCollectionChanged(Bridge.fn.cacheBind(this, this.OnInnerCollectionChanged));
            }
        },
        methods: {
            getItem: function (index) {
                return this.innerCollection.getItem(index);
            },
            setItem: function (index, value) {
                this.innerCollection.setItem(index, value);
            },
            OnInnerCollectionChanged: function (sender, e) {
                this.SetCurrent$1(this.CurrentItem);
                Granular.Collections.NotifyCollectionChangedEventHandlerExtensions.Raise(this.CollectionChanged, this, e);
            },
            SetCurrent$1: function (item) {
                var itemIndex = this.innerCollection.indexOf(item);

                if (itemIndex !== -1) {
                    this.SetCurrent$2(item, itemIndex);
                } else if (this.currentItemIndex >= 0 && this.currentItemIndex < this.innerCollection.Count) {
                    this.SetCurrent$2(this.innerCollection.getItem(this.currentItemIndex), this.currentItemIndex);
                } else {
                    this.SetCurrent$2(null, Math.min(this.currentItemIndex, this.innerCollection.Count));
                }
            },
            SetCurrent: function (itemIndex) {
                if (itemIndex >= 0 && itemIndex < this.innerCollection.Count) {
                    this.SetCurrent$2(this.innerCollection.getItem(itemIndex), itemIndex);
                } else {
                    this.SetCurrent$2(null, Math.min(itemIndex, this.innerCollection.Count));
                }
            },
            SetCurrent$2: function (item, itemIndex) {
                if (Bridge.referenceEquals(this.currentItem, item) && this.currentItemIndex === itemIndex) {
                    return;
                }

                this.currentItem = item;
                this.currentItemIndex = itemIndex;

                Granular.Extensions.EventHandlerExtensions.Raise$2(this.CurrentChanged, this);
            },
            add: function (value) {
                this.innerCollection.add(value);
            },
            clear: function () {
                this.innerCollection.clear();
            },
            contains: function (value) {
                return this.innerCollection.contains(value);
            },
            indexOf: function (value) {
                return this.innerCollection.indexOf(value);
            },
            insert: function (index, value) {
                this.innerCollection.insert(index, value);
            },
            remove: function (value) {
                return this.innerCollection.remove(value);
            },
            removeAt: function (index) {
                this.innerCollection.removeAt(index);
            },
            copyTo: function (array, arrayIndex) {
                this.innerCollection.copyTo(array, arrayIndex);
            },
            getEnumerator: function () {
                return this.innerCollection.getEnumerator();
            },
            System$Collections$IEnumerable$getEnumerator: function () {
                return this.getEnumerator();
            }
        }
    });

    Bridge.define("System.Windows.Controls.IPopupLayerHost", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Controls.IRadioButtonGroupScope", {
        $kind: "interface"
    });

    Bridge.definei("System.Windows.Controls.ISelectionGroup$1", function (T) { return {
        $kind: "interface"
    }; });

    Bridge.definei("System.Windows.Controls.ISelectionGroupScope$1", function (T) { return {
        $kind: "interface"
    }; });

    Bridge.define("System.Windows.Controls.IStyleSelector", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Controls.ItemCollection", {
        inherits: [Granular.Collections.ICollectionView,System.Collections.Generic.IList$1(System.Object)],
        fields: {
            defaultView: null,
            innerView: null,
            delegateView: null
        },
        events: {
            CollectionChanged: null,
            CurrentChanged: null
        },
        props: {
            SourceCollection: {
                get: function () {
                    return this.delegateView.Granular$Collections$ICollectionView$SourceCollection;
                }
            },
            CurrentItem: {
                get: function () {
                    return this.delegateView.Granular$Collections$ICollectionView$CurrentItem;
                },
                set: function (value) {
                    this.delegateView.Granular$Collections$ICollectionView$CurrentItem = value;
                }
            },
            CurrentItemIndex: {
                get: function () {
                    return this.delegateView.Granular$Collections$ICollectionView$CurrentItemIndex;
                },
                set: function (value) {
                    this.delegateView.Granular$Collections$ICollectionView$CurrentItemIndex = value;
                }
            },
            CanFilter: {
                get: function () {
                    return this.delegateView.Granular$Collections$ICollectionView$CanFilter;
                }
            },
            FilterPredicate: {
                get: function () {
                    return this.delegateView.Granular$Collections$ICollectionView$FilterPredicate;
                },
                set: function (value) {
                    this.delegateView.Granular$Collections$ICollectionView$FilterPredicate = value;
                }
            },
            CanSort: {
                get: function () {
                    return this.delegateView.Granular$Collections$ICollectionView$CanSort;
                }
            },
            SortKeySelector: {
                get: function () {
                    return this.delegateView.Granular$Collections$ICollectionView$SortKeySelector;
                },
                set: function (value) {
                    this.delegateView.Granular$Collections$ICollectionView$SortKeySelector = value;
                }
            },
            SortDirection: {
                get: function () {
                    return this.delegateView.Granular$Collections$ICollectionView$SortDirection;
                },
                set: function (value) {
                    this.delegateView.Granular$Collections$ICollectionView$SortDirection = value;
                }
            },
            Count: {
                get: function () {
                    return System.Linq.Enumerable.from(this.delegateView).count();
                }
            },
            IsReadOnly: {
                get: function () {
                    return false;
                }
            }
        },
        alias: [
            "addCollectionChanged", "Granular$Collections$INotifyCollectionChanged$addCollectionChanged",
            "removeCollectionChanged", "Granular$Collections$INotifyCollectionChanged$removeCollectionChanged",
            "addCurrentChanged", "Granular$Collections$ICollectionView$addCurrentChanged",
            "removeCurrentChanged", "Granular$Collections$ICollectionView$removeCurrentChanged",
            "SourceCollection", "Granular$Collections$ICollectionView$SourceCollection",
            "CurrentItem", "Granular$Collections$ICollectionView$CurrentItem",
            "CurrentItemIndex", "Granular$Collections$ICollectionView$CurrentItemIndex",
            "CanFilter", "Granular$Collections$ICollectionView$CanFilter",
            "FilterPredicate", "Granular$Collections$ICollectionView$FilterPredicate",
            "CanSort", "Granular$Collections$ICollectionView$CanSort",
            "SortKeySelector", "Granular$Collections$ICollectionView$SortKeySelector",
            "SortDirection", "Granular$Collections$ICollectionView$SortDirection",
            "getItem", "System$Collections$Generic$IList$1$System$Object$getItem",
            "setItem", "System$Collections$Generic$IList$1$System$Object$setItem",
            "Count", "System$Collections$Generic$ICollection$1$System$Object$Count",
            "add", "System$Collections$Generic$ICollection$1$System$Object$add",
            "clear", "System$Collections$Generic$ICollection$1$System$Object$clear",
            "contains", "System$Collections$Generic$ICollection$1$System$Object$contains",
            "indexOf", "System$Collections$Generic$IList$1$System$Object$indexOf",
            "insert", "System$Collections$Generic$IList$1$System$Object$insert",
            "IsReadOnly", "System$Collections$Generic$ICollection$1$System$Object$IsReadOnly",
            "remove", "System$Collections$Generic$ICollection$1$System$Object$remove",
            "removeAt", "System$Collections$Generic$IList$1$System$Object$removeAt",
            "copyTo", "System$Collections$Generic$ICollection$1$System$Object$copyTo",
            "getEnumerator", ["System$Collections$Generic$IEnumerable$1$System$Object$getEnumerator", "System$Collections$Generic$IEnumerable$1$getEnumerator"]
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                this.defaultView = new System.Windows.Controls.InnerCollectionView();
                this.SetDelegateView(this.defaultView);
            }
        },
        methods: {
            getItem: function (index) {
                return System.Linq.Enumerable.from(this.delegateView).elementAt(index);
            },
            setItem: function (index, value) {
                this.VerifyDefaultView();
                this.defaultView.setItem(index, value);
            },
            SetItemsSource: function (source) {
                if (this.innerView != null) {
                    if (Bridge.referenceEquals(this.innerView.SourceCollection, source)) {
                        return;
                    }

                    this.innerView.dispose();
                    this.innerView = null;
                }

                if (Bridge.is(source, Granular.Collections.ICollectionView)) {
                    this.SetDelegateView(Bridge.cast(source, Granular.Collections.ICollectionView));
                } else {
                    this.innerView = new System.Windows.Data.CollectionView(source);
                    this.SetDelegateView(this.innerView);
                }
            },
            ClearItemsSource: function () {
                if (this.innerView != null) {
                    this.innerView.dispose();
                    this.innerView = null;
                }

                this.SetDelegateView(this.defaultView);
            },
            SetDelegateView: function (collectionView) {
                if (Bridge.referenceEquals(this.delegateView, collectionView)) {
                    return;
                }

                var oldItems;
                if (this.delegateView != null) {
                    this.delegateView.Granular$Collections$INotifyCollectionChanged$removeCollectionChanged(Bridge.fn.cacheBind(this, this.OnDelegateViewCollectionChanged));
                    this.delegateView.Granular$Collections$ICollectionView$removeCurrentChanged(Bridge.fn.cacheBind(this, this.OnDelegateViewCurrentChanged));
                    oldItems = this.delegateView;
                } else {
                    oldItems = System.Array.init(0, null, System.Object);
                }

                this.delegateView = collectionView || System.Windows.Data.CollectionView.Empty;

                this.delegateView.Granular$Collections$INotifyCollectionChanged$addCollectionChanged(Bridge.fn.cacheBind(this, this.OnDelegateViewCollectionChanged));
                this.delegateView.Granular$Collections$ICollectionView$addCurrentChanged(Bridge.fn.cacheBind(this, this.OnDelegateViewCurrentChanged));

                Granular.Collections.NotifyCollectionChangedEventHandlerExtensions.Raise(this.CollectionChanged, this, Granular.Collections.NotifyCollectionChangedEventArgs.Reset(oldItems, this.delegateView));
                Granular.Extensions.EventHandlerExtensions.Raise$2(this.CurrentChanged, this);
            },
            OnDelegateViewCollectionChanged: function (sender, e) {
                Granular.Collections.NotifyCollectionChangedEventHandlerExtensions.Raise(this.CollectionChanged, this, e);
            },
            OnDelegateViewCurrentChanged: function (sender, e) {
                Granular.Extensions.EventHandlerExtensions.Raise$3(this.CurrentChanged, this, e);
            },
            add: function (value) {
                this.VerifyDefaultView();
                this.defaultView.add(value);
            },
            clear: function () {
                this.VerifyDefaultView();
                this.defaultView.clear();
            },
            contains: function (value) {
                this.VerifyDefaultView();
                return this.defaultView.contains(value);
            },
            indexOf: function (value) {
                return System.Array.indexOfT(System.Linq.Enumerable.from(this.delegateView).toArray(), value);
            },
            insert: function (index, value) {
                this.VerifyDefaultView();
                this.defaultView.insert(index, value);
            },
            remove: function (value) {
                this.VerifyDefaultView();
                return this.defaultView.remove(value);
            },
            removeAt: function (index) {
                this.VerifyDefaultView();
                this.defaultView.removeAt(index);
            },
            copyTo: function (array, arrayIndex) {
                var $t;
                ($t = System.Linq.Enumerable.from(this.delegateView).toArray(), System.Array.copy($t, 0, array, arrayIndex, $t.length));
            },
            VerifyDefaultView: function () {
                if (!Bridge.referenceEquals(this.delegateView, this.defaultView)) {
                    throw new Granular.Exception("Can't change ItemCollection while ItemSource is set");
                }
            },
            getEnumerator: function () {
                return Bridge.getEnumerator(this.delegateView, System.Object);
            },
            System$Collections$IEnumerable$getEnumerator: function () {
                return this.getEnumerator();
            }
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.IItemContainerGenerator", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Controls.ItemContainerGenerator.GeneratedItemContainer", {
        props: {
            Container: null,
            Item: null,
            Index: 0
        },
        ctors: {
            ctor: function (container, item, index) {
                this.$initialize();
                this.Container = container;
                this.Item = item;
                this.Index = index;
            }
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.IGeneratorHost", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Controls.ListBox.ISelectionBehavior", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Controls.Orientation", {
        $kind: "enum",
        statics: {
            fields: {
                Horizontal: 0,
                Vertical: 1
            }
        }
    });

    Bridge.define("System.Windows.RoutedEventArgs", {
        props: {
            RoutedEvent: null,
            OriginalSource: null,
            Source: null,
            Handled: false
        },
        ctors: {
            ctor: function (routedEvent, originalSource) {
                this.$initialize();
                this.RoutedEvent = routedEvent;
                this.OriginalSource = originalSource;
            }
        },
        methods: {
            InvokeEventHandler: function (handler, target) {
                if (!(Bridge.is(handler, Function))) {
                    throw new Granular.Exception("Can't dynamically invoke a non RoutedEventHandler, \"{0}\" must override InvokeEventHandler", [Bridge.Reflection.getTypeName(Bridge.getType(this))]);
                }

                handler(target, this);
            }
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.IScrollInfo", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Controls.Primitives.ItemContainerGeneratorExtensions", {
        statics: {
            methods: {
                GenerateRange: function (generator, startIndex, count) {
                    for (var i = 0; i < count; i = (i + 1) | 0) {
                        generator.System$Windows$Controls$Primitives$IItemContainerGenerator$Generate(((startIndex + i) | 0));
                    }
                },
                Remove: function (generator, index) {
                    generator.System$Windows$Controls$Primitives$IItemContainerGenerator$RemoveRange(index, 1);
                }
            }
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.ItemsChangedEventArgs", {
        props: {
            Action: 0,
            OldStartingIndex: 0,
            NewStartingIndex: 0,
            ItemsCount: 0,
            ContainersCount: 0
        },
        ctors: {
            ctor: function (action, oldStartingIndex, newStartingIndex, itemsCount, containersCount) {
                this.$initialize();
                this.Action = action;
                this.OldStartingIndex = oldStartingIndex;
                this.NewStartingIndex = newStartingIndex;
                this.ItemsCount = itemsCount;
                this.ContainersCount = containersCount;
            }
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.Placement", {
        statics: {
            methods: {
                GetPosition: function (placementMode, placementTargetRect, placementRectangle, mouseBounds, offset, popupSize, containerBounds) {
                    return System.Windows.Controls.Primitives.Placement.GetPlacement(placementMode).GetPosition(placementTargetRect, placementRectangle, mouseBounds, offset, popupSize, containerBounds);
                },
                GetPlacement: function (placementMode) {
                    switch (placementMode) {
                        case System.Windows.Controls.Primitives.PlacementMode.Absolute: 
                            return System.Windows.Controls.Primitives.Placement.AbsolutePlacement.Default;
                        case System.Windows.Controls.Primitives.PlacementMode.Relative: 
                            return System.Windows.Controls.Primitives.Placement.RelativePlacement.Default;
                        case System.Windows.Controls.Primitives.PlacementMode.Bottom: 
                            return System.Windows.Controls.Primitives.Placement.BottomPlacement.Default;
                        case System.Windows.Controls.Primitives.PlacementMode.Center: 
                            return System.Windows.Controls.Primitives.Placement.CenterPlacement.Default;
                        case System.Windows.Controls.Primitives.PlacementMode.Right: 
                            return System.Windows.Controls.Primitives.Placement.RightPlacement.Default;
                        case System.Windows.Controls.Primitives.PlacementMode.AbsolutePoint: 
                            return System.Windows.Controls.Primitives.Placement.AbsolutePointPlacement.Default;
                        case System.Windows.Controls.Primitives.PlacementMode.RelativePoint: 
                            return System.Windows.Controls.Primitives.Placement.RelativePointPlacement.Default;
                        case System.Windows.Controls.Primitives.PlacementMode.Mouse: 
                            return System.Windows.Controls.Primitives.Placement.MousePlacement.Default;
                        case System.Windows.Controls.Primitives.PlacementMode.MousePoint: 
                            return System.Windows.Controls.Primitives.Placement.MousePointPlacement.Default;
                        case System.Windows.Controls.Primitives.PlacementMode.Left: 
                            return System.Windows.Controls.Primitives.Placement.LeftPlacement.Default;
                        case System.Windows.Controls.Primitives.PlacementMode.Top: 
                            return System.Windows.Controls.Primitives.Placement.TopPlacement.Default;
                    }

                    throw new Granular.Exception("Unexpected PlacementMode \"{0}\"", [Bridge.box(placementMode, System.Windows.Controls.Primitives.PlacementMode, System.Enum.toStringFn(System.Windows.Controls.Primitives.PlacementMode))]);
                },
                GetTopLeft: function (size) {
                    return System.Windows.Point.Zero;
                },
                GetTopRight: function (size) {
                    return new System.Windows.Point.$ctor1(size.Width, 0);
                },
                GetBottomLeft: function (size) {
                    return new System.Windows.Point.$ctor1(0, size.Height);
                },
                GetBottomRight: function (size) {
                    return new System.Windows.Point.$ctor1(size.Width, size.Height);
                }
            }
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.Placement.PlacementBase", {
        statics: {
            methods: {
                GetPosition: function (targetOrigin, popupAlignmentPoint, offset) {
                    return new System.Windows.Point.$ctor1(targetOrigin.X + offset.X - popupAlignmentPoint.X, targetOrigin.Y + offset.Y - popupAlignmentPoint.Y);
                }
            }
        },
        methods: {
            GetPosition: function (placementTargetBounds, placementRectangle, mouseBounds, offset, popupSize, containerBounds) {
                var targetObjectRect = !placementTargetBounds.IsEmpty ? placementTargetBounds : containerBounds;

                var targetArea = this.GetTargetArea(targetObjectRect, placementRectangle, mouseBounds, containerBounds);

                var targetOrigin = this.GetTargetOrigin(targetArea);
                var popupAlignmentPoint = this.GetPopupAlignmentPoint(popupSize);

                // calculate initial position
                var position = System.Windows.Controls.Primitives.Placement.PlacementBase.GetPosition(targetOrigin, popupAlignmentPoint, offset);

                // check edges overflow and get alternative origin and alignment points
                if (position.X < containerBounds.Left) {
                    targetOrigin = this.GetLeftEdgeTargetOrigin(targetArea, targetOrigin);
                    popupAlignmentPoint = this.GetLeftEdgePopupAlignmentPoint(popupSize, popupAlignmentPoint);
                }

                if (position.Y < containerBounds.Top) {
                    targetOrigin = this.GetTopEdgeTargetOrigin(targetArea, targetOrigin);
                    popupAlignmentPoint = this.GetTopEdgePopupAlignmentPoint(popupSize, popupAlignmentPoint);
                }

                if (position.X + popupSize.Width > containerBounds.Right) {
                    targetOrigin = this.GetRightEdgeTargetOrigin(targetArea, targetOrigin);
                    popupAlignmentPoint = this.GetRightEdgePopupAlignmentPoint(popupSize, popupAlignmentPoint);
                }

                if (position.Y + popupSize.Height > containerBounds.Bottom) {
                    targetOrigin = this.GetBottomEdgeTargetOrigin(targetArea, targetOrigin);
                    popupAlignmentPoint = this.GetBottomEdgePopupAlignmentPoint(popupSize, popupAlignmentPoint);
                }

                // recalculate position with the alternative origin and alignment points
                position = System.Windows.Controls.Primitives.Placement.PlacementBase.GetPosition(targetOrigin, popupAlignmentPoint, offset);

                // after the recalculation, overflow can occur from opposite edges if the containerBounds is too small, so apply bounds
                return System.Windows.PointExtensions.Bounds(position, System.Windows.RectExtensions.GetTopLeft(containerBounds), System.Windows.Point.op_Subtraction(System.Windows.RectExtensions.GetBottomRight(containerBounds), System.Windows.Controls.Primitives.Placement.GetBottomRight(popupSize)));
            },
            GetTargetArea: function (targetObjectRect, placementRectangle, mouseBounds, containerBounds) {
                return !placementRectangle.IsEmpty ? System.Windows.RectExtensions.AddOffset(placementRectangle, targetObjectRect.Location) : targetObjectRect;
            },
            GetTargetOrigin: function (targetArea) {
                return System.Windows.RectExtensions.GetTopLeft(targetArea);
            },
            GetPopupAlignmentPoint: function (popupSize) {
                return System.Windows.Controls.Primitives.Placement.GetTopLeft(popupSize);
            },
            GetLeftEdgeTargetOrigin: function (targetArea, currentTargetOrigin) {
                return currentTargetOrigin;
            },
            GetRightEdgeTargetOrigin: function (targetArea, currentTargetOrigin) {
                return currentTargetOrigin;
            },
            GetTopEdgeTargetOrigin: function (targetArea, currentTargetOrigin) {
                return currentTargetOrigin;
            },
            GetBottomEdgeTargetOrigin: function (targetArea, currentTargetOrigin) {
                return currentTargetOrigin;
            },
            GetLeftEdgePopupAlignmentPoint: function (popupSize, currentAlignmentPoint) {
                return currentAlignmentPoint;
            },
            GetRightEdgePopupAlignmentPoint: function (popupSize, currentAlignmentPoint) {
                return currentAlignmentPoint;
            },
            GetTopEdgePopupAlignmentPoint: function (popupSize, currentAlignmentPoint) {
                return currentAlignmentPoint;
            },
            GetBottomEdgePopupAlignmentPoint: function (popupSize, currentAlignmentPoint) {
                return currentAlignmentPoint;
            }
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.PlacementMode", {
        $kind: "enum",
        statics: {
            fields: {
                Absolute: 0,
                Relative: 1,
                Bottom: 2,
                Center: 3,
                Right: 4,
                AbsolutePoint: 5,
                RelativePoint: 6,
                Mouse: 7,
                MousePoint: 8,
                Left: 9,
                Top: 10
            }
        }
    });

    Bridge.define("System.Windows.Documents.IAdornerLayerHost", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Controls.Primitives.ScrollEventType", {
        $kind: "enum",
        statics: {
            fields: {
                EndScroll: 0,
                LargeDecrement: 1,
                LargeIncrement: 2,
                SmallDecrement: 3,
                SmallIncrement: 4,
                ThumbTrack: 5
            }
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.ScrollInfoExtensions", {
        statics: {
            fields: {
                ScrollLineDelta: 0,
                MouseWheelDelta: 0
            },
            ctors: {
                init: function () {
                    this.ScrollLineDelta = 16;
                    this.MouseWheelDelta = 48;
                }
            },
            methods: {
                LineUp: function (scrollInfo) {
                    scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset = System.Windows.Point.op_Subtraction(scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset, new System.Windows.Point.$ctor1(0, System.Windows.Controls.Primitives.ScrollInfoExtensions.ScrollLineDelta));
                },
                LineDown: function (scrollInfo) {
                    scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset = System.Windows.Point.op_Addition(scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset, new System.Windows.Point.$ctor1(0, System.Windows.Controls.Primitives.ScrollInfoExtensions.ScrollLineDelta));
                },
                LineLeft: function (scrollInfo) {
                    scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset = System.Windows.Point.op_Subtraction(scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset, new System.Windows.Point.$ctor1(System.Windows.Controls.Primitives.ScrollInfoExtensions.ScrollLineDelta, 0));
                },
                LineRight: function (scrollInfo) {
                    scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset = System.Windows.Point.op_Addition(scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset, new System.Windows.Point.$ctor1(System.Windows.Controls.Primitives.ScrollInfoExtensions.ScrollLineDelta, 0));
                },
                PageUp: function (scrollInfo) {
                    scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset = System.Windows.Point.op_Subtraction(scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset, new System.Windows.Point.$ctor1(0, scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$ViewportSize.Height));
                },
                PageDown: function (scrollInfo) {
                    scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset = System.Windows.Point.op_Addition(scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset, new System.Windows.Point.$ctor1(0, scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$ViewportSize.Height));
                },
                PageLeft: function (scrollInfo) {
                    scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset = System.Windows.Point.op_Subtraction(scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset, new System.Windows.Point.$ctor1(scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$ViewportSize.Width, 0));
                },
                PageRight: function (scrollInfo) {
                    scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset = System.Windows.Point.op_Addition(scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset, new System.Windows.Point.$ctor1(scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$ViewportSize.Width, 0));
                },
                MouseWheelUp: function (scrollInfo) {
                    scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset = System.Windows.Point.op_Subtraction(scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset, new System.Windows.Point.$ctor1(0, System.Windows.Controls.Primitives.ScrollInfoExtensions.MouseWheelDelta));
                },
                MouseWheelDown: function (scrollInfo) {
                    scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset = System.Windows.Point.op_Addition(scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset, new System.Windows.Point.$ctor1(0, System.Windows.Controls.Primitives.ScrollInfoExtensions.MouseWheelDelta));
                },
                MouseWheelLeft: function (scrollInfo) {
                    scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset = System.Windows.Point.op_Subtraction(scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset, new System.Windows.Point.$ctor1(System.Windows.Controls.Primitives.ScrollInfoExtensions.MouseWheelDelta, 0));
                },
                MouseWheelRight: function (scrollInfo) {
                    scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset = System.Windows.Point.op_Addition(scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset, new System.Windows.Point.$ctor1(System.Windows.Controls.Primitives.ScrollInfoExtensions.MouseWheelDelta, 0));
                },
                ScrollToHome: function (scrollInfo) {
                    scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset = System.Windows.Point.Zero;
                },
                ScrollToEnd: function (scrollInfo) {
                    scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset = new System.Windows.Point.$ctor1(0, System.Windows.Controls.Primitives.ScrollInfoExtensions.GetScrollableSize(scrollInfo).Height);
                },
                ScrollToHorizontalOffset: function (scrollInfo, offset) {
                    scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset = new System.Windows.Point.$ctor1(Granular.Extensions.DoubleExtensions.Bounds(offset, 0, System.Windows.Controls.Primitives.ScrollInfoExtensions.GetScrollableSize(scrollInfo).Width), scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset.Y);
                },
                ScrollToVerticalOffset: function (scrollInfo, offset) {
                    scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset = new System.Windows.Point.$ctor1(scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset.X, Granular.Extensions.DoubleExtensions.Bounds(offset, 0, System.Windows.Controls.Primitives.ScrollInfoExtensions.GetScrollableSize(scrollInfo).Height));
                },
                GetScrollableSize: function (scrollInfo) {
                    return System.Windows.SizeExtensions.Max((System.Windows.Size.op_Subtraction(scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$ExtentSize, scrollInfo.System$Windows$Controls$Primitives$IScrollInfo$ViewportSize)), System.Windows.Size.Zero);
                }
            }
        }
    });

    Bridge.define("System.Windows.Controls.ScrollBarVisibility", {
        $kind: "enum",
        statics: {
            fields: {
                Disabled: 0,
                Auto: 1,
                Hidden: 2,
                Visible: 3
            }
        }
    });

    Bridge.define("System.Windows.Controls.SelectionMode", {
        $kind: "enum",
        statics: {
            fields: {
                Single: 0,
                Multiple: 1,
                Extended: 2
            }
        }
    });

    Bridge.define("System.Windows.Controls.SpellCheck", {
        statics: {
            fields: {
                IsEnabledProperty: null
            },
            ctors: {
                init: function () {
                    this.IsEnabledProperty = System.Windows.DependencyProperty.RegisterAttached("IsEnabled", System.Boolean, System.Windows.Controls.SpellCheck, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(true, System.Boolean, System.Boolean.toString)));
                }
            },
            methods: {
                GetIsEnabled: function (obj) {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj.GetValue(System.Windows.Controls.SpellCheck.IsEnabledProperty)), System.Boolean));
                },
                SetIsEnabled: function (obj, value) {
                    obj.SetValue(System.Windows.Controls.SpellCheck.IsEnabledProperty, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            }
        }
    });

    Bridge.define("System.Windows.Controls.StretchDirection", {
        $kind: "enum",
        statics: {
            fields: {
                UpOnly: 0,
                DownOnly: 1,
                Both: 2
            }
        }
    });

    Bridge.define("System.Windows.Controls.VisualStates", {
        statics: {
            fields: {
                CommonStates: null,
                DisabledState: null,
                PressedState: null,
                MouseOverState: null,
                NormalState: null,
                FocusStates: null,
                FocusedState: null,
                UnfocusedState: null,
                CheckStates: null,
                CheckedState: null,
                UncheckedState: null,
                IndeterminateState: null,
                ExpansionStates: null,
                ExpandedState: null,
                CollapsedState: null,
                SelectionStates: null,
                SelectedState: null,
                SelectedUnfocusedState: null,
                SelectedInactiveState: null,
                UnselectedState: null
            },
            ctors: {
                init: function () {
                    this.CommonStates = "CommonStates";
                    this.DisabledState = "Disabled";
                    this.PressedState = "Pressed";
                    this.MouseOverState = "MouseOver";
                    this.NormalState = "Normal";
                    this.FocusStates = "FocusStates";
                    this.FocusedState = "Focused";
                    this.UnfocusedState = "Unfocused";
                    this.CheckStates = "CheckStates";
                    this.CheckedState = "Checked";
                    this.UncheckedState = "Unchecked";
                    this.IndeterminateState = "Indeterminate";
                    this.ExpansionStates = "ExpansionStates";
                    this.ExpandedState = "Expanded";
                    this.CollapsedState = "Collapsed";
                    this.SelectionStates = "SelectionStates";
                    this.SelectedState = "Selected";
                    this.SelectedUnfocusedState = "SelectedUnfocused";
                    this.SelectedInactiveState = "SelectedInactive";
                    this.UnselectedState = "Unselected";
                }
            }
        }
    });

    Bridge.define("System.Windows.CornerRadius", {
        statics: {
            fields: {
                Zero: null
            },
            ctors: {
                init: function () {
                    this.Zero = new System.Windows.CornerRadius.ctor(0);
                }
            },
            methods: {
                Parse: function (value) {
                    var values = System.Linq.Enumerable.from(System.String.split(value, [44].map(function(i) {{ return String.fromCharCode(i); }}))).select($asm.$.System.Windows.CornerRadius.f1).toArray(System.Double);

                    if (values.length === 1) {
                        return new System.Windows.CornerRadius.ctor(values[System.Array.index(0, values)]);
                    }

                    if (values.length === 4) {
                        return new System.Windows.CornerRadius.$ctor1(values[System.Array.index(0, values)], values[System.Array.index(1, values)], values[System.Array.index(2, values)], values[System.Array.index(3, values)]);
                    }

                    throw new Granular.Exception("Can't parse CornerRadius value \"{0}\"", [value]);
                },
                op_Equality: function (cornerRadius1, cornerRadius2) {
                    return Bridge.equals(cornerRadius1, cornerRadius2);
                },
                op_Inequality: function (cornerRadius1, cornerRadius2) {
                    return !(System.Windows.CornerRadius.op_Equality(cornerRadius1, cornerRadius2));
                }
            }
        },
        props: {
            TopLeft: 0,
            TopRight: 0,
            BottomRight: 0,
            BottomLeft: 0,
            IsUniform: false
        },
        ctors: {
            ctor: function (uniformRadius) {
                System.Windows.CornerRadius.$ctor1.call(this, uniformRadius, uniformRadius, uniformRadius, uniformRadius);
                //
            },
            $ctor1: function (topLeft, topRight, bottomRight, bottomLeft) {
                this.$initialize();
                this.TopLeft = topLeft;
                this.TopRight = topRight;
                this.BottomRight = bottomRight;
                this.BottomLeft = bottomLeft;

                this.IsUniform = this.TopLeft === this.TopRight && this.TopLeft === this.BottomRight && this.TopLeft === this.BottomLeft;
            }
        },
        methods: {
            toString: function () {
                return this.IsUniform ? System.String.format("CornerRadius({0})", Bridge.box(this.TopLeft, System.Double, System.Double.format, System.Double.getHashCode)) : System.String.format("CornerRadius({0}, {1}, {2}, {3})", Bridge.box(this.TopLeft, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(this.TopRight, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(this.BottomRight, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(this.BottomLeft, System.Double, System.Double.format, System.Double.getHashCode));
            },
            equals: function (obj) {
                var other = Bridge.as(obj, System.Windows.CornerRadius);

                return Bridge.referenceEquals(this, other) || !Bridge.referenceEquals(other, null) && Granular.Compatibility.EqualityComparer.Double.equals2(this.TopLeft, other.TopLeft) && Granular.Compatibility.EqualityComparer.Double.equals2(this.TopRight, other.TopRight) && Granular.Compatibility.EqualityComparer.Double.equals2(this.BottomRight, other.BottomRight) && Granular.Compatibility.EqualityComparer.Double.equals2(this.BottomLeft, other.BottomLeft);
            },
            getHashCode: function () {
                return System.Double.getHashCode(this.TopLeft) ^ System.Double.getHashCode(this.TopRight) ^ System.Double.getHashCode(this.BottomRight) ^ System.Double.getHashCode(this.BottomLeft);
            }
        }
    });

    Bridge.ns("System.Windows.CornerRadius", $asm.$);

    Bridge.apply($asm.$.System.Windows.CornerRadius, {
        f1: function (v) {
            return System.Double.parse(v);
        }
    });

    Bridge.define("System.Windows.CornerRadiusExtensions", {
        statics: {
            methods: {
                DefaultIfNull: function (cornerRadius, defaultValue) {
                    if (defaultValue === void 0) { defaultValue = null; }
                    return cornerRadius || defaultValue || System.Windows.CornerRadius.Zero;
                }
            }
        }
    });

    Bridge.define("System.Windows.Markup.ITypeConverter", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.IExpressionProvider", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Data.IObservableValue", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Data.BindingMode", {
        $kind: "enum",
        statics: {
            fields: {
                TwoWay: 0,
                OneWay: 1,
                OneWayToSource: 2,
                Default: 3
            }
        }
    });

    Bridge.define("System.Windows.Data.BindingStatus", {
        $kind: "enum",
        statics: {
            fields: {
                Inactive: 0,
                Active: 1,
                Detached: 2,
                UpdateTargetError: 3,
                UpdateSourceError: 4
            }
        }
    });

    Bridge.define("System.Windows.Data.CollectionView", {
        inherits: [Granular.Collections.ICollectionView,System.IDisposable],
        statics: {
            fields: {
                Empty: null
            },
            ctors: {
                init: function () {
                    this.Empty = new System.Windows.Data.CollectionView.EmptyCollectionView();
                }
            },
            methods: {
                TranslateCollection: function (source, filterPredicate, sortKeySelector, sortDirection) {
                    var collection = source;

                    if (!Bridge.staticEquals(filterPredicate, null)) {
                        collection = System.Linq.Enumerable.from(collection).where(filterPredicate);
                    }

                    if (!Bridge.staticEquals(sortKeySelector, null)) {
                        collection = sortDirection === Granular.Collections.ListSortDirection.Ascending ? System.Linq.Enumerable.from(collection).orderBy(sortKeySelector) : System.Linq.Enumerable.from(collection).orderByDescending(sortKeySelector);
                    }

                    return collection;
                }
            }
        },
        fields: {
            currentItem: null,
            currentItemIndex: 0,
            filterPredicate: null,
            sortKeySelector: null,
            sortDirection: 0,
            innerCollection: null
        },
        events: {
            CollectionChanged: null,
            CurrentChanged: null
        },
        props: {
            SourceCollection: null,
            CurrentItem: {
                get: function () {
                    return this.currentItem;
                },
                set: function (value) {
                    this.SetCurrent$1(value);
                }
            },
            CurrentItemIndex: {
                get: function () {
                    return this.currentItemIndex;
                },
                set: function (value) {
                    this.SetCurrent(value);
                }
            },
            CanFilter: {
                get: function () {
                    return true;
                }
            },
            FilterPredicate: {
                get: function () {
                    return this.filterPredicate;
                },
                set: function (value) {
                    if (Bridge.staticEquals(this.filterPredicate, value)) {
                        return;
                    }

                    this.filterPredicate = value;
                    this.ResetInnerCollection();
                }
            },
            CanSort: {
                get: function () {
                    return true;
                }
            },
            SortKeySelector: {
                get: function () {
                    return this.sortKeySelector;
                },
                set: function (value) {
                    if (Bridge.staticEquals(this.sortKeySelector, value)) {
                        return;
                    }

                    this.sortKeySelector = value;
                    this.ResetInnerCollection();
                }
            },
            SortDirection: {
                get: function () {
                    return this.sortDirection;
                },
                set: function (value) {
                    if (this.sortDirection === value) {
                        return;
                    }

                    this.sortDirection = value;
                    this.ResetInnerCollection();
                }
            }
        },
        alias: [
            "addCollectionChanged", "Granular$Collections$INotifyCollectionChanged$addCollectionChanged",
            "removeCollectionChanged", "Granular$Collections$INotifyCollectionChanged$removeCollectionChanged",
            "addCurrentChanged", "Granular$Collections$ICollectionView$addCurrentChanged",
            "removeCurrentChanged", "Granular$Collections$ICollectionView$removeCurrentChanged",
            "SourceCollection", "Granular$Collections$ICollectionView$SourceCollection",
            "CurrentItem", "Granular$Collections$ICollectionView$CurrentItem",
            "CurrentItemIndex", "Granular$Collections$ICollectionView$CurrentItemIndex",
            "CanFilter", "Granular$Collections$ICollectionView$CanFilter",
            "FilterPredicate", "Granular$Collections$ICollectionView$FilterPredicate",
            "CanSort", "Granular$Collections$ICollectionView$CanSort",
            "SortKeySelector", "Granular$Collections$ICollectionView$SortKeySelector",
            "SortDirection", "Granular$Collections$ICollectionView$SortDirection",
            "dispose", "System$IDisposable$dispose",
            "getEnumerator", ["System$Collections$Generic$IEnumerable$1$System$Object$getEnumerator", "System$Collections$Generic$IEnumerable$1$getEnumerator"]
        ],
        ctors: {
            ctor: function (source) {
                this.$initialize();
                this.SourceCollection = source;
                this.currentItemIndex = -1;

                if (Bridge.is(this.SourceCollection, Granular.Collections.INotifyCollectionChanged)) {
                    Bridge.cast(this.SourceCollection, Granular.Collections.INotifyCollectionChanged).Granular$Collections$INotifyCollectionChanged$addCollectionChanged(Bridge.fn.cacheBind(this, this.OnSourceCollectionChanged));
                }

                this.ResetInnerCollection();
            }
        },
        methods: {
            dispose: function () {
                if (Bridge.is(this.SourceCollection, Granular.Collections.INotifyCollectionChanged)) {
                    Bridge.cast(this.SourceCollection, Granular.Collections.INotifyCollectionChanged).Granular$Collections$INotifyCollectionChanged$removeCollectionChanged(Bridge.fn.cacheBind(this, this.OnSourceCollectionChanged));
                }
            },
            SetCurrent$1: function (item) {
                var itemIndex = System.Array.indexOfT(this.innerCollection, item);

                if (itemIndex !== -1) {
                    this.SetCurrent$2(item, itemIndex);
                } else if (this.currentItemIndex >= 0 && this.currentItemIndex < this.innerCollection.length) {
                    this.SetCurrent$2(this.innerCollection[System.Array.index(this.currentItemIndex, this.innerCollection)], this.currentItemIndex);
                } else {
                    this.SetCurrent$2(null, Math.min(this.currentItemIndex, this.innerCollection.length));
                }
            },
            SetCurrent: function (itemIndex) {
                if (itemIndex >= 0 && itemIndex < this.innerCollection.length) {
                    this.SetCurrent$2(this.innerCollection[System.Array.index(itemIndex, this.innerCollection)], itemIndex);
                } else {
                    this.SetCurrent$2(null, Math.min(itemIndex, this.innerCollection.length));
                }
            },
            SetCurrent$2: function (item, itemIndex) {
                if (Bridge.referenceEquals(this.currentItem, item) && this.currentItemIndex === itemIndex) {
                    return;
                }

                this.currentItem = item;
                this.currentItemIndex = itemIndex;

                Granular.Extensions.EventHandlerExtensions.Raise$2(this.CurrentChanged, this);
            },
            ResetInnerCollection: function () {
                var oldInnerCollection = this.innerCollection || System.Array.init(0, null, System.Object);

                this.innerCollection = System.Linq.Enumerable.from(System.Windows.Data.CollectionView.TranslateCollection(System.Linq.Enumerable.from(this.SourceCollection).select(function(x) { return Bridge.cast(x, System.Object); }), this.filterPredicate, this.sortKeySelector, this.sortDirection)).toArray();

                if (System.Array.contains(this.innerCollection, this.CurrentItem, System.Object)) {
                    this.SetCurrent$1(this.CurrentItem);
                } else {
                    this.SetCurrent(this.CurrentItemIndex >= oldInnerCollection.length ? this.innerCollection.length : this.CurrentItemIndex);
                }

                Granular.Collections.NotifyCollectionChangedEventHandlerExtensions.Raise(this.CollectionChanged, this, Granular.Collections.NotifyCollectionChangedEventArgs.Reset(oldInnerCollection, this.innerCollection));
            },
            OnSourceCollectionChanged: function (sender, e) {
                var oldInnerCollection = this.innerCollection;

                this.innerCollection = System.Linq.Enumerable.from(System.Windows.Data.CollectionView.TranslateCollection(System.Linq.Enumerable.from(this.SourceCollection).select(function(x) { return Bridge.cast(x, System.Object); }), this.filterPredicate, this.sortKeySelector, this.sortDirection)).toArray();

                if (System.Array.contains(this.innerCollection, this.CurrentItem, System.Object)) {
                    this.SetCurrent$1(this.CurrentItem);
                } else {
                    this.SetCurrent(this.CurrentItemIndex >= oldInnerCollection.length ? this.innerCollection.length : this.CurrentItemIndex);
                }

                var oldItems = System.Linq.Enumerable.from(e.OldItems).intersect(oldInnerCollection).toArray(System.Object);
                var newItems = System.Linq.Enumerable.from(e.NewItems).intersect(this.innerCollection).toArray(System.Object);

                if (System.Linq.Enumerable.from(oldItems).count() > 1 || System.Linq.Enumerable.from(newItems).count() > 1) {
                    Granular.Collections.NotifyCollectionChangedEventHandlerExtensions.Raise(this.CollectionChanged, this, Granular.Collections.NotifyCollectionChangedEventArgs.Reset(oldInnerCollection, this.innerCollection));
                    return;
                }

                var oldItem = System.Linq.Enumerable.from(e.OldItems).firstOrDefault(null, null);
                var oldIndex = System.Array.findIndex(oldInnerCollection, function (item) {
                        return Granular.Compatibility.EqualityComparer.Default.equals2(item, oldItem);
                    });

                var newItem = System.Linq.Enumerable.from(e.NewItems).firstOrDefault(null, null);
                var newIndex = System.Array.findIndex(this.innerCollection, function (item) {
                        return Granular.Compatibility.EqualityComparer.Default.equals2(item, newItem);
                    });

                if (oldIndex === -1 && newIndex === -1 || Bridge.referenceEquals(oldItem, newItem) && oldIndex === newIndex) {
                    return;
                }

                if (Granular.Compatibility.EqualityComparer.Default.equals2(oldItem, newItem)) {
                    Granular.Collections.NotifyCollectionChangedEventHandlerExtensions.Raise(this.CollectionChanged, this, Granular.Collections.NotifyCollectionChangedEventArgs.Move(newItem, oldIndex, newIndex));
                } else if (oldIndex === newIndex) {
                    Granular.Collections.NotifyCollectionChangedEventHandlerExtensions.Raise(this.CollectionChanged, this, Granular.Collections.NotifyCollectionChangedEventArgs.Replace(oldItem, newItem, newIndex));
                } else {
                    if (oldIndex !== -1) {
                        Granular.Collections.NotifyCollectionChangedEventHandlerExtensions.Raise(this.CollectionChanged, this, Granular.Collections.NotifyCollectionChangedEventArgs.Remove(oldItem, oldIndex));
                    }

                    if (newIndex !== -1) {
                        Granular.Collections.NotifyCollectionChangedEventHandlerExtensions.Raise(this.CollectionChanged, this, Granular.Collections.NotifyCollectionChangedEventArgs.Add(newItem, newIndex));
                    }
                }
            },
            getEnumerator: function () {
                return System.Linq.Enumerable.from(this.innerCollection).select(function(x) { return Bridge.cast(x, System.Object); }).getEnumerator();
            },
            System$Collections$IEnumerable$getEnumerator: function () {
                return this.getEnumerator();
            }
        }
    });

    Bridge.define("System.Windows.Data.CollectionView.EmptyCollectionView", {
        inherits: [Granular.Collections.ICollectionView],
        props: {
            SourceCollection: {
                get: function () {
                    return this;
                }
            },
            CurrentItem: {
                get: function () {
                    return null;
                },
                set: function (value) { }
            },
            CurrentItemIndex: {
                get: function () {
                    return -1;
                },
                set: function (value) { }
            },
            CanFilter: {
                get: function () {
                    return false;
                }
            },
            FilterPredicate: {
                get: function () {
                    return null;
                },
                set: function (value) { }
            },
            CanSort: {
                get: function () {
                    return false;
                }
            },
            SortKeySelector: {
                get: function () {
                    return null;
                },
                set: function (value) { }
            },
            SortDirection: {
                get: function () {
                    return Granular.Collections.ListSortDirection.Ascending;
                },
                set: function (value) { }
            }
        },
        alias: [
            "addCollectionChanged", "Granular$Collections$INotifyCollectionChanged$addCollectionChanged",
            "removeCollectionChanged", "Granular$Collections$INotifyCollectionChanged$removeCollectionChanged",
            "addCurrentChanged", "Granular$Collections$ICollectionView$addCurrentChanged",
            "removeCurrentChanged", "Granular$Collections$ICollectionView$removeCurrentChanged",
            "SourceCollection", "Granular$Collections$ICollectionView$SourceCollection",
            "CurrentItem", "Granular$Collections$ICollectionView$CurrentItem",
            "CurrentItemIndex", "Granular$Collections$ICollectionView$CurrentItemIndex",
            "CanFilter", "Granular$Collections$ICollectionView$CanFilter",
            "FilterPredicate", "Granular$Collections$ICollectionView$FilterPredicate",
            "CanSort", "Granular$Collections$ICollectionView$CanSort",
            "SortKeySelector", "Granular$Collections$ICollectionView$SortKeySelector",
            "SortDirection", "Granular$Collections$ICollectionView$SortDirection",
            "getEnumerator", ["System$Collections$Generic$IEnumerable$1$System$Object$getEnumerator", "System$Collections$Generic$IEnumerable$1$getEnumerator"]
        ],
        methods: {
            addCollectionChanged: function (value) { },
            removeCollectionChanged: function (value) { },
            addCurrentChanged: function (value) { },
            removeCurrentChanged: function (value) { },
            getEnumerator: function () {
                return System.Linq.Enumerable.empty().getEnumerator();
            },
            System$Collections$IEnumerable$getEnumerator: function () {
                return this.getEnumerator();
            }
        }
    });

    Bridge.define("System.Windows.Data.NamedObject", {
        fields: {
            name: null
        },
        ctors: {
            ctor: function (name) {
                this.$initialize();
                this.name = name;
            }
        },
        methods: {
            toString: function () {
                return System.String.format("{{{0}}}", this.name);
            }
        }
    });

    Bridge.define("System.Windows.Data.ObservableValueChangedEventHandlerExtensions", {
        statics: {
            methods: {
                Raise: function (handler, sender, oldValue, newValue) {
                    if (!Bridge.staticEquals(handler, null)) {
                        handler(sender, oldValue, newValue);
                    }
                }
            }
        }
    });

    Bridge.define("System.Windows.Data.RelativeSourceMode", {
        $kind: "enum",
        statics: {
            fields: {
                TemplatedParent: 0,
                Self: 1,
                FindAncestor: 2
            }
        }
    });

    Bridge.define("System.Windows.Data.UpdateSourceTrigger", {
        $kind: "enum",
        statics: {
            fields: {
                Default: 0,
                PropertyChanged: 1,
                LostFocus: 2,
                Explicit: 3
            }
        }
    });

    Bridge.define("System.Windows.Markup.IDeferredValueKeyProvider", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.IDataTriggerConditionProvider", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.ITrigger", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.IDataTriggerCondition", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.DependencyProperty", {
        statics: {
            fields: {
                registeredProperties: null,
                registeredReadOnlyPropertiesKey: null
            },
            ctors: {
                init: function () {
                    this.registeredProperties = new (Granular.Collections.ConvertedStringDictionary$2(System.Windows.DependencyProperty.DependencyPropertyHashKey,System.Windows.DependencyProperty))($asm.$.System.Windows.DependencyProperty.f1);
                    this.registeredReadOnlyPropertiesKey = new (Granular.Collections.ConvertedStringDictionary$2(System.Windows.DependencyProperty.DependencyPropertyHashKey,System.Windows.DependencyPropertyKey))($asm.$.System.Windows.DependencyProperty.f1);
                }
            },
            methods: {
                Register$1: function (key, propertyType, metadata, validateValueCallback, isAttached, isReadOnly) {
                    if (metadata == null) {
                        metadata = new System.Windows.PropertyMetadata.ctor();
                    }

                    if (metadata.DefaultValue == null && System.TypeExtensions.GetIsValueType(propertyType)) {
                        metadata.DefaultValue = Bridge.createInstance(propertyType);
                    }

                    if (metadata.DefaultValue != null && !Bridge.Reflection.isInstanceOfType(metadata.DefaultValue, propertyType)) {
                        metadata.DefaultValue = System.Windows.DependencyProperty.ConvertDefaultValue(key, metadata.DefaultValue, propertyType);
                    }

                    var property = new System.Windows.DependencyProperty(key, propertyType, metadata, validateValueCallback, isAttached, isReadOnly);

                    if (!property.IsValidValue(metadata.DefaultValue)) {
                        throw new Granular.Exception("Default value validation of dependency property \"{0}.{1}\" failed", [Bridge.Reflection.getTypeName(key.Owner), key.Name]);
                    }

                    System.Windows.DependencyProperty.AddRegisteredProperty(key, property);

                    return property;
                },
                Register: function (name, propertyType, ownerType, metadata, validateValueCallback) {
                    if (metadata === void 0) { metadata = null; }
                    if (validateValueCallback === void 0) { validateValueCallback = null; }
                    return System.Windows.DependencyProperty.Register$1(new System.Windows.DependencyProperty.DependencyPropertyHashKey(ownerType, name), propertyType, metadata, validateValueCallback, false, false);
                },
                RegisterAttached: function (name, propertyType, ownerType, metadata, validateValueCallback) {
                    if (metadata === void 0) { metadata = null; }
                    if (validateValueCallback === void 0) { validateValueCallback = null; }
                    return System.Windows.DependencyProperty.Register$1(new System.Windows.DependencyProperty.DependencyPropertyHashKey(ownerType, name), propertyType, metadata, validateValueCallback, true, false);
                },
                RegisterReadOnly: function (name, propertyType, ownerType, metadata, validateValueCallback) {
                    if (metadata === void 0) { metadata = null; }
                    if (validateValueCallback === void 0) { validateValueCallback = null; }
                    var hashKey = new System.Windows.DependencyProperty.DependencyPropertyHashKey(ownerType, name);
                    var readOnlyKey = new System.Windows.DependencyPropertyKey(System.Windows.DependencyProperty.Register$1(hashKey, propertyType, metadata, validateValueCallback, false, true));
                    System.Windows.DependencyProperty.registeredReadOnlyPropertiesKey.Add(hashKey, readOnlyKey);
                    return readOnlyKey;
                },
                RegisterAttachedReadOnly: function (name, propertyType, ownerType, metadata, validateValueCallback) {
                    if (metadata === void 0) { metadata = null; }
                    if (validateValueCallback === void 0) { validateValueCallback = null; }
                    var key = new System.Windows.DependencyProperty.DependencyPropertyHashKey(ownerType, name);
                    var readOnlyKey = new System.Windows.DependencyPropertyKey(System.Windows.DependencyProperty.Register$1(key, propertyType, metadata, validateValueCallback, true, true));
                    System.Windows.DependencyProperty.registeredReadOnlyPropertiesKey.Add(key, readOnlyKey);
                    return readOnlyKey;
                },
                IsValidReadOnlyKey: function (key) {
                    var registeredKey = { };
                    return System.Windows.DependencyProperty.registeredReadOnlyPropertiesKey.TryGetValue(key.DependencyProperty.hashKey, registeredKey) && Bridge.referenceEquals(registeredKey.v, key);
                },
                IsValidType: function (value, propertyType) {
                    return value == null ? !System.TypeExtensions.GetIsValueType(propertyType) || Bridge.Reflection.isGenericType(propertyType) && Bridge.referenceEquals(Bridge.Reflection.getGenericTypeDefinition(propertyType), System.Nullable$1) : Bridge.Reflection.isInstanceOfType(value, propertyType);
                },
                ConvertDefaultValue: function (key, defaultValue, propertyType) {
                    try {
                        return Granular.Compatibility.Convert.ChangeType(defaultValue, propertyType);
                    }
                    catch (e) {
                        e = System.Exception.create(e);
                        throw new Granular.Exception("Dependency property \"{0}.{1}\" default value \"{2}\" cannot be converted to \"{3}\" ({4})", [Bridge.Reflection.getTypeName(key.Owner), key.Name, defaultValue, propertyType, e.Message]);
                    }
                },
                AddRegisteredProperty: function (key, dependencyProperty) {
                    System.Windows.DependencyProperty.VerifyNotRegistered(key, dependencyProperty);
                    System.Windows.DependencyProperty.registeredProperties.Add(key, dependencyProperty);
                },
                VerifyNotRegistered: function (key, dependencyProperty) {
                    var registeredDependencyProperty = { };
                    if (System.Windows.DependencyProperty.registeredProperties.TryGetValue(key, registeredDependencyProperty)) {
                        throw new Granular.Exception("Can't register dependency property \"{0}\", Type \"{1}\" already has a dependency property with the same name \"{2}\"", [dependencyProperty, Bridge.Reflection.getTypeName(key.Owner), registeredDependencyProperty.v]);
                    }
                },
                GetProperty: function (containingType, propertyName) {
                    var $t;
                    var dependencyProperty = { };

                    while (containingType != null && !Bridge.referenceEquals(containingType, System.Windows.DependencyObject)) {
                        ($t = System.TypeExtensions.GetTypeHandle(containingType), $t.$staticInit && $t.$staticInit());

                        if (System.Windows.DependencyProperty.registeredProperties.TryGetValue(new System.Windows.DependencyProperty.DependencyPropertyHashKey(containingType, propertyName), dependencyProperty)) {
                            return dependencyProperty.v;
                        }

                        containingType = Bridge.Reflection.getBaseType(containingType);
                    }

                    return null;
                }
            }
        },
        fields: {
            hashKey: null,
            typeMetadata: null,
            ownerMetadata: null,
            isMetadataOverridden: false,
            hashCode: 0,
            typeMetadataCache: null,
            typeContainsCache: null,
            orderedTypeMetadataCache: null
        },
        props: {
            Name: null,
            OwnerType: null,
            PropertyType: null,
            ValidateValueCallback: null,
            IsReadOnly: false,
            Inherits: false,
            IsAttached: false,
            StringKey: null
        },
        ctors: {
            ctor: function (hashKey, propertyType, metadata, validateValueCallback, isAttached, isReadOnly) {
                this.$initialize();
                this.hashKey = hashKey;
                this.Name = hashKey.Name;
                this.OwnerType = hashKey.Owner;
                this.PropertyType = propertyType;
                this.ValidateValueCallback = validateValueCallback;
                this.IsReadOnly = isReadOnly;
                this.Inherits = metadata.Inherits;
                this.StringKey = hashKey.StringKey;
                this.hashCode = hashKey.getHashCode();

                this.ownerMetadata = metadata;
                this.IsAttached = isAttached;

                this.typeMetadata = new (Granular.Collections.ConvertedStringDictionary$2(Function,System.Windows.PropertyMetadata))($asm.$.System.Windows.DependencyProperty.f2);
                this.typeMetadata.Granular$Collections$IMinimalDictionary$2$Function$System$Windows$PropertyMetadata$Add(this.OwnerType, this.ownerMetadata);

                this.typeMetadataCache = Granular.Collections.CacheDictionary$2(Function,System.Windows.PropertyMetadata).CreateUsingStringKeys(Bridge.fn.cacheBind(this, this.ResolveTypeMetadata), $asm.$.System.Windows.DependencyProperty.f2);
                this.typeContainsCache = Granular.Collections.CacheDictionary$2(Function,System.Boolean).CreateUsingStringKeys(Bridge.fn.cacheBind(this, this.ResolveTypeContains), $asm.$.System.Windows.DependencyProperty.f2);
            }
        },
        methods: {
            getHashCode: function () {
                return this.hashCode;
            },
            toString: function () {
                return System.String.format("{0}.{1}", Bridge.Reflection.getTypeFullName(this.OwnerType), this.Name);
            },
            IsValidValue: function (value) {
                return System.Windows.DependencyProperty.IsValidType(value, this.PropertyType) && (Bridge.staticEquals(this.ValidateValueCallback, null) || this.ValidateValueCallback(value));
            },
            OverrideMetadata: function (forType, metadata) {
                if (this.typeMetadata.Granular$Collections$IMinimalDictionary$2$Function$System$Windows$PropertyMetadata$ContainsKey(forType)) {
                    throw new Granular.Exception("DependencyProperty \"{0}\" already contains metadata for type \"{1}\"", [this, Bridge.Reflection.getTypeName(forType)]);
                }

                if (metadata.DefaultValue == null) {
                    metadata.DefaultValue = this.ownerMetadata.DefaultValue;
                }

                if (Bridge.staticEquals(metadata.CoerceValueCallback, null)) {
                    metadata.CoerceValueCallback = this.ownerMetadata.CoerceValueCallback;
                }

                if (this.Inherits !== metadata.Inherits) {
                    throw new Granular.Exception("Overriding inheritance behavior is not supported, Overrides of \"{0}\" must declare \"inherits: {1}\"", [this, Bridge.box(this.Inherits, System.Boolean, System.Boolean.toString)]);
                }

                if (this.Inherits) {
                    if (metadata.DefaultValue != null && !Bridge.referenceEquals(metadata.DefaultValue, this.ownerMetadata.DefaultValue)) {
                        throw new Granular.Exception("Overriding inherited properties metadata with different default value is not supported, Overrides of \"{0}\" cannot set a different default value other than \"{1}\"", [this, this.ownerMetadata.DefaultValue]);
                    }

                    metadata.DefaultValue = this.ownerMetadata.DefaultValue;
                }

                this.typeMetadata.Granular$Collections$IMinimalDictionary$2$Function$System$Windows$PropertyMetadata$Add(forType, metadata);

                this.typeMetadataCache.Clear();
                this.orderedTypeMetadataCache = null;

                this.isMetadataOverridden = true;
            },
            AddOwner: function (ownerType, metadata) {
                if (metadata === void 0) { metadata = null; }
                System.Windows.DependencyProperty.AddRegisteredProperty(new System.Windows.DependencyProperty.DependencyPropertyHashKey(ownerType, this.Name), this);

                if (metadata != null) {
                    this.OverrideMetadata(ownerType, metadata);
                }

                this.typeContainsCache.Clear();

                return this;
            },
            GetMetadata: function (type) {
                if (!this.isMetadataOverridden) {
                    return this.ownerMetadata;
                }

                return this.typeMetadataCache.GetValue(type);
            },
            ResolveTypeMetadata: function (type) {
                var closestBaseType = System.Linq.Enumerable.from(this.GetOrderedTypeMetadata()).where(function (baseType) {
                        return Bridge.referenceEquals(type, baseType) || (type.prototype instanceof baseType);
                    }).lastOrDefault(null, null);
                return closestBaseType != null ? Granular.Collections.MinimalDictionaryExtensions.GetValue(Bridge.global.Function, Bridge.global.System.Windows.PropertyMetadata, this.typeMetadata, closestBaseType) : this.ownerMetadata;
            },
            IsContainedBy: function (type) {
                return this.typeContainsCache.GetValue(type);
            },
            ResolveTypeContains: function (type) {
                return System.Linq.Enumerable.from(this.typeMetadata.Granular$Collections$IMinimalDictionary$2$Function$System$Windows$PropertyMetadata$GetKeys()).any(function (baseType) {
                        return Bridge.referenceEquals(type, baseType) || (type.prototype instanceof baseType);
                    });
            },
            RaiseMetadataPropertyChangedCallback: function (dependencyObject, e) {
                var $t;
                // metadata's changed callback will be raised for
                // - the original owner metadata
                // - every attached property metadata
                // - every metadata that the currently changed object derives from its owner type

                $t = Bridge.getEnumerator(this.GetOrderedTypeMetadata(), Function);
                try {
                    while ($t.moveNext()) {
                        var type = $t.Current;
                        if (!Bridge.Reflection.isInstanceOfType(dependencyObject, type) && (!this.IsAttached || !Bridge.referenceEquals(type, this.OwnerType))) {
                            continue;
                        }

                        var propertyMetadata = Granular.Collections.MinimalDictionaryExtensions.GetValue(Bridge.global.Function, Bridge.global.System.Windows.PropertyMetadata, this.typeMetadata, type);

                        if (!Bridge.staticEquals(propertyMetadata.PropertyChangedCallback, null)) {
                            propertyMetadata.PropertyChangedCallback(dependencyObject, e);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }},
            GetOrderedTypeMetadata: function () {
                if (this.orderedTypeMetadataCache == null) {
                    // topological sorting, with the original owner type first, and each base class before all of its subclasses
                    var orderedTypes = Bridge.fn.bind(this, $asm.$.System.Windows.DependencyProperty.f3)(new (System.Collections.Generic.List$1(Function)).ctor());
                    var remainingTypes = System.Linq.Enumerable.from(this.typeMetadata.Granular$Collections$IMinimalDictionary$2$Function$System$Windows$PropertyMetadata$GetKeys()).where(Bridge.fn.bind(this, $asm.$.System.Windows.DependencyProperty.f4)).toList(Function);

                    while (System.Linq.Enumerable.from(remainingTypes).any()) {
                        var nextType = System.Linq.Enumerable.from(remainingTypes).firstOrDefault(function (type1) {
                                return System.Linq.Enumerable.from(remainingTypes).all(function (type2) {
                                        return !(type1.prototype instanceof type2);
                                    });
                            }, null);
                        remainingTypes.remove(nextType);
                        orderedTypes.add(nextType);
                    }

                    this.orderedTypeMetadataCache = orderedTypes;
                }

                return this.orderedTypeMetadataCache;
            }
        }
    });

    Bridge.ns("System.Windows.DependencyProperty", $asm.$);

    Bridge.apply($asm.$.System.Windows.DependencyProperty, {
        f1: function (hashKey) {
            return hashKey.StringKey;
        },
        f2: function (type) {
            return Bridge.Reflection.getTypeFullName(type);
        },
        f3: function (_o1) {
            _o1.add(this.OwnerType);
            return _o1;
        },
        f4: function (type) {
            return !Bridge.referenceEquals(type, this.OwnerType);
        }
    });

    Bridge.define("System.Windows.DependencyProperty.DependencyPropertyHashKey", {
        props: {
            Owner: null,
            Name: null,
            StringKey: null
        },
        ctors: {
            ctor: function (owner, name) {
                this.$initialize();
                this.Owner = owner;
                this.Name = name;
                this.StringKey = (Bridge.Reflection.getTypeFullName(owner) || "") + "," + (name || "");
            }
        },
        methods: {
            equals: function (obj) {
                var other = Bridge.as(obj, System.Windows.DependencyProperty.DependencyPropertyHashKey);

                return Bridge.referenceEquals(this, other) || !Bridge.referenceEquals(other, null) && Bridge.equals(this.Owner, other.Owner) && Bridge.equals(this.Name, other.Name);
            },
            getHashCode: function () {
                return Bridge.getHashCode(this.StringKey);
            },
            toString: function () {
                return System.String.format("{0}.{1}", Bridge.Reflection.getTypeFullName(this.Owner), this.Name);
            }
        }
    });

    Bridge.define("System.Windows.DependencyPropertyChangedEventArgs", {
        props: {
            Property: null,
            NewValue: null,
            OldValue: null,
            IsSubPropertyChange: false
        },
        ctors: {
            $ctor1: function (property, oldValue, newValue) {
                System.Windows.DependencyPropertyChangedEventArgs.$ctor2.call(this, property, oldValue, newValue, false);
                //
            },
            ctor: function (property, value) {
                System.Windows.DependencyPropertyChangedEventArgs.$ctor2.call(this, property, value, value, true);
                //
            },
            $ctor2: function (property, oldValue, newValue, isSubPropertyChange) {
                this.$initialize();
                this.Property = property;
                this.OldValue = oldValue;
                this.NewValue = newValue;
                this.IsSubPropertyChange = isSubPropertyChange;
            }
        }
    });

    Bridge.define("System.Windows.DependencyPropertyChangedEventHandlerExtensions", {
        statics: {
            methods: {
                Raise: function (handler, sender, e) {
                    if (!Bridge.staticEquals(handler, null)) {
                        handler(sender, e);
                    }
                }
            }
        }
    });

    Bridge.define("System.Windows.DependencyPropertyKey", {
        props: {
            DependencyProperty: null
        },
        ctors: {
            ctor: function (dependencyProperty) {
                this.$initialize();
                this.DependencyProperty = dependencyProperty;
            }
        }
    });

    Bridge.define("System.Windows.IPropertyPathElement", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.IDependencyPropertyValueEntry", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.DependencyPropertyValueEntryExtensions", {
        statics: {
            methods: {
                GetBaseValue: function (entry, flattened) {
                    return entry.System$Windows$IDependencyPropertyValueEntry$GetValue(entry.System$Windows$IDependencyPropertyValueEntry$GetBaseValuePriority(), flattened);
                },
                GetBaseValue$1: function (entry, priority, flattened) {
                    return entry.System$Windows$IDependencyPropertyValueEntry$GetValue(priority, flattened);
                },
                SetBaseValue: function (entry, priority, value) {
                    entry.System$Windows$IDependencyPropertyValueEntry$SetValue(priority, value);
                },
                ClearBaseValue: function (entry, priority) {
                    entry.System$Windows$IDependencyPropertyValueEntry$SetValue(priority, System.Windows.Data.ObservableValue.UnsetValue);
                },
                GetCurrentValue: function (entry, flattened) {
                    return entry.System$Windows$IDependencyPropertyValueEntry$GetValue(System.Windows.DependencyPropertyValueEntry.CurrentValuePriority, flattened);
                },
                SetCurrentValue: function (entry, value) {
                    entry.System$Windows$IDependencyPropertyValueEntry$SetValue(System.Windows.DependencyPropertyValueEntry.CurrentValuePriority, value);
                },
                ClearCurrentValue: function (entry) {
                    entry.System$Windows$IDependencyPropertyValueEntry$SetValue(System.Windows.DependencyPropertyValueEntry.CurrentValuePriority, System.Windows.Data.ObservableValue.UnsetValue);
                },
                GetAnimationValue: function (entry, flattened) {
                    return entry.System$Windows$IDependencyPropertyValueEntry$GetValue(System.Windows.DependencyPropertyValueEntry.AnimationValuePriority, flattened);
                },
                SetAnimationValue: function (entry, value) {
                    entry.System$Windows$IDependencyPropertyValueEntry$SetValue(System.Windows.DependencyPropertyValueEntry.AnimationValuePriority, value);
                },
                ClearAnimationValue: function (entry) {
                    entry.System$Windows$IDependencyPropertyValueEntry$SetValue(System.Windows.DependencyPropertyValueEntry.AnimationValuePriority, System.Windows.Data.ObservableValue.UnsetValue);
                }
            }
        }
    });

    Bridge.define("System.Windows.Duration", {
        statics: {
            fields: {
                Automatic: null,
                Forever: null
            },
            ctors: {
                init: function () {
                    this.Automatic = new System.Windows.Duration.$ctor1(System.Windows.Duration.DurationType.Automatic, System.TimeSpan.zero);
                    this.Forever = new System.Windows.Duration.$ctor1(System.Windows.Duration.DurationType.Forever, System.TimeSpan.zero);
                }
            },
            methods: {
                Parse: function (value) {
                    value = value.trim();

                    if (Bridge.referenceEquals(value, "Automatic")) {
                        return System.Windows.Duration.Automatic;
                    }

                    if (Bridge.referenceEquals(value, "Forever")) {
                        return System.Windows.Duration.Forever;
                    }

                    var timeSpan = { };
                    if (Granular.Compatibility.TimeSpan.TryParse(value, timeSpan)) {
                        return new System.Windows.Duration.ctor(timeSpan.v);
                    }

                    throw new Granular.Exception("Can't parse Duration value \"{0}\"", [value]);
                }
            }
        },
        fields: {
            durationType: 0
        },
        props: {
            TimeSpan: null,
            IsAutomatic: {
                get: function () {
                    return this.durationType === System.Windows.Duration.DurationType.Automatic;
                }
            },
            IsForever: {
                get: function () {
                    return this.durationType === System.Windows.Duration.DurationType.Forever;
                }
            },
            HasTimeSpan: {
                get: function () {
                    return this.durationType === System.Windows.Duration.DurationType.TimeSpan;
                }
            }
        },
        ctors: {
            init: function () {
                this.TimeSpan = new System.TimeSpan();
            },
            ctor: function (timeSpan) {
                System.Windows.Duration.$ctor1.call(this, System.Windows.Duration.DurationType.TimeSpan, timeSpan);
                //
            },
            $ctor1: function (durationType, timeSpan) {
                this.$initialize();
                this.TimeSpan = timeSpan;
                this.durationType = durationType;
            }
        },
        methods: {
            equals: function (obj) {
                var other = Bridge.as(obj, System.Windows.Duration);

                return Bridge.referenceEquals(this, other) || !Bridge.referenceEquals(other, null) && this.durationType === other.durationType && System.TimeSpan.eq(this.TimeSpan, other.TimeSpan);
            },
            getHashCode: function () {
                return Bridge.getHashCode(this.durationType) ^ Bridge.getHashCode(this.TimeSpan);
            },
            toString: function () {
                if (this.IsAutomatic) {
                    return "Automatic";
                }

                if (this.IsForever) {
                    return "Forever";
                }

                return this.TimeSpan.toString();
            }
        }
    });

    Bridge.define("System.Windows.Duration.DurationType", {
        $kind: "enum",
        statics: {
            fields: {
                Automatic: 0,
                TimeSpan: 1,
                Forever: 2
            }
        }
    });

    Bridge.define("System.Windows.EmbeddedResourceLoader", {
        statics: {
            fields: {
                ResourceUriRegex: null,
                ResourceUriAssemblyNameGroupIndex: 0,
                ResourceUriPathGroupIndex: 0,
                resourceSetCache: null,
                resourceDataCache: null,
                resourceElementCache: null
            },
            ctors: {
                init: function () {
                    this.ResourceUriRegex = new RegExp("/([^;]*);component/(.*)");
                    this.ResourceUriAssemblyNameGroupIndex = 1;
                    this.ResourceUriPathGroupIndex = 2;
                    this.resourceSetCache = Granular.Collections.CacheDictionary$2(System.Reflection.Assembly,System.Resources.ResourceSet).CreateUsingStringKeys$1(System.Windows.EmbeddedResourceLoader.TryResolveResourceSet, $asm.$.System.Windows.EmbeddedResourceLoader.f1);
                    this.resourceDataCache = Granular.Collections.CacheDictionary$2(System.Uri,System.Array.type(System.Byte)).CreateUsingStringKeys(System.Windows.EmbeddedResourceLoader.ResolveResourceData, $asm.$.System.Windows.EmbeddedResourceLoader.f2);
                    this.resourceElementCache = Granular.Collections.CacheDictionary$2(System.Uri,System.Object).CreateUsingStringKeys(System.Windows.EmbeddedResourceLoader.ResolveResourceElement, $asm.$.System.Windows.EmbeddedResourceLoader.f2);
                }
            },
            methods: {
                LoadResourceData: function (resourceUri) {
                    System.Windows.EmbeddedResourceLoader.VerifyResourceUri(resourceUri);

                    return System.Windows.EmbeddedResourceLoader.resourceDataCache.GetValue(resourceUri);
                },
                ResolveResourceData: function (resourceUri) {
                    var assemblyName = { };
                    var resourcePath = { };
                    if (!System.Windows.EmbeddedResourceLoader.TryParseAbsolutePath(System.UriExtensions.GetAbsolutePath(resourceUri), assemblyName, resourcePath)) {
                        throw new Granular.Exception("Resource \"{0}\" absolute path is invalid", [System.UriExtensions.GetAbsoluteUri(resourceUri)]);
                    }

                    var assembly = System.Linq.Enumerable.from(System.AppDomain.getAssemblies()).where(function (a) {
                            return Bridge.referenceEquals(System.AssemblyExtensions.GetName(a).Name, assemblyName.v);
                        }).firstOrDefault(null, null);

                    if (assembly == null) {
                        assembly = Bridge.Reflection.load(assemblyName.v);
                    }

                    var resourceData = { };
                    if (!System.Windows.EmbeddedResourceLoader.TryResolveEmbeddedResourceData(assembly, assemblyName.v, resourcePath.v, resourceData) && !System.Windows.EmbeddedResourceLoader.TryResolveResourceData(assembly, resourcePath.v, resourceData)) {
                        throw new Granular.Exception("Resource \"{0}\" was not found", [System.UriExtensions.GetAbsoluteUri(resourceUri)]);
                    }

                    return resourceData.v;
                },
                TryResolveEmbeddedResourceData: function (assembly, assemblyName, resourcePath, resourceData) {
                    var embeddedResourceName = System.String.format("{0}.{1}", assemblyName, System.String.replaceAll(System.String.trimStart(resourcePath, [47]), String.fromCharCode(47), String.fromCharCode(46)));

                    resourceData.v = assembly != null ? assembly.getManifestResourceData(embeddedResourceName) : null;
                    return resourceData.v != null;
                },
                TryResolveResourceData: function (assembly, resourcePath, resourceData) {
                    resourceData.v = null;

                    var resourceSet = { };
                    if (!System.Windows.EmbeddedResourceLoader.resourceSetCache.TryGetValue(assembly, resourceSet)) {
                        return false;
                    }

                    var resourceName = System.String.trimStart(resourcePath, [47]).toLowerCase();
                    var stream = Bridge.cast(resourceSet.v.GetObject(resourceName), System.IO.Stream);
                    try {
                        if (stream == null) {
                            return false;
                        }

                        var memoryStream = new System.IO.MemoryStream.ctor();
                        try {
                            stream.CopyTo(memoryStream);
                            resourceData.v = memoryStream.ToArray();
                            return true;
                        }
                        finally {
                            if (Bridge.hasValue(memoryStream)) {
                                memoryStream.System$IDisposable$dispose();
                            }
                        }
                    }
                    finally {
                        if (Bridge.hasValue(stream)) {
                            stream.System$IDisposable$dispose();
                        }
                    }
                },
                LoadResourceElement: function (resourceUri) {
                    System.Windows.EmbeddedResourceLoader.VerifyResourceUri(resourceUri);

                    return System.Windows.EmbeddedResourceLoader.resourceElementCache.GetValue(resourceUri);
                },
                ResolveResourceElement: function (resourceUri) {
                    var resourceString = Granular.Compatibility.String.FromByteArray(System.Windows.EmbeddedResourceLoader.resourceDataCache.GetValue(resourceUri));
                    return System.Windows.Markup.XamlLoader.Load(System.Windows.Markup.XamlParser.Parse(resourceString, resourceUri));
                },
                TryResolveResourceSet: function (assembly, resourceSet) {
                    var resourceStream = System.AssemblyExtensions.GetManifestResourceStream(assembly, System.String.format("{0}.g.resources", System.AssemblyExtensions.GetName(assembly).Name));

                    if (resourceStream == null) {
                        resourceSet.v = null;
                        return false;
                    }

                    resourceSet.v = new System.Resources.ResourceSet(resourceStream);
                    return true;
                },
                TryParseAbsolutePath: function (absolutePath, assemblyName, resourcePath) {
                    var matches = System.Windows.EmbeddedResourceLoader.ResourceUriRegex.exec(absolutePath);

                    if (matches == null) {
                        assemblyName.v = null;
                        resourcePath.v = null;
                        return false;
                    }

                    assemblyName.v = matches[System.Array.index(System.Windows.EmbeddedResourceLoader.ResourceUriAssemblyNameGroupIndex, matches)];
                    resourcePath.v = matches[System.Array.index(System.Windows.EmbeddedResourceLoader.ResourceUriPathGroupIndex, matches)];
                    return true;
                },
                VerifyResourceUri: function (resourceUri) {
                    if (!System.UriExtensions.GetIsAbsoluteUri(resourceUri)) {
                        throw new Granular.Exception("Resource uri \"{0}\" must be an absolute uri", [System.UriExtensions.GetOriginalString(resourceUri)]);
                    }

                    if (!Bridge.referenceEquals(System.UriExtensions.GetScheme(resourceUri), "pack")) {
                        throw new Granular.Exception("Resource uri \"{0}\" must be a pack uri", [System.UriExtensions.GetAbsoluteUri(resourceUri)]);
                    }
                }
            }
        }
    });

    Bridge.ns("System.Windows.EmbeddedResourceLoader", $asm.$);

    Bridge.apply($asm.$.System.Windows.EmbeddedResourceLoader, {
        f1: function (assembly) {
            return assembly.name;
        },
        f2: function (uri) {
            return System.UriExtensions.GetAbsoluteUri(uri);
        }
    });

    Bridge.define("System.Windows.EmbeddedResourceLoader.UriEqualityComparer", {
        inherits: [System.Collections.Generic.IEqualityComparer$1(System.Uri)],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.EmbeddedResourceLoader.UriEqualityComparer();
                }
            }
        },
        alias: [
            "equals2", ["System$Collections$Generic$IEqualityComparer$1$System$Uri$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2"],
            "getHashCode2", ["System$Collections$Generic$IEqualityComparer$1$System$Uri$getHashCode2", "System$Collections$Generic$IEqualityComparer$1$getHashCode2"]
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                //
            }
        },
        methods: {
            equals2: function (x, y) {
                return Bridge.equals(System.UriExtensions.GetAbsoluteUri(x), System.UriExtensions.GetAbsoluteUri(y));
            },
            getHashCode2: function (obj) {
                return Bridge.getHashCode(System.UriExtensions.GetAbsoluteUri(obj));
            }
        }
    });

    Bridge.define("System.Windows.EventManager", {
        statics: {
            fields: {
                registeredEvents: null
            },
            ctors: {
                init: function () {
                    this.registeredEvents = new (Granular.Collections.ConvertedStringDictionary$2(System.Windows.EventManager.RoutedEventHashKey,System.Windows.RoutedEvent))($asm.$.System.Windows.EventManager.f1);
                }
            },
            methods: {
                RegisterRoutedEvent: function (name, routingStrategy, handlerType, ownerType) {
                    var key = new System.Windows.EventManager.RoutedEventHashKey(ownerType, name);

                    if (System.Windows.EventManager.registeredEvents.ContainsKey(key)) {
                        throw new Granular.Exception("RoutedEvent {0}.{1} is already registered", [Bridge.Reflection.getTypeName(ownerType), name]);
                    }

                    var routedEvent = new System.Windows.RoutedEvent(name, routingStrategy, handlerType, ownerType);

                    System.Windows.EventManager.registeredEvents.Add(key, routedEvent);

                    return routedEvent;
                },
                AddOwner: function (routedEvent, ownerType) {
                    var key = new System.Windows.EventManager.RoutedEventHashKey(ownerType, routedEvent.Name);

                    if (System.Windows.EventManager.registeredEvents.ContainsKey(key)) {
                        throw new Granular.Exception("Type \"{0}\" is already an owner of RoutedEvent \"{1}\"", [Bridge.Reflection.getTypeName(key.Owner), routedEvent]);
                    }

                    System.Windows.EventManager.registeredEvents.Add(key, routedEvent);
                },
                RegisterClassHandler: function (classType, routedEvent, handler, handledEventsToo) {
                    routedEvent.RegisterClassHandler(classType, new System.Windows.RoutedEventHandlerItem(handler, handledEventsToo));
                },
                GetEvent: function (containingType, eventName) {
                    var $t;
                    var routedEvent = { };

                    while (containingType != null && !Bridge.referenceEquals(containingType, System.Windows.Media.Visual)) {
                        ($t = System.TypeExtensions.GetTypeHandle(containingType), $t.$staticInit && $t.$staticInit());

                        if (System.Windows.EventManager.registeredEvents.TryGetValue(new System.Windows.EventManager.RoutedEventHashKey(containingType, eventName), routedEvent)) {
                            return routedEvent.v;
                        }

                        containingType = Bridge.Reflection.getBaseType(containingType);
                    }

                    return null;
                }
            }
        }
    });

    Bridge.ns("System.Windows.EventManager", $asm.$);

    Bridge.apply($asm.$.System.Windows.EventManager, {
        f1: function (hashKey) {
            return hashKey.KeyString;
        }
    });

    Bridge.define("System.Windows.EventManager.RoutedEventHashKey", {
        props: {
            Owner: null,
            Name: null,
            KeyString: null
        },
        ctors: {
            ctor: function (owner, name) {
                this.$initialize();
                this.Owner = owner;
                this.Name = name;
                this.KeyString = (Bridge.Reflection.getTypeFullName(owner) || "") + "," + (name || "");
            }
        },
        methods: {
            equals: function (obj) {
                var other = Bridge.as(obj, System.Windows.EventManager.RoutedEventHashKey);

                return Bridge.referenceEquals(this, other) || !Bridge.referenceEquals(other, null) && Bridge.equals(this.Owner, other.Owner) && Bridge.equals(this.Name, other.Name);
            },
            getHashCode: function () {
                return Bridge.getHashCode(this.KeyString);
            },
            toString: function () {
                return System.String.format("{0}.{1}", Bridge.Reflection.getTypeFullName(this.Owner), this.Name);
            }
        }
    });

    Bridge.define("System.Windows.EventRoute", {
        fields: {
            routedEvent: null,
            items: null
        },
        ctors: {
            ctor: function (routedEvent, items) {
                this.$initialize();
                this.routedEvent = routedEvent;
                this.items = items;
            }
        },
        methods: {
            InvokeHandlers: function (e) {
                var $t;
                $t = Bridge.getEnumerator(this.items, System.Windows.EventRouteItem);
                try {
                    while ($t.moveNext()) {
                        var item = $t.Current;
                        item.InvokeHandler(e);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }}
        }
    });

    Bridge.define("System.Windows.EventRouteItem", {
        fields: {
            handler: null,
            originalSource: null,
            source: null,
            target: null
        },
        ctors: {
            ctor: function (handler, originalSource, source, target) {
                this.$initialize();
                this.handler = handler;
                this.originalSource = originalSource;
                this.source = source;
                this.target = target;
            }
        },
        methods: {
            InvokeHandler: function (e) {
                if (!e.Handled || this.handler.HandledEventsToo) {
                    e.Source = this.source;
                    e.InvokeEventHandler(this.handler.Handler, this.target);
                }
            }
        }
    });

    Bridge.define("System.Windows.ITriggerAction", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.IEventTriggerCondition", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.FlowDirection", {
        $kind: "enum",
        statics: {
            fields: {
                LeftToRight: 0,
                TopDown: 1,
                RightToLeft: 2,
                BottomUp: 3
            }
        }
    });

    Bridge.define("System.Windows.FontStretch", {
        $kind: "enum",
        statics: {
            fields: {
                Normal: 0,
                Condensed: 1,
                Expanded: 2,
                ExtraCondensed: 3,
                ExtraExpanded: 4,
                Medium: 5,
                SemiCondensed: 6,
                SemiExpanded: 7,
                UltraCondensed: 8,
                UltraExpanded: 9
            }
        }
    });

    Bridge.define("System.Windows.FontStyle", {
        $kind: "enum",
        statics: {
            fields: {
                Normal: 0,
                Italic: 1,
                Oblique: 2
            }
        }
    });

    Bridge.define("System.Windows.FontWeight", {
        $kind: "enum",
        statics: {
            fields: {
                Normal: 0,
                Black: 1,
                Bold: 2,
                DemiBold: 3,
                ExtraBlack: 4,
                ExtraBold: 5,
                ExtraLight: 6,
                Heavy: 7,
                Light: 8,
                Medium: 9,
                Regular: 10,
                SemiBold: 11,
                Thin: 12,
                UltraBlack: 13,
                UltraBold: 14,
                UltraLight: 15
            }
        }
    });

    Bridge.define("System.Windows.IFrameworkElementFactory", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.PropertyMetadata", {
        props: {
            DefaultValue: null,
            PropertyChangedCallback: null,
            CoerceValueCallback: null,
            Inherits: false
        },
        ctors: {
            ctor: function () {
                System.Windows.PropertyMetadata.$ctor3.call(this, null, null, null);
                //
            },
            $ctor1: function (defaultValue) {
                System.Windows.PropertyMetadata.$ctor3.call(this, defaultValue, null, null);
                //
            },
            $ctor4: function (propertyChangedCallback) {
                System.Windows.PropertyMetadata.$ctor3.call(this, null, propertyChangedCallback, null);
                //
            },
            $ctor2: function (defaultValue, propertyChangedCallback) {
                System.Windows.PropertyMetadata.$ctor3.call(this, defaultValue, propertyChangedCallback, null);
                //
            },
            $ctor3: function (defaultValue, propertyChangedCallback, coerceValueCallback) {
                this.$initialize();
                this.DefaultValue = defaultValue;
                this.PropertyChangedCallback = propertyChangedCallback;
                this.CoerceValueCallback = coerceValueCallback;
            }
        }
    });

    Bridge.define("System.Windows.FrameworkPropertyMetadataOptions", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                AffectsMeasure: 1,
                AffectsArrange: 2,
                AffectsParentMeasure: 4,
                AffectsParentArrange: 8,
                AffectsRender: 16,
                Inherits: 32,
                BindsTwoWayByDefault: 256,
                AffectsVisualState: 2048
            }
        }
    });

    Bridge.define("System.Windows.FrameworkTemplateExtensions", {
        statics: {
            methods: {
                FindName: function (frameworkTemplate, name, templatedParent) {
                    return System.Windows.NameScope.GetNameScope(templatedParent.TemplateChild).System$Windows$INameScope$findName(name);
                }
            }
        }
    });

    Bridge.define("System.Windows.GridLength", {
        statics: {
            fields: {
                Auto: null,
                Star: null
            },
            ctors: {
                init: function () {
                    this.Auto = new System.Windows.GridLength(System.Windows.GridUnitType.Auto, 0);
                    this.Star = new System.Windows.GridLength(System.Windows.GridUnitType.Star, 1);
                }
            },
            methods: {
                FromPixles: function (pixels) {
                    return new System.Windows.GridLength(System.Windows.GridUnitType.Pixel, pixels);
                },
                FromStars: function (stars) {
                    return new System.Windows.GridLength(System.Windows.GridUnitType.Star, stars);
                }
            }
        },
        props: {
            GridUnitType: 0,
            Value: 0,
            IsAuto: {
                get: function () {
                    return this.GridUnitType === System.Windows.GridUnitType.Auto;
                }
            },
            IsAbsolute: {
                get: function () {
                    return this.GridUnitType === System.Windows.GridUnitType.Pixel;
                }
            },
            IsStar: {
                get: function () {
                    return this.GridUnitType === System.Windows.GridUnitType.Star;
                }
            }
        },
        ctors: {
            ctor: function (gridUnitType, value) {
                this.$initialize();
                this.GridUnitType = gridUnitType;
                this.Value = value;
            }
        },
        methods: {
            equals: function (obj) {
                var other = Bridge.as(obj, System.Windows.GridLength);

                return Bridge.referenceEquals(this, other) || !Bridge.referenceEquals(other, null) && this.GridUnitType === other.GridUnitType && Granular.Compatibility.EqualityComparer.Double.equals2(this.Value, other.Value);
            },
            getHashCode: function () {
                return Bridge.getHashCode(this.GridUnitType) ^ System.Double.getHashCode(this.Value);
            },
            toString: function () {
                return this.IsAuto ? "Auto" : System.String.format("{0}{1}", Bridge.box(this.Value, System.Double, System.Double.format, System.Double.getHashCode), this.IsAbsolute ? "px" : "*");
            }
        }
    });

    Bridge.define("System.Windows.GridUnitType", {
        $kind: "enum",
        statics: {
            fields: {
                Auto: 0,
                Pixel: 1,
                Star: 2
            }
        }
    });

    Bridge.define("System.Windows.HorizontalAlignment", {
        $kind: "enum",
        statics: {
            fields: {
                Left: 0,
                Center: 1,
                Right: 2,
                Stretch: 3
            }
        }
    });

    Bridge.define("System.Windows.IApplicationHost", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.IInputElementExtensions", {
        statics: {
            methods: {
                RaiseEvents: function (element, previewEventArgs, eventArgs) {
                    element.System$Windows$IInputElement$RaiseEvent(previewEventArgs);

                    eventArgs.Handled = previewEventArgs.Handled;
                    element.System$Windows$IInputElement$RaiseEvent(eventArgs);

                    return eventArgs.Handled;
                }
            }
        }
    });

    Bridge.define("System.Windows.INameScope", {
        inherits: [System.Collections.Generic.IEnumerable$1(System.Collections.Generic.KeyValuePair$2(System.String,System.Object))],
        $kind: "interface"
    });

    Bridge.define("System.Windows.Input.Cursor", {
        props: {
            CursorType: 0,
            ImageSource: null,
            Hotspot: null
        },
        ctors: {
            ctor: function (cursorType) {
                System.Windows.Input.Cursor.$ctor1.call(this, cursorType, null, null);
                //
            },
            $ctor2: function (imageSource, hotspot) {
                if (hotspot === void 0) { hotspot = null; }

                System.Windows.Input.Cursor.$ctor1.call(this, System.Windows.Input.CursorType.None, imageSource, hotspot);
                //
            },
            $ctor1: function (cursorType, imageSource, hotspot) {
                this.$initialize();
                this.CursorType = cursorType;
                this.ImageSource = imageSource;
                this.Hotspot = hotspot;
            }
        },
        methods: {
            toString: function () {
                return System.String.format("Cursor({0})", this.ImageSource != null ? this.ImageSource.toString() : System.Enum.toString(System.Windows.Input.CursorType, this.CursorType));
            }
        }
    });

    Bridge.define("System.Windows.Input.Cursors", {
        statics: {
            fields: {
                cursors: null
            },
            props: {
                None: {
                    get: function () {
                        return System.Windows.Input.Cursors.cursors.GetValue(System.Windows.Input.CursorType.None);
                    }
                },
                No: {
                    get: function () {
                        return System.Windows.Input.Cursors.cursors.GetValue(System.Windows.Input.CursorType.No);
                    }
                },
                Arrow: {
                    get: function () {
                        return System.Windows.Input.Cursors.cursors.GetValue(System.Windows.Input.CursorType.Arrow);
                    }
                },
                AppStarting: {
                    get: function () {
                        return System.Windows.Input.Cursors.cursors.GetValue(System.Windows.Input.CursorType.AppStarting);
                    }
                },
                Cross: {
                    get: function () {
                        return System.Windows.Input.Cursors.cursors.GetValue(System.Windows.Input.CursorType.Cross);
                    }
                },
                Help: {
                    get: function () {
                        return System.Windows.Input.Cursors.cursors.GetValue(System.Windows.Input.CursorType.Help);
                    }
                },
                IBeam: {
                    get: function () {
                        return System.Windows.Input.Cursors.cursors.GetValue(System.Windows.Input.CursorType.IBeam);
                    }
                },
                SizeAll: {
                    get: function () {
                        return System.Windows.Input.Cursors.cursors.GetValue(System.Windows.Input.CursorType.SizeAll);
                    }
                },
                SizeNESW: {
                    get: function () {
                        return System.Windows.Input.Cursors.cursors.GetValue(System.Windows.Input.CursorType.SizeNESW);
                    }
                },
                SizeNS: {
                    get: function () {
                        return System.Windows.Input.Cursors.cursors.GetValue(System.Windows.Input.CursorType.SizeNS);
                    }
                },
                SizeNWSE: {
                    get: function () {
                        return System.Windows.Input.Cursors.cursors.GetValue(System.Windows.Input.CursorType.SizeNWSE);
                    }
                },
                SizeWE: {
                    get: function () {
                        return System.Windows.Input.Cursors.cursors.GetValue(System.Windows.Input.CursorType.SizeWE);
                    }
                },
                UpArrow: {
                    get: function () {
                        return System.Windows.Input.Cursors.cursors.GetValue(System.Windows.Input.CursorType.UpArrow);
                    }
                },
                Wait: {
                    get: function () {
                        return System.Windows.Input.Cursors.cursors.GetValue(System.Windows.Input.CursorType.Wait);
                    }
                },
                Hand: {
                    get: function () {
                        return System.Windows.Input.Cursors.cursors.GetValue(System.Windows.Input.CursorType.Hand);
                    }
                },
                Pen: {
                    get: function () {
                        return System.Windows.Input.Cursors.cursors.GetValue(System.Windows.Input.CursorType.Pen);
                    }
                },
                ScrollNS: {
                    get: function () {
                        return System.Windows.Input.Cursors.cursors.GetValue(System.Windows.Input.CursorType.ScrollNS);
                    }
                },
                ScrollWE: {
                    get: function () {
                        return System.Windows.Input.Cursors.cursors.GetValue(System.Windows.Input.CursorType.ScrollWE);
                    }
                },
                ScrollAll: {
                    get: function () {
                        return System.Windows.Input.Cursors.cursors.GetValue(System.Windows.Input.CursorType.ScrollAll);
                    }
                },
                ScrollN: {
                    get: function () {
                        return System.Windows.Input.Cursors.cursors.GetValue(System.Windows.Input.CursorType.ScrollN);
                    }
                },
                ScrollS: {
                    get: function () {
                        return System.Windows.Input.Cursors.cursors.GetValue(System.Windows.Input.CursorType.ScrollS);
                    }
                },
                ScrollW: {
                    get: function () {
                        return System.Windows.Input.Cursors.cursors.GetValue(System.Windows.Input.CursorType.ScrollW);
                    }
                },
                ScrollE: {
                    get: function () {
                        return System.Windows.Input.Cursors.cursors.GetValue(System.Windows.Input.CursorType.ScrollE);
                    }
                },
                ScrollNW: {
                    get: function () {
                        return System.Windows.Input.Cursors.cursors.GetValue(System.Windows.Input.CursorType.ScrollNW);
                    }
                },
                ScrollNE: {
                    get: function () {
                        return System.Windows.Input.Cursors.cursors.GetValue(System.Windows.Input.CursorType.ScrollNE);
                    }
                },
                ScrollSW: {
                    get: function () {
                        return System.Windows.Input.Cursors.cursors.GetValue(System.Windows.Input.CursorType.ScrollSW);
                    }
                },
                ScrollSE: {
                    get: function () {
                        return System.Windows.Input.Cursors.cursors.GetValue(System.Windows.Input.CursorType.ScrollSE);
                    }
                },
                ArrowCD: {
                    get: function () {
                        return System.Windows.Input.Cursors.cursors.GetValue(System.Windows.Input.CursorType.ArrowCD);
                    }
                }
            },
            ctors: {
                init: function () {
                    this.cursors = Granular.Collections.CacheDictionary$2(System.Windows.Input.CursorType,System.Windows.Input.Cursor).Create($asm.$.System.Windows.Input.Cursors.f1);
                }
            }
        }
    });

    Bridge.ns("System.Windows.Input.Cursors", $asm.$);

    Bridge.apply($asm.$.System.Windows.Input.Cursors, {
        f1: function (cursorType) {
            return new System.Windows.Input.Cursor.ctor(cursorType);
        }
    });

    Bridge.define("System.Windows.Input.CursorType", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                No: 1,
                Arrow: 2,
                AppStarting: 3,
                Cross: 4,
                Help: 5,
                IBeam: 6,
                SizeAll: 7,
                SizeNESW: 8,
                SizeNS: 9,
                SizeNWSE: 10,
                SizeWE: 11,
                UpArrow: 12,
                Wait: 13,
                Hand: 14,
                Pen: 15,
                ScrollNS: 16,
                ScrollWE: 17,
                ScrollAll: 18,
                ScrollN: 19,
                ScrollS: 20,
                ScrollW: 21,
                ScrollE: 22,
                ScrollNW: 23,
                ScrollNE: 24,
                ScrollSW: 25,
                ScrollSE: 26,
                ArrowCD: 27
            }
        }
    });

    Bridge.define("System.Windows.Input.FocusManager", {
        statics: {
            fields: {
                GotFocusEvent: null,
                LostFocusEvent: null,
                FocusedElementProperty: null,
                IsFocusScopeProperty: null
            },
            ctors: {
                init: function () {
                    this.GotFocusEvent = System.Windows.EventManager.RegisterRoutedEvent("GotFocus", System.Windows.RoutingStrategy.Bubble, Function, System.Windows.Input.FocusManager);
                    this.LostFocusEvent = System.Windows.EventManager.RegisterRoutedEvent("LostFocus", System.Windows.RoutingStrategy.Bubble, Function, System.Windows.Input.FocusManager);
                    this.FocusedElementProperty = System.Windows.DependencyProperty.RegisterAttached("FocusedElement", System.Windows.IInputElement, System.Windows.Input.FocusManager, new System.Windows.FrameworkPropertyMetadata.$ctor6(null, System.Windows.Input.FocusManager.OnFocusedElementChanged));
                    this.IsFocusScopeProperty = System.Windows.DependencyProperty.RegisterAttached("IsFocusScope", System.Boolean, System.Windows.Input.FocusManager, new System.Windows.FrameworkPropertyMetadata.ctor());
                }
            },
            methods: {
                GetFocusedElement: function (obj) {
                    return Bridge.cast(obj.GetValue(System.Windows.Input.FocusManager.FocusedElementProperty), System.Windows.IInputElement);
                },
                SetFocusedElement: function (obj, value) {
                    obj.SetValue(System.Windows.Input.FocusManager.FocusedElementProperty, value);
                },
                GetIsFocusScope: function (obj) {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj.GetValue(System.Windows.Input.FocusManager.IsFocusScopeProperty)), System.Boolean));
                },
                SetIsFocusScope: function (obj, value) {
                    obj.SetValue(System.Windows.Input.FocusManager.IsFocusScopeProperty, Bridge.box(value, System.Boolean, System.Boolean.toString));
                },
                GetFocusScope: function (element) {
                    while (element != null && !System.Windows.Input.FocusManager.GetIsFocusScope(element)) {
                        element = Bridge.cast((element.LogicalParent || element.VisualParent), System.Windows.UIElement);
                    }

                    return element;
                },
                Focus: function (element) {
                    if (!element.Focusable) {
                        return null;
                    }

                    var focusScope = System.Windows.Input.FocusManager.GetFocusScope(element);

                    if (focusScope != null) {
                        System.Windows.Input.FocusManager.SetFocusedElement(focusScope, element);
                        return new Granular.Disposable(function () {
                            if (Bridge.referenceEquals(System.Windows.Input.FocusManager.GetFocusedElement(focusScope), element)) {
                                System.Windows.Input.FocusManager.SetFocusedElement(focusScope, null);
                            }
                        });
                    }

                    return null;
                },
                OnFocusedElementChanged: function (d, e) {
                    var oldElement = Bridge.cast(e.OldValue, System.Windows.FrameworkElement);
                    var newElement = Bridge.cast(e.NewValue, System.Windows.FrameworkElement);

                    if (oldElement != null) {
                        oldElement.RaiseEvent(new System.Windows.RoutedEventArgs(System.Windows.Input.FocusManager.LostFocusEvent, oldElement));
                    }

                    if (newElement != null) {
                        newElement.RaiseEvent(new System.Windows.RoutedEventArgs(System.Windows.Input.FocusManager.GotFocusEvent, newElement));
                    }
                }
            }
        }
    });

    Bridge.define("System.Windows.Input.FocusNavigationDirection", {
        $kind: "enum",
        statics: {
            fields: {
                Next: 0,
                Previous: 1,
                First: 2,
                Last: 3,
                Left: 4,
                Right: 5,
                Up: 6,
                Down: 7
            }
        }
    });

    Bridge.define("System.Windows.Input.IInputDevice", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Input.Key", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                Cancel: 1,
                Back: 2,
                Tab: 3,
                LineFeed: 4,
                Clear: 5,
                Return: 6,
                Enter: 6,
                Pause: 7,
                CapsLock: 8,
                Capital: 8,
                HangulMode: 9,
                KanaMode: 9,
                JunjaMode: 10,
                FinalMode: 11,
                KanjiMode: 12,
                HanjaMode: 12,
                Escape: 13,
                ImeConvert: 14,
                ImeNonConvert: 15,
                ImeAccept: 16,
                ImeModeChange: 17,
                Space: 18,
                PageUp: 19,
                Prior: 19,
                PageDown: 20,
                Next: 20,
                End: 21,
                Home: 22,
                Left: 23,
                Up: 24,
                Right: 25,
                Down: 26,
                Select: 27,
                Print: 28,
                Execute: 29,
                Snapshot: 30,
                PrintScreen: 30,
                Insert: 31,
                Delete: 32,
                Help: 33,
                D0: 34,
                D1: 35,
                D2: 36,
                D3: 37,
                D4: 38,
                D5: 39,
                D6: 40,
                D7: 41,
                D8: 42,
                D9: 43,
                A: 44,
                B: 45,
                C: 46,
                D: 47,
                E: 48,
                F: 49,
                G: 50,
                H: 51,
                I: 52,
                J: 53,
                K: 54,
                L: 55,
                M: 56,
                N: 57,
                O: 58,
                P: 59,
                Q: 60,
                R: 61,
                S: 62,
                T: 63,
                U: 64,
                V: 65,
                W: 66,
                X: 67,
                Y: 68,
                Z: 69,
                LWin: 70,
                RWin: 71,
                Apps: 72,
                Sleep: 73,
                NumPad0: 74,
                NumPad1: 75,
                NumPad2: 76,
                NumPad3: 77,
                NumPad4: 78,
                NumPad5: 79,
                NumPad6: 80,
                NumPad7: 81,
                NumPad8: 82,
                NumPad9: 83,
                Multiply: 84,
                Add: 85,
                Separator: 86,
                Subtract: 87,
                Decimal: 88,
                Divide: 89,
                F1: 90,
                F2: 91,
                F3: 92,
                F4: 93,
                F5: 94,
                F6: 95,
                F7: 96,
                F8: 97,
                F9: 98,
                F10: 99,
                F11: 100,
                F12: 101,
                F13: 102,
                F14: 103,
                F15: 104,
                F16: 105,
                F17: 106,
                F18: 107,
                F19: 108,
                F20: 109,
                F21: 110,
                F22: 111,
                F23: 112,
                F24: 113,
                NumLock: 114,
                Scroll: 115,
                LeftShift: 116,
                RightShift: 117,
                LeftCtrl: 118,
                RightCtrl: 119,
                LeftAlt: 120,
                RightAlt: 121,
                BrowserBack: 122,
                BrowserForward: 123,
                BrowserRefresh: 124,
                BrowserStop: 125,
                BrowserSearch: 126,
                BrowserFavorites: 127,
                BrowserHome: 128,
                VolumeMute: 129,
                VolumeDown: 130,
                VolumeUp: 131,
                MediaNextTrack: 132,
                MediaPreviousTrack: 133,
                MediaStop: 134,
                MediaPlayPause: 135,
                LaunchMail: 136,
                SelectMedia: 137,
                LaunchApplication1: 138,
                LaunchApplication2: 139,
                OemSemicolon: 140,
                Oem1: 140,
                OemPlus: 141,
                OemComma: 142,
                OemMinus: 143,
                OemPeriod: 144,
                OemQuestion: 145,
                Oem2: 145,
                OemTilde: 146,
                Oem3: 146,
                AbntC1: 147,
                AbntC2: 148,
                OemOpenBrackets: 149,
                Oem4: 149,
                OemPipe: 150,
                Oem5: 150,
                OemCloseBrackets: 151,
                Oem6: 151,
                OemQuotes: 152,
                Oem7: 152,
                Oem8: 153,
                OemBackslash: 154,
                Oem102: 154,
                ImeProcessed: 155,
                System: 156,
                OemAttn: 157,
                DbeAlphanumeric: 157,
                OemFinish: 158,
                DbeKatakana: 158,
                DbeHiragana: 159,
                OemCopy: 159,
                DbeSbcsChar: 160,
                OemAuto: 160,
                DbeDbcsChar: 161,
                OemEnlw: 161,
                OemBackTab: 162,
                DbeRoman: 162,
                DbeNoRoman: 163,
                Attn: 163,
                CrSel: 164,
                DbeEnterWordRegisterMode: 164,
                ExSel: 165,
                DbeEnterImeConfigureMode: 165,
                EraseEof: 166,
                DbeFlushString: 166,
                Play: 167,
                DbeCodeInput: 167,
                DbeNoCodeInput: 168,
                Zoom: 168,
                NoName: 169,
                DbeDetermineString: 169,
                DbeEnterDialogConversionMode: 170,
                Pa1: 170,
                OemClear: 171,
                DeadCharProcessed: 172
            }
        }
    });

    Bridge.define("System.Windows.Input.Keyboard", {
        statics: {
            fields: {
                PreviewKeyDownEvent: null,
                PreviewKeyUpEvent: null,
                PreviewGotKeyboardFocusEvent: null,
                PreviewLostKeyboardFocusEvent: null,
                KeyDownEvent: null,
                KeyUpEvent: null,
                GotKeyboardFocusEvent: null,
                LostKeyboardFocusEvent: null
            },
            ctors: {
                init: function () {
                    this.PreviewKeyDownEvent = System.Windows.EventManager.RegisterRoutedEvent("PreviewKeyDown", System.Windows.RoutingStrategy.Tunnel, Function, System.Windows.Input.Keyboard);
                    this.PreviewKeyUpEvent = System.Windows.EventManager.RegisterRoutedEvent("PreviewKeyUp", System.Windows.RoutingStrategy.Tunnel, Function, System.Windows.Input.Keyboard);
                    this.PreviewGotKeyboardFocusEvent = System.Windows.EventManager.RegisterRoutedEvent("PreviewGotKeyboardFocus", System.Windows.RoutingStrategy.Tunnel, Function, System.Windows.Input.Keyboard);
                    this.PreviewLostKeyboardFocusEvent = System.Windows.EventManager.RegisterRoutedEvent("PreviewLostKeyboardFocus", System.Windows.RoutingStrategy.Tunnel, Function, System.Windows.Input.Keyboard);
                    this.KeyDownEvent = System.Windows.EventManager.RegisterRoutedEvent("KeyDown", System.Windows.RoutingStrategy.Bubble, Function, System.Windows.Input.Keyboard);
                    this.KeyUpEvent = System.Windows.EventManager.RegisterRoutedEvent("KeyUp", System.Windows.RoutingStrategy.Bubble, Function, System.Windows.Input.Keyboard);
                    this.GotKeyboardFocusEvent = System.Windows.EventManager.RegisterRoutedEvent("GotKeyboardFocus", System.Windows.RoutingStrategy.Bubble, Function, System.Windows.Input.Keyboard);
                    this.LostKeyboardFocusEvent = System.Windows.EventManager.RegisterRoutedEvent("LostKeyboardFocus", System.Windows.RoutingStrategy.Bubble, Function, System.Windows.Input.Keyboard);
                }
            },
            methods: {
                Focus: function (element) {
                    var keyboardDevice = System.Windows.ApplicationHostExtensions.GetKeyboardDeviceFromElement(System.Windows.ApplicationHost.Current, Bridge.cast(element, System.Windows.FrameworkElement));
                    return keyboardDevice != null ? keyboardDevice.Focus(element) : null;
                }
            }
        }
    });

    Bridge.define("System.Windows.Input.KeyboardNavigation", {
        inherits: [System.IDisposable],
        statics: {
            fields: {
                TabNavigationProperty: null,
                ControlTabNavigationProperty: null,
                DirectionalNavigationProperty: null,
                IsTabStopProperty: null,
                TabIndexProperty: null,
                NavigationFocusElementProperty: null
            },
            ctors: {
                init: function () {
                    this.TabNavigationProperty = System.Windows.DependencyProperty.RegisterAttached("TabNavigation", System.Windows.Input.KeyboardNavigationMode, System.Windows.Input.KeyboardNavigation, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(System.Windows.Input.KeyboardNavigationMode.Continue, System.Windows.Input.KeyboardNavigationMode, System.Enum.toStringFn(System.Windows.Input.KeyboardNavigationMode))));
                    this.ControlTabNavigationProperty = System.Windows.DependencyProperty.RegisterAttached("ControlTabNavigation", System.Windows.Input.KeyboardNavigationMode, System.Windows.Input.KeyboardNavigation, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(System.Windows.Input.KeyboardNavigationMode.Continue, System.Windows.Input.KeyboardNavigationMode, System.Enum.toStringFn(System.Windows.Input.KeyboardNavigationMode))));
                    this.DirectionalNavigationProperty = System.Windows.DependencyProperty.RegisterAttached("DirectionalNavigation", System.Windows.Input.KeyboardNavigationMode, System.Windows.Input.KeyboardNavigation, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(System.Windows.Input.KeyboardNavigationMode.Continue, System.Windows.Input.KeyboardNavigationMode, System.Enum.toStringFn(System.Windows.Input.KeyboardNavigationMode))));
                    this.IsTabStopProperty = System.Windows.DependencyProperty.RegisterAttached("IsTabStop", System.Boolean, System.Windows.Input.KeyboardNavigation, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(true, System.Boolean, System.Boolean.toString)));
                    this.TabIndexProperty = System.Windows.DependencyProperty.RegisterAttached("TabIndex", System.Int32, System.Windows.Input.KeyboardNavigation, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(2147483647, System.Int32)));
                    this.NavigationFocusElementProperty = System.Windows.DependencyProperty.RegisterAttached("NavigationFocusElement", System.Windows.Media.VisualWeakReference, System.Windows.Input.KeyboardNavigation, new System.Windows.FrameworkPropertyMetadata.ctor());
                }
            },
            methods: {
                GetTabNavigation: function (obj) {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj.GetValue(System.Windows.Input.KeyboardNavigation.TabNavigationProperty)), System.Int32));
                },
                SetTabNavigation: function (obj, value) {
                    obj.SetValue(System.Windows.Input.KeyboardNavigation.TabNavigationProperty, Bridge.box(value, System.Windows.Input.KeyboardNavigationMode, System.Enum.toStringFn(System.Windows.Input.KeyboardNavigationMode)));
                },
                GetControlTabNavigation: function (obj) {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj.GetValue(System.Windows.Input.KeyboardNavigation.ControlTabNavigationProperty)), System.Int32));
                },
                SetControlTabNavigation: function (obj, value) {
                    obj.SetValue(System.Windows.Input.KeyboardNavigation.ControlTabNavigationProperty, Bridge.box(value, System.Windows.Input.KeyboardNavigationMode, System.Enum.toStringFn(System.Windows.Input.KeyboardNavigationMode)));
                },
                GetDirectionalNavigation: function (obj) {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj.GetValue(System.Windows.Input.KeyboardNavigation.DirectionalNavigationProperty)), System.Int32));
                },
                SetDirectionalNavigation: function (obj, value) {
                    obj.SetValue(System.Windows.Input.KeyboardNavigation.DirectionalNavigationProperty, Bridge.box(value, System.Windows.Input.KeyboardNavigationMode, System.Enum.toStringFn(System.Windows.Input.KeyboardNavigationMode)));
                },
                GetIsTabStop: function (obj) {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj.GetValue(System.Windows.Input.KeyboardNavigation.IsTabStopProperty)), System.Boolean));
                },
                SetIsTabStop: function (obj, value) {
                    obj.SetValue(System.Windows.Input.KeyboardNavigation.IsTabStopProperty, Bridge.box(value, System.Boolean, System.Boolean.toString));
                },
                GetTabIndex: function (obj) {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj.GetValue(System.Windows.Input.KeyboardNavigation.TabIndexProperty)), System.Int32));
                },
                SetTabIndex: function (obj, value) {
                    obj.SetValue(System.Windows.Input.KeyboardNavigation.TabIndexProperty, Bridge.box(value, System.Int32));
                },
                GetNavigationFocusElement: function (obj) {
                    return Bridge.cast(obj.GetValue(System.Windows.Input.KeyboardNavigation.NavigationFocusElementProperty), System.Windows.Media.VisualWeakReference);
                },
                SetNavigationFocusElement: function (obj, value) {
                    obj.SetValue(System.Windows.Input.KeyboardNavigation.NavigationFocusElementProperty, value);
                },
                SetNavigationFocusElement$1: function (focusedElement) {
                    var navigationScope = System.Windows.Input.KeyboardNavigation.GetNavigationScope(focusedElement);
                    if (navigationScope != null) {
                        var visualWeakReference = System.Windows.Input.KeyboardNavigation.GetNavigationFocusElement(focusedElement);
                        System.Windows.Input.KeyboardNavigation.SetNavigationFocusElement(navigationScope, new System.Windows.Media.VisualWeakReference(focusedElement, navigationScope));
                    }
                },
                TryGetNavigationMode: function (e, navigationModeProperty, navigationDirection) {
                    navigationModeProperty.v = null;
                    navigationDirection.v = System.Windows.Input.FocusNavigationDirection.Next;

                    if (!e.IsDown) {
                        return false;
                    }

                    if (e.Key === System.Windows.Input.Key.Tab) {
                        navigationModeProperty.v = (e.KeyboardDevice.Modifiers & System.Windows.Input.ModifierKeys.Control) === 0 ? System.Windows.Input.KeyboardNavigation.TabNavigationProperty : System.Windows.Input.KeyboardNavigation.ControlTabNavigationProperty;
                        navigationDirection.v = (e.KeyboardDevice.Modifiers & System.Windows.Input.ModifierKeys.Shift) === 0 ? System.Windows.Input.FocusNavigationDirection.Next : System.Windows.Input.FocusNavigationDirection.Previous;
                        return true;
                    }

                    if (e.Key === System.Windows.Input.Key.Left) {
                        navigationModeProperty.v = System.Windows.Input.KeyboardNavigation.DirectionalNavigationProperty;
                        navigationDirection.v = System.Windows.Input.FocusNavigationDirection.Left;
                        return true;
                    }

                    if (e.Key === System.Windows.Input.Key.Right) {
                        navigationModeProperty.v = System.Windows.Input.KeyboardNavigation.DirectionalNavigationProperty;
                        navigationDirection.v = System.Windows.Input.FocusNavigationDirection.Right;
                        return true;
                    }

                    if (e.Key === System.Windows.Input.Key.Up) {
                        navigationModeProperty.v = System.Windows.Input.KeyboardNavigation.DirectionalNavigationProperty;
                        navigationDirection.v = System.Windows.Input.FocusNavigationDirection.Up;
                        return true;
                    }

                    if (e.Key === System.Windows.Input.Key.Down) {
                        navigationModeProperty.v = System.Windows.Input.KeyboardNavigation.DirectionalNavigationProperty;
                        navigationDirection.v = System.Windows.Input.FocusNavigationDirection.Down;
                        return true;
                    }

                    return false;
                },
                IsNavigationScope: function (keyboardNavigationMode) {
                    return keyboardNavigationMode === System.Windows.Input.KeyboardNavigationMode.Once;
                },
                GetNavigationScope: function (element) {
                    while (element != null && !System.Windows.Input.KeyboardNavigation.IsNavigationScope(System.Windows.Input.KeyboardNavigation.GetTabNavigation(element)) && !System.Windows.Input.KeyboardNavigation.IsNavigationScope(System.Windows.Input.KeyboardNavigation.GetControlTabNavigation(element))) {
                        element = element.VisualParent;
                    }

                    return element;
                }
            }
        },
        fields: {
            presentationSource: null,
            focusVisualAdorner: null
        },
        alias: ["dispose", "System$IDisposable$dispose"],
        ctors: {
            ctor: function (presentationSource) {
                this.$initialize();
                this.presentationSource = presentationSource;

                presentationSource.System$Windows$IPresentationSource$KeyboardDevice.addTargetChanged(Bridge.fn.cacheBind(this, this.OnTargetChanged));
                presentationSource.System$Windows$IPresentationSource$KeyboardDevice.addPostProcessKey(Bridge.fn.cacheBind(this, this.OnPostProcessKey));
            }
        },
        methods: {
            dispose: function () {
                this.presentationSource.System$Windows$IPresentationSource$KeyboardDevice.removeTargetChanged(Bridge.fn.cacheBind(this, this.OnTargetChanged));
                this.presentationSource.System$Windows$IPresentationSource$KeyboardDevice.removePostProcessKey(Bridge.fn.cacheBind(this, this.OnPostProcessKey));
            },
            OnTargetChanged: function (sender, e) {
                if (this.focusVisualAdorner != null) {
                    this.focusVisualAdorner.dispose();
                    this.focusVisualAdorner = null;
                }

                var focusedElement = Bridge.cast(this.presentationSource.System$Windows$IPresentationSource$KeyboardDevice.Target, System.Windows.FrameworkElement);

                if (focusedElement != null) {
                    this.focusVisualAdorner = System.Windows.Input.KeyboardNavigation.FocusVisualAdorner.Attach(focusedElement);
                    System.Windows.Input.KeyboardNavigation.SetNavigationFocusElement$1(focusedElement);
                }
            },
            OnPostProcessKey: function (sender, e) {
                if (e.Handled) {
                    return;
                }

                var navigationDirection = { v : new System.Windows.Input.FocusNavigationDirection() };
                var navigationModeProperty = { };

                if (System.Windows.Input.KeyboardNavigation.TryGetNavigationMode(e, navigationModeProperty, navigationDirection)) {
                    var currentTarget = Bridge.cast(this.presentationSource.System$Windows$IPresentationSource$KeyboardDevice.Target, System.Windows.UIElement) || this.presentationSource.System$Windows$IPresentationSource$RootElement;

                    var newTarget = Bridge.cast(System.Windows.Input.KeyboardNavigationTarget.FindTarget(currentTarget, navigationDirection.v, navigationModeProperty.v), System.Windows.UIElement);

                    if (!Bridge.referenceEquals(currentTarget, newTarget) && newTarget != null) {
                        newTarget.Focus();
                    }

                    e.Handled = true;
                }
            }
        }
    });

    Bridge.define("System.Windows.Input.KeyboardNavigation.FocusVisualAdorner", {
        inherits: [System.IDisposable],
        statics: {
            methods: {
                Attach: function (element) {
                    return new System.Windows.Input.KeyboardNavigation.FocusVisualAdorner(element);
                }
            }
        },
        fields: {
            adornerLayer: null,
            adorner: null
        },
        alias: ["dispose", "System$IDisposable$dispose"],
        ctors: {
            ctor: function (element) {
                var $t, $t1;
                this.$initialize();
                this.adornerLayer = System.Windows.Documents.AdornerLayer.GetAdornerLayer(element);
                this.adorner = ($t = new System.Windows.Documents.Adorner(element), $t.Child = ($t1 = new System.Windows.Controls.Control(), $t1.Style = element.FocusVisualStyle, $t1.Focusable = false, $t1), $t);

                this.adornerLayer.Add(this.adorner);
            }
        },
        methods: {
            dispose: function () {
                this.adornerLayer.Remove(this.adorner);
            }
        }
    });

    Bridge.define("System.Windows.Input.KeyboardNavigationMode", {
        $kind: "enum",
        statics: {
            fields: {
                Continue: 0,
                Once: 1,
                Cycle: 2,
                None: 3,
                Contained: 4,
                Local: 5
            }
        }
    });

    Bridge.define("System.Windows.Input.KeyboardNavigationTarget", {
        statics: {
            fields: {
                TabStopComparerProvider: null,
                LeftBoundStopComparerProvider: null,
                RightBoundStopComparerProvider: null,
                TopBoundStopComparerProvider: null,
                BottomBoundStopComparerProvider: null
            },
            ctors: {
                init: function () {
                    this.TabStopComparerProvider = new System.Windows.Input.KeyboardNavigationTarget.StopComparerProvider($asm.$.System.Windows.Input.KeyboardNavigationTarget.f1);
                    this.LeftBoundStopComparerProvider = new System.Windows.Input.KeyboardNavigationTarget.StopComparerProvider($asm.$.System.Windows.Input.KeyboardNavigationTarget.f2);
                    this.RightBoundStopComparerProvider = new System.Windows.Input.KeyboardNavigationTarget.StopComparerProvider($asm.$.System.Windows.Input.KeyboardNavigationTarget.f3);
                    this.TopBoundStopComparerProvider = new System.Windows.Input.KeyboardNavigationTarget.StopComparerProvider($asm.$.System.Windows.Input.KeyboardNavigationTarget.f4);
                    this.BottomBoundStopComparerProvider = new System.Windows.Input.KeyboardNavigationTarget.StopComparerProvider($asm.$.System.Windows.Input.KeyboardNavigationTarget.f5);
                }
            },
            methods: {
                FindTarget: function (currentElement, direction, navigationModeProperty) {
                    var currentStop = new System.Windows.Input.KeyboardNavigationTarget.Stop.ctor(currentElement);

                    switch (direction) {
                        case System.Windows.Input.FocusNavigationDirection.Next: 
                            return System.Windows.Input.KeyboardNavigationTarget.FindNextTarget(currentStop.Element, currentStop, navigationModeProperty, System.Windows.Input.KeyboardNavigationTarget.TabStopComparerProvider);
                        case System.Windows.Input.FocusNavigationDirection.Previous: 
                            return System.Windows.Input.KeyboardNavigationTarget.FindPreviousTarget(currentStop.Element, currentStop, navigationModeProperty, System.Windows.Input.KeyboardNavigationTarget.TabStopComparerProvider);
                        case System.Windows.Input.FocusNavigationDirection.First: 
                            return System.Windows.Input.KeyboardNavigationTarget.FindFirstTarget(currentStop.Element, currentStop, navigationModeProperty, System.Windows.Input.KeyboardNavigationTarget.TabStopComparerProvider);
                        case System.Windows.Input.FocusNavigationDirection.Last: 
                            return System.Windows.Input.KeyboardNavigationTarget.FindLastTarget(currentStop.Element, currentStop, navigationModeProperty, System.Windows.Input.KeyboardNavigationTarget.TabStopComparerProvider);
                        case System.Windows.Input.FocusNavigationDirection.Left: 
                            return System.Windows.Input.KeyboardNavigationTarget.FindPreviousTarget(currentStop.Element, currentStop, navigationModeProperty, System.Windows.Input.KeyboardNavigationTarget.LeftBoundStopComparerProvider);
                        case System.Windows.Input.FocusNavigationDirection.Right: 
                            return System.Windows.Input.KeyboardNavigationTarget.FindNextTarget(currentStop.Element, currentStop, navigationModeProperty, System.Windows.Input.KeyboardNavigationTarget.RightBoundStopComparerProvider);
                        case System.Windows.Input.FocusNavigationDirection.Up: 
                            return System.Windows.Input.KeyboardNavigationTarget.FindPreviousTarget(currentStop.Element, currentStop, navigationModeProperty, System.Windows.Input.KeyboardNavigationTarget.TopBoundStopComparerProvider);
                        case System.Windows.Input.FocusNavigationDirection.Down: 
                            return System.Windows.Input.KeyboardNavigationTarget.FindNextTarget(currentStop.Element, currentStop, navigationModeProperty, System.Windows.Input.KeyboardNavigationTarget.BottomBoundStopComparerProvider);
                    }

                    throw new Granular.Exception("Unexpected navigation direction \"{0}\"", [Bridge.box(direction, System.Windows.Input.FocusNavigationDirection, System.Enum.toStringFn(System.Windows.Input.FocusNavigationDirection))]);
                },
                GetNavigation: function (scope, navigationModeProperty) {
                    var scopeNavigationMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(scope.GetValue(navigationModeProperty)), System.Int32));

                    switch (scopeNavigationMode) {
                        case System.Windows.Input.KeyboardNavigationMode.Continue: 
                            return System.Windows.Input.KeyboardNavigationTarget.ContinueNavigation.Default;
                        case System.Windows.Input.KeyboardNavigationMode.Once: 
                            return System.Windows.Input.KeyboardNavigationTarget.OnceNavigation.Default;
                        case System.Windows.Input.KeyboardNavigationMode.Cycle: 
                            return System.Windows.Input.KeyboardNavigationTarget.CycleNavigation.Default;
                        case System.Windows.Input.KeyboardNavigationMode.None: 
                            return System.Windows.Input.KeyboardNavigationTarget.NoneNavigation.Default;
                        case System.Windows.Input.KeyboardNavigationMode.Contained: 
                            return System.Windows.Input.KeyboardNavigationTarget.ContainedNavigation.Default;
                        case System.Windows.Input.KeyboardNavigationMode.Local: 
                            return System.Windows.Input.KeyboardNavigationTarget.LocalNavigation.Default;
                    }

                    throw new Granular.Exception("Unexpected KeyboardNavigationMode \"{0}\"", [Bridge.box(scopeNavigationMode, System.Windows.Input.KeyboardNavigationMode, System.Enum.toStringFn(System.Windows.Input.KeyboardNavigationMode))]);
                },
                FindNextTarget: function (scope, currentStop, navigationModeProperty, stopComparerProvider) {
                    return System.Windows.Input.KeyboardNavigationTarget.GetNavigation(scope, navigationModeProperty).System$Windows$Input$KeyboardNavigationTarget$INavigation$FindNextTarget(scope, currentStop, navigationModeProperty, stopComparerProvider);
                },
                FindPreviousTarget: function (scope, currentStop, navigationModeProperty, stopComparerProvider) {
                    return System.Windows.Input.KeyboardNavigationTarget.GetNavigation(scope, navigationModeProperty).System$Windows$Input$KeyboardNavigationTarget$INavigation$FindPreviousTarget(scope, currentStop, navigationModeProperty, stopComparerProvider);
                },
                FindFirstTarget: function (scope, currentStop, navigationModeProperty, stopComparerProvider) {
                    return System.Windows.Input.KeyboardNavigationTarget.GetNavigation(scope, navigationModeProperty).System$Windows$Input$KeyboardNavigationTarget$INavigation$FindFirstTarget(scope, currentStop, navigationModeProperty, stopComparerProvider);
                },
                FindLastTarget: function (scope, currentStop, navigationModeProperty, stopComparerProvider) {
                    return System.Windows.Input.KeyboardNavigationTarget.GetNavigation(scope, navigationModeProperty).System$Windows$Input$KeyboardNavigationTarget$INavigation$FindLastTarget(scope, currentStop, navigationModeProperty, stopComparerProvider);
                },
                FindNextContainedTarget: function (scope, currentStop, navigationModeProperty, stopComparerProvider) {
                    var $t;
                    var stopComparer = stopComparerProvider.System$Windows$Input$KeyboardNavigationTarget$IStopComparerProvider$CreateComparer(currentStop);

                    var passedCurrentStop = false;

                    var targetStop = null;

                    $t = Bridge.getEnumerator(System.Windows.Input.KeyboardNavigationTarget.GetContainedStops(scope, currentStop.Element, navigationModeProperty), System.Windows.Input.KeyboardNavigationTarget.Stop);
                    try {
                        while ($t.moveNext()) {
                            var stop = $t.Current;
                            if (Bridge.referenceEquals(stop.Element, currentStop.Element)) {
                                passedCurrentStop = true;
                                continue;
                            }

                            var compareResult = stopComparer[Bridge.geti(stopComparer, "System$Collections$Generic$IComparer$1$System$Windows$Input$KeyboardNavigationTarget$Stop$compare", "System$Collections$Generic$IComparer$1$compare")](currentStop, stop);
                            if ((compareResult < 0 || compareResult === 0 && passedCurrentStop) && (targetStop == null || stopComparer[Bridge.geti(stopComparer, "System$Collections$Generic$IComparer$1$System$Windows$Input$KeyboardNavigationTarget$Stop$compare", "System$Collections$Generic$IComparer$1$compare")](targetStop, stop) > 0)) {
                                targetStop = stop;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$dispose();
                        }
                    }
                    return targetStop != null ? targetStop.Element : null;
                },
                FindPreviousContainedTarget: function (scope, currentStop, navigationModeProperty, stopComparerProvider) {
                    var $t;
                    var stopComparer = stopComparerProvider.System$Windows$Input$KeyboardNavigationTarget$IStopComparerProvider$CreateComparer(currentStop);

                    var passedCurrentStop = false;

                    var targetStop = null;

                    $t = Bridge.getEnumerator(System.Windows.Input.KeyboardNavigationTarget.GetContainedStops(scope, currentStop.Element, navigationModeProperty), System.Windows.Input.KeyboardNavigationTarget.Stop);
                    try {
                        while ($t.moveNext()) {
                            var stop = $t.Current;
                            if (Bridge.referenceEquals(stop.Element, currentStop.Element)) {
                                passedCurrentStop = true;
                                continue;
                            }

                            var compareResult = stopComparer[Bridge.geti(stopComparer, "System$Collections$Generic$IComparer$1$System$Windows$Input$KeyboardNavigationTarget$Stop$compare", "System$Collections$Generic$IComparer$1$compare")](currentStop, stop);
                            if ((compareResult > 0 || compareResult === 0 && !passedCurrentStop) && (targetStop == null || stopComparer[Bridge.geti(stopComparer, "System$Collections$Generic$IComparer$1$System$Windows$Input$KeyboardNavigationTarget$Stop$compare", "System$Collections$Generic$IComparer$1$compare")](targetStop, stop) <= 0)) {
                                targetStop = stop;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$dispose();
                        }
                    }
                    return targetStop != null ? targetStop.Element : null;
                },
                FindFirstContainedTarget: function (scope, currentStop, navigationModeProperty, stopComparerProvider) {
                    var $t;
                    var stopComparer = stopComparerProvider.System$Windows$Input$KeyboardNavigationTarget$IStopComparerProvider$CreateComparer(currentStop);

                    var targetStop = null;

                    $t = Bridge.getEnumerator(System.Windows.Input.KeyboardNavigationTarget.GetContainedStops(scope, currentStop.Element, navigationModeProperty), System.Windows.Input.KeyboardNavigationTarget.Stop);
                    try {
                        while ($t.moveNext()) {
                            var stop = $t.Current;
                            if (targetStop == null || stopComparer[Bridge.geti(stopComparer, "System$Collections$Generic$IComparer$1$System$Windows$Input$KeyboardNavigationTarget$Stop$compare", "System$Collections$Generic$IComparer$1$compare")](targetStop, stop) > 0) {
                                targetStop = stop;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$dispose();
                        }
                    }
                    return targetStop != null ? targetStop.Element : null;
                },
                FindLastContainedTarget: function (scope, currentStop, navigationModeProperty, stopComparerProvider) {
                    var $t;
                    var stopComparer = stopComparerProvider.System$Windows$Input$KeyboardNavigationTarget$IStopComparerProvider$CreateComparer(currentStop);

                    var targetStop = null;

                    $t = Bridge.getEnumerator(System.Windows.Input.KeyboardNavigationTarget.GetContainedStops(scope, currentStop.Element, navigationModeProperty), System.Windows.Input.KeyboardNavigationTarget.Stop);
                    try {
                        while ($t.moveNext()) {
                            var stop = $t.Current;
                            if (targetStop == null || stopComparer[Bridge.geti(stopComparer, "System$Collections$Generic$IComparer$1$System$Windows$Input$KeyboardNavigationTarget$Stop$compare", "System$Collections$Generic$IComparer$1$compare")](targetStop, stop) <= 0) {
                                targetStop = stop;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$dispose();
                        }
                    }
                    return targetStop != null ? targetStop.Element : null;
                },
                IsStop: function (element) {
                    return System.Windows.Input.KeyboardNavigation.GetIsTabStop(element) && element.IsVisible && element.IsEnabled && element.Focusable;
                },
                GetGlobalStops: function (scope, currentElement, navigationModeProperty) {
                    return System.Windows.Input.KeyboardNavigationTarget.GetNavigation(scope, navigationModeProperty).System$Windows$Input$KeyboardNavigationTarget$INavigation$GetGlobalStops(scope, currentElement, navigationModeProperty);
                },
                GetContainedStops: function (scope, currentElement, navigationModeProperty) {
                    return new (Bridge.GeneratorEnumerable$1(System.Windows.Input.KeyboardNavigationTarget.Stop))(Bridge.fn.bind(this, function (scope, currentElement, navigationModeProperty) {
                        var $step = 0,
                            $jumpFromFinally,
                            $returnValue,
                            $t,
                            stop,
                            $async_e;

                        var $enumerator = new (Bridge.GeneratorEnumerator$1(System.Windows.Input.KeyboardNavigationTarget.Stop))(Bridge.fn.bind(this, function () {
                            try {
                                for (;;) {
                                    switch ($step) {
                                        case 0: {
                                            if (System.Windows.Input.KeyboardNavigationTarget.IsStop(Bridge.cast(scope, System.Windows.UIElement)) || Bridge.referenceEquals(scope, currentElement)) {
                                                    $step = 1;
                                                    continue;
                                                } 
                                                $step = 3;
                                                continue;
                                        }
                                        case 1: {
                                            $enumerator.current = new System.Windows.Input.KeyboardNavigationTarget.Stop.ctor(scope);
                                                $step = 2;
                                                return true;
                                        }
                                        case 2: {
                                            $step = 3;
                                            continue;
                                        }
                                        case 3: {
                                            $t = Bridge.getEnumerator(System.Linq.Enumerable.from(scope.VisualChildren).selectMany(function (child) {
                                                        return System.Windows.Input.KeyboardNavigationTarget.GetGlobalStops(child, currentElement, navigationModeProperty);
                                                    }));
                                                $step = 4;
                                                continue;
                                        }
                                        case 4: {
                                            if ($t.moveNext()) {
                                                    stop = $t.Current;
                                                    $step = 5;
                                                    continue;
                                                }
                                            $step = 7;
                                            continue;
                                        }
                                        case 5: {
                                            $enumerator.current = stop;
                                                $step = 6;
                                                return true;
                                        }
                                        case 6: {
                                            $step = 4;
                                            continue;
                                        }
                                        case 7: {

                                        }
                                        default: {
                                            return false;
                                        }
                                    }
                                }
                            } catch($async_e1) {
                                $async_e = System.Exception.create($async_e1);
                                throw $async_e;
                            }
                        }));
                        return $enumerator;
                    }, arguments));
                },
                GetAbsoluteBounds: function (element) {
                    return System.Windows.Media.MatrixExtensions.GetApproximatedRect$1(element.TransformToAncestor(null), element.VisualBounds.Size);
                },
                GetLeftBoundPosition: function (bounds) {
                    return System.Windows.Point.op_Addition(bounds.Location, new System.Windows.Point.$ctor1(0, bounds.Height / 2));
                },
                GetRightBoundPosition: function (bounds) {
                    return System.Windows.Point.op_Addition(bounds.Location, new System.Windows.Point.$ctor1(bounds.Width, bounds.Height / 2));
                },
                GetTopBoundPosition: function (bounds) {
                    return System.Windows.Point.op_Addition(bounds.Location, new System.Windows.Point.$ctor1(bounds.Width / 2, 0));
                },
                GetBottomBoundPosition: function (bounds) {
                    return System.Windows.Point.op_Addition(bounds.Location, new System.Windows.Point.$ctor1(bounds.Width / 2, bounds.Height));
                }
            }
        }
    });

    Bridge.ns("System.Windows.Input.KeyboardNavigationTarget", $asm.$);

    Bridge.apply($asm.$.System.Windows.Input.KeyboardNavigationTarget, {
        f1: function (currentStop) {
            return System.Windows.Input.KeyboardNavigationTarget.TabStopComparer.Default;
        },
        f2: function (currentStop) {
            return new System.Windows.Input.KeyboardNavigationTarget.LeftBoundStopComparer(currentStop);
        },
        f3: function (currentStop) {
            return new System.Windows.Input.KeyboardNavigationTarget.RightBoundStopComparer(currentStop);
        },
        f4: function (currentStop) {
            return new System.Windows.Input.KeyboardNavigationTarget.TopBoundStopComparer(currentStop);
        },
        f5: function (currentStop) {
            return new System.Windows.Input.KeyboardNavigationTarget.BottomBoundStopComparer(currentStop);
        }
    });

    Bridge.define("System.Windows.Input.KeyboardNavigationTarget.INavigation", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Input.KeyboardNavigationTarget.Stop", {
        props: {
            Element: null,
            TabIndex: 0
        },
        ctors: {
            ctor: function (element) {
                System.Windows.Input.KeyboardNavigationTarget.Stop.$ctor1.call(this, element, System.Windows.Input.KeyboardNavigation.GetTabIndex(element));
                //
            },
            $ctor1: function (element, tabIndex) {
                this.$initialize();
                this.Element = element;
                this.TabIndex = tabIndex;
            }
        },
        methods: {
            toString: function () {
                return System.String.format("Stop({0}, {1})", this.Element, Bridge.box(this.TabIndex, System.Int32));
            }
        }
    });

    Bridge.define("System.Windows.Input.KeyboardNavigationTarget.IStopComparerProvider", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Input.KeyEventHandlerExtensions", {
        statics: {
            methods: {
                Raise: function (handler, sender, e) {
                    if (!Bridge.staticEquals(handler, null)) {
                        handler(sender, e);
                    }
                }
            }
        }
    });

    Bridge.define("System.Windows.Input.KeyStates", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                Down: 1
            }
        }
    });

    Bridge.define("System.Windows.Input.ModifierKeys", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                Alt: 1,
                Control: 2,
                Shift: 4,
                Windows: 8
            }
        }
    });

    Bridge.define("System.Windows.Input.Mouse", {
        statics: {
            fields: {
                PreviewMouseMoveEvent: null,
                PreviewMouseDownEvent: null,
                PreviewMouseUpEvent: null,
                PreviewMouseWheelEvent: null,
                MouseMoveEvent: null,
                MouseDownEvent: null,
                MouseUpEvent: null,
                MouseWheelEvent: null,
                MouseEnterEvent: null,
                MouseLeaveEvent: null,
                QueryCursorEvent: null
            },
            ctors: {
                init: function () {
                    this.PreviewMouseMoveEvent = System.Windows.EventManager.RegisterRoutedEvent("PreviewMouseMove", System.Windows.RoutingStrategy.Tunnel, Function, System.Windows.Input.Mouse);
                    this.PreviewMouseDownEvent = System.Windows.EventManager.RegisterRoutedEvent("PreviewMouseDown", System.Windows.RoutingStrategy.Tunnel, Function, System.Windows.Input.Mouse);
                    this.PreviewMouseUpEvent = System.Windows.EventManager.RegisterRoutedEvent("PreviewMouseUp", System.Windows.RoutingStrategy.Tunnel, Function, System.Windows.Input.Mouse);
                    this.PreviewMouseWheelEvent = System.Windows.EventManager.RegisterRoutedEvent("PreviewMouseWheel", System.Windows.RoutingStrategy.Tunnel, Function, System.Windows.Input.Mouse);
                    this.MouseMoveEvent = System.Windows.EventManager.RegisterRoutedEvent("MouseMove", System.Windows.RoutingStrategy.Bubble, Function, System.Windows.Input.Mouse);
                    this.MouseDownEvent = System.Windows.EventManager.RegisterRoutedEvent("MouseDown", System.Windows.RoutingStrategy.Bubble, Function, System.Windows.Input.Mouse);
                    this.MouseUpEvent = System.Windows.EventManager.RegisterRoutedEvent("MouseUp", System.Windows.RoutingStrategy.Bubble, Function, System.Windows.Input.Mouse);
                    this.MouseWheelEvent = System.Windows.EventManager.RegisterRoutedEvent("MouseWheel", System.Windows.RoutingStrategy.Bubble, Function, System.Windows.Input.Mouse);
                    this.MouseEnterEvent = System.Windows.EventManager.RegisterRoutedEvent("MouseEnter", System.Windows.RoutingStrategy.Direct, Function, System.Windows.Input.Mouse);
                    this.MouseLeaveEvent = System.Windows.EventManager.RegisterRoutedEvent("MouseLeave", System.Windows.RoutingStrategy.Direct, Function, System.Windows.Input.Mouse);
                    this.QueryCursorEvent = System.Windows.EventManager.RegisterRoutedEvent("QueryCursor", System.Windows.RoutingStrategy.Bubble, Function, System.Windows.Input.Mouse);
                }
            }
        }
    });

    Bridge.define("System.Windows.Input.MouseButton", {
        $kind: "enum",
        statics: {
            fields: {
                Left: 0,
                Middle: 1,
                Right: 2,
                XButton1: 3,
                XButton2: 4
            }
        }
    });

    Bridge.define("System.Windows.Input.MouseButtonState", {
        $kind: "enum",
        statics: {
            fields: {
                Released: 0,
                Pressed: 1
            }
        }
    });

    Bridge.define("System.Windows.Input.RawEventArgs", {
        props: {
            Timestamp: 0
        },
        ctors: {
            ctor: function (timestamp) {
                this.$initialize();
                this.Timestamp = timestamp;
            }
        }
    });

    Bridge.define("System.Windows.IPresentationSource", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.IPresentationSourceFactory", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.ITextMeasurementService", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.LayoutManager", {
        statics: {
            fields: {
                Current: null
            },
            ctors: {
                init: function () {
                    this.Current = new System.Windows.LayoutManager();
                }
            },
            methods: {
                GetElementPath: function (element) {
                    return new (Bridge.GeneratorEnumerable$1(System.Windows.UIElement))(Bridge.fn.bind(this, function (element) {
                        var $step = 0,
                            $jumpFromFinally,
                            $returnValue,
                            $async_e;

                        var $enumerator = new (Bridge.GeneratorEnumerator$1(System.Windows.UIElement))(Bridge.fn.bind(this, function () {
                            try {
                                for (;;) {
                                    switch ($step) {
                                        case 0: {
                                            if ( element != null ) {
                                                    $step = 1;
                                                    continue;
                                                } 
                                                $step = 3;
                                                continue;
                                        }
                                        case 1: {
                                            $enumerator.current = element;
                                                $step = 2;
                                                return true;
                                        }
                                        case 2: {
                                            element = Bridge.cast(element.VisualParent, System.Windows.UIElement);

                                                $step = 0;
                                                continue;
                                        }
                                        case 3: {

                                        }
                                        default: {
                                            return false;
                                        }
                                    }
                                }
                            } catch($async_e1) {
                                $async_e = System.Exception.create($async_e1);
                                throw $async_e;
                            }
                        }));
                        return $enumerator;
                    }, arguments));
                }
            }
        },
        fields: {
            measureQueue: null,
            arrangeQueue: null,
            updatedElements: null,
            updateLayoutOperation: null
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                this.measureQueue = new (System.Collections.Generic.HashSet$1(System.Windows.UIElement)).ctor();
                this.arrangeQueue = new (System.Collections.Generic.HashSet$1(System.Windows.UIElement)).ctor();
                this.updatedElements = new (System.Collections.Generic.HashSet$1(System.Windows.UIElement)).ctor();
            }
        },
        methods: {
            AddMeasure: function (element) {
                this.measureQueue.add(element);
                this.BeginUpdateLayout();
            },
            RemoveMeasure: function (element) {
                this.measureQueue.remove(element);
            },
            AddArrange: function (element) {
                this.arrangeQueue.add(element);
                this.BeginUpdateLayout();
            },
            RemoveArrange: function (element) {
                this.arrangeQueue.remove(element);
            },
            AddUpdatedElement: function (element) {
                var $t;
                if (this.updateLayoutOperation == null || this.updateLayoutOperation.Status !== System.Windows.Threading.DispatcherOperationStatus.Executing) {
                    // element was updated manually (not through the UpdateLayout loop)
                    $t = Bridge.getEnumerator(System.Windows.LayoutManager.GetElementPath(element), System.Windows.UIElement);
                    try {
                        while ($t.moveNext()) {
                            var pathElement = $t.Current;
                            pathElement.RaiseLayoutUpdated();
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$dispose();
                        }
                    }
                    return;
                }
                Granular.Extensions.CollectionExtensions.AddRange$1(Bridge.global.System.Windows.UIElement, this.updatedElements, System.Windows.LayoutManager.GetElementPath(element));
            },
            BeginUpdateLayout: function () {
                if (this.updateLayoutOperation == null || this.updateLayoutOperation.Status === System.Windows.Threading.DispatcherOperationStatus.Completed) {
                    this.updateLayoutOperation = System.Windows.Threading.Dispatcher.CurrentDispatcher.InvokeAsync(Bridge.fn.cacheBind(this, this.UpdateLayout), System.Windows.Threading.DispatcherPriority.Render);
                }
            },
            UpdateLayout: function () {
                while (this.measureQueue.Count > 0 || this.arrangeQueue.Count > 0) {
                    while (this.measureQueue.Count > 0) {
                        var element = this.GetTopElement(this.measureQueue);
                        var previousDesiredSize = element.DesiredSize;

                        element.Measure(element.PreviousAvailableSize);

                        if (System.Windows.Size.op_Inequality(previousDesiredSize, element.DesiredSize)) {
                            element.InvalidateArrange();
                            element.InvalidateParentMeasure();
                        }
                    }

                    while (this.arrangeQueue.Count > 0) {
                        var element1 = this.GetTopElement(this.arrangeQueue);
                        element1.Arrange(element1.PreviousFinalRect);
                    }

                    while (this.updatedElements.Count > 0 && this.measureQueue.Count === 0 && this.arrangeQueue.Count === 0) {
                        var element2 = System.Linq.Enumerable.from(this.updatedElements).first();
                        this.updatedElements.remove(element2);

                        element2.RaiseLayoutUpdated();
                    }
                }
            },
            GetTopElement: function (measureQueue) {
                var $t;
                var topElement = null;

                $t = Bridge.getEnumerator(measureQueue, System.Windows.UIElement);
                try {
                    while ($t.moveNext()) {
                        var element = $t.Current;
                        if (topElement == null || topElement.VisualLevel > element.VisualLevel) {
                            topElement = element;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                return topElement;
            }
        }
    });

    Bridge.define("System.Windows.Markup.IEventAdapter", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Markup.IPropertyAdapter", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Markup.IElementFactory", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Markup.PropertyAttribute", {
        inherits: [System.Attribute],
        statics: {
            methods: {
                ResolvePropertyName: function (T, type) {
                    return Granular.Compatibility.Linq.Enumerable.FirstOrDefault(System.String, Granular.Compatibility.Linq.Enumerable.Select(T, System.String, Granular.Compatibility.Linq.Enumerable.OfType(T, Bridge.Reflection.getAttributes(type, null, true)), $asm.$.System.Windows.Markup.PropertyAttribute.f1));
                }
            }
        },
        props: {
            Name: null
        },
        ctors: {
            ctor: function (name) {
                this.$initialize();
                System.Attribute.ctor.call(this);
                this.Name = name;
            }
        }
    });

    Bridge.ns("System.Windows.Markup.PropertyAttribute", $asm.$);

    Bridge.apply($asm.$.System.Windows.Markup.PropertyAttribute, {
        f1: function (attribute) {
            return attribute.Name;
        }
    });

    Bridge.define("System.Windows.Markup.DeferredValueKeyProviderAttribute", {
        inherits: [System.Attribute],
        props: {
            ProviderType: null
        },
        ctors: {
            ctor: function (providerType) {
                this.$initialize();
                System.Attribute.ctor.call(this);
                this.ProviderType = providerType;
            }
        }
    });

    Bridge.define("System.Windows.Markup.DeferredValueKeyProviders", {
        statics: {
            fields: {
                DeferredValueKeyProviderCache: null
            },
            ctors: {
                init: function () {
                    this.DeferredValueKeyProviderCache = Granular.Collections.CacheDictionary$2(Function,System.Windows.Markup.IDeferredValueKeyProvider).CreateUsingStringKeys(System.Windows.Markup.DeferredValueKeyProviders.ResolveDeferredValueKeyProvider, $asm.$.System.Windows.Markup.DeferredValueKeyProviders.f1);
                }
            },
            methods: {
                GetDeferredValueKeyProvider: function (type) {
                    return System.Windows.Markup.DeferredValueKeyProviders.DeferredValueKeyProviderCache.GetValue(type);
                },
                ResolveDeferredValueKeyProvider: function (type) {
                    var deferredValueKeyProviderAttribute = Bridge.as(System.Linq.Enumerable.from(Bridge.Reflection.getAttributes(type, System.Windows.Markup.DeferredValueKeyProviderAttribute, false)).firstOrDefault(null, null), System.Windows.Markup.DeferredValueKeyProviderAttribute);
                    if (deferredValueKeyProviderAttribute != null) {
                        return Bridge.as(Bridge.createInstance(deferredValueKeyProviderAttribute.ProviderType), System.Windows.Markup.IDeferredValueKeyProvider);
                    }

                    return null;
                }
            }
        }
    });

    Bridge.ns("System.Windows.Markup.DeferredValueKeyProviders", $asm.$);

    Bridge.apply($asm.$.System.Windows.Markup.DeferredValueKeyProviders, {
        f1: function (type) {
            return Bridge.Reflection.getTypeFullName(type);
        }
    });

    Bridge.define("System.Windows.Markup.ElementCollectionContentInitailizer", {
        statics: {
            fields: {
                IsCollectionTypeCache: null
            },
            ctors: {
                init: function () {
                    this.IsCollectionTypeCache = Granular.Collections.CacheDictionary$2(Function,System.Boolean).CreateUsingStringKeys(System.Windows.Markup.ElementCollectionContentInitailizer.ResolveIsCollectionType, $asm.$.System.Windows.Markup.ElementCollectionContentInitailizer.f1);
                }
            },
            methods: {
                Create: function (values, containingType) {
                    var keyType = { };
                    var valueType = { };

                    if (System.Windows.Markup.ElementCollectionContentInitailizer.TryGetDictionaryGenericArguments(containingType, keyType, valueType)) {
                        return new System.Windows.Markup.ElementDictionaryContentInitializer(containingType, keyType.v, valueType.v, values);
                    }

                    if (System.Windows.Markup.ElementCollectionContentInitailizer.TryGetCollectionGenericArgument(containingType, valueType)) {
                        return new System.Windows.Markup.ElementCollectionContentInitializer(valueType.v, values);
                    }

                    throw new Granular.Exception("Can't initialize type \"{0}\" content", [Bridge.Reflection.getTypeName(containingType)]);
                },
                IsCollectionType: function (type) {
                    return System.Windows.Markup.ElementCollectionContentInitailizer.IsCollectionTypeCache.GetValue(type);
                },
                ResolveIsCollectionType: function (type) {
                    var keyType = { };
                    var valueType = { };

                    return System.Windows.Markup.ElementCollectionContentInitailizer.TryGetDictionaryGenericArguments(type, keyType, valueType) || System.Windows.Markup.ElementCollectionContentInitailizer.TryGetCollectionGenericArgument(type, valueType);
                },
                TryGetDictionaryGenericArguments: function (type, keyType, valueType) {
                    var interfaceType = Granular.Extensions.TypeExtensions.GetInterfaceType(type, System.Collections.Generic.IDictionary$2);

                    if (interfaceType != null) {
                        var $arguments = Granular.Compatibility.Linq.Enumerable.ToArray(Bridge.global.Function, Bridge.Reflection.getGenericArguments(interfaceType));
                        keyType.v = $arguments[System.Array.index(0, $arguments)];
                        valueType.v = $arguments[System.Array.index(1, $arguments)];
                        return true;
                    }

                    valueType.v = null;
                    keyType.v = null;
                    return false;
                },
                TryGetCollectionGenericArgument: function (type, valueType) {
                    var interfaceType = Granular.Extensions.TypeExtensions.GetInterfaceType(type, System.Collections.Generic.ICollection$1);

                    if (interfaceType != null) {
                        valueType.v = Granular.Compatibility.Linq.Enumerable.First(Bridge.global.Function, Bridge.Reflection.getGenericArguments(interfaceType));
                        return true;
                    }

                    valueType.v = null;
                    return false;
                }
            }
        }
    });

    Bridge.ns("System.Windows.Markup.ElementCollectionContentInitailizer", $asm.$);

    Bridge.apply($asm.$.System.Windows.Markup.ElementCollectionContentInitailizer, {
        f1: function (type) {
            return Bridge.Reflection.getTypeFullName(type);
        }
    });

    Bridge.define("System.Windows.Markup.IElementInitializer", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Markup.ElementDictionaryContentInitializer.KeyValueElementFactory", {
        statics: {
            methods: {
                GetKeyDirectiveFactory: function (element, keyType) {
                    var keyDirective = Granular.Compatibility.Linq.Enumerable.FirstOrDefault$1(Bridge.global.System.Windows.Markup.XamlMember, element.Directives, $asm.$.System.Windows.Markup.ElementDictionaryContentInitializer.KeyValueElementFactory.f1);
                    return keyDirective != null ? System.Windows.Markup.ElementFactory.FromValue(System.Windows.Markup.XamlMemberExtensions.GetSingleValue(keyDirective), keyType, element.Namespaces, element.SourceUri) : null;
                },
                GetKeyProperty: function (type) {
                    var propertyName = System.Windows.Markup.DictionaryKeyPropertyAttribute.GetPropertyName(type);
                    return !Granular.Extensions.StringExtensions.IsNullOrWhiteSpace(propertyName) ? System.Windows.Markup.PropertyAdapter.CreateAdapter(type, propertyName) : null;
                },
                GetDeferredKeyFactory: function (xamlElement) {
                    var elementType = System.Windows.Markup.XamlElementExtensions.GetElementType(xamlElement);

                    var provider = System.Windows.Markup.DeferredValueKeyProviders.GetDeferredValueKeyProvider(elementType);
                    if (provider != null) {
                        return new System.Windows.Markup.ElementDictionaryContentInitializer.DeferredKeyFactory(provider, xamlElement);
                    }

                    var keyPropertyName = System.Windows.Markup.DictionaryKeyPropertyAttribute.GetPropertyName(elementType);
                    if (!Granular.Extensions.StringExtensions.IsNullOrWhiteSpace(keyPropertyName)) {
                        var keyMember = Granular.Compatibility.Linq.Enumerable.FirstOrDefault$1(Bridge.global.System.Windows.Markup.XamlMember, xamlElement.Members, function (member) {
                            return Bridge.referenceEquals(member.Name.LocalName, keyPropertyName);
                        });
                        if (keyMember != null) {
                            var keyProperty = System.Windows.Markup.PropertyAdapter.CreateAdapter(elementType, keyPropertyName);
                            return System.Windows.Markup.ElementFactory.FromValue(Granular.Compatibility.Linq.Enumerable.Single(System.Object, keyMember.Values), keyProperty.System$Windows$Markup$IPropertyAdapter$PropertyType, xamlElement.Namespaces, xamlElement.SourceUri);
                        }
                    }

                    return null;
                }
            }
        },
        fields: {
            valueFactory: null,
            keyDirectiveFactory: null,
            deferredKeyFactory: null,
            keyProperty: null
        },
        ctors: {
            ctor: function (keyType, valueFactory, xamlElement, isValueDeferred) {
                this.$initialize();
                this.valueFactory = valueFactory;

                this.keyDirectiveFactory = System.Windows.Markup.ElementDictionaryContentInitializer.KeyValueElementFactory.GetKeyDirectiveFactory(xamlElement, keyType);
                this.deferredKeyFactory = isValueDeferred && this.keyDirectiveFactory == null ? System.Windows.Markup.ElementDictionaryContentInitializer.KeyValueElementFactory.GetDeferredKeyFactory(xamlElement) : null;
                this.keyProperty = System.Windows.Markup.ElementDictionaryContentInitializer.KeyValueElementFactory.GetKeyProperty(valueFactory.System$Windows$Markup$IElementFactory$ElementType);

                if (this.keyDirectiveFactory == null && this.deferredKeyFactory == null && this.keyProperty == null) {
                    throw new Granular.Exception("Dictionary item \"{0}\" must have a key", [xamlElement.Name]);
                }
            }
        },
        methods: {
            CreateElement: function (context) {
                var element = this.valueFactory.System$Windows$Markup$IElementFactory$CreateElement(context);

                var key = null;

                if (this.keyDirectiveFactory != null) {
                    key = this.keyDirectiveFactory.System$Windows$Markup$IElementFactory$CreateElement(context);

                    if (this.keyProperty != null) {
                        this.keyProperty.System$Windows$Markup$IPropertyAdapter$SetValue(element, key, context.ValueSource);
                    }
                } else if (this.deferredKeyFactory != null) {
                    key = this.deferredKeyFactory.System$Windows$Markup$IElementFactory$CreateElement(context);
                } else {
                    key = this.keyProperty.System$Windows$Markup$IPropertyAdapter$GetValue(element);
                }

                return new (System.Collections.Generic.KeyValuePair$2(System.Object,System.Object))(key, element);
            }
        }
    });

    Bridge.ns("System.Windows.Markup.ElementDictionaryContentInitializer.KeyValueElementFactory", $asm.$);

    Bridge.apply($asm.$.System.Windows.Markup.ElementDictionaryContentInitializer.KeyValueElementFactory, {
        f1: function (directive) {
            return System.Windows.Markup.XamlName.op_Equality(directive.Name, System.Windows.Markup.XamlLanguage.KeyDirective);
        }
    });

    Bridge.define("System.Windows.Markup.ElementMemberInitializer", {
        statics: {
            methods: {
                Create: function (containingType, memberName, values, namespaces, sourceUri) {
                    var propertyAdapter = System.Windows.Markup.PropertyAdapter.CreateAdapter(containingType, memberName);
                    if (propertyAdapter != null) {
                        return System.Windows.Markup.ElementPropertyMemberInitializer.Create(propertyAdapter, values, namespaces, sourceUri);
                    }

                    var eventAdapter = System.Windows.Markup.EventAdapter.CreateAdapter(containingType, memberName);
                    if (eventAdapter != null) {
                        return new System.Windows.Markup.ElementEventMemberInitializer(eventAdapter, System.Windows.Markup.ElementMemberInitializer.GetEventHandlerName(memberName, values));
                    }

                    throw new Granular.Exception("Type \"{0}\" does not contain a member named \"{1}\"", [Bridge.Reflection.getTypeName(containingType), memberName]);
                },
                GetEventHandlerName: function (memberName, values) {
                    if (!Granular.Compatibility.Linq.Enumerable.Any(System.Object, values)) {
                        throw new Granular.Exception("Member \"{0}\" doesn't have values", [memberName]);
                    }

                    if (Granular.Compatibility.Linq.Enumerable.Count(System.Object, values) > 1) {
                        throw new Granular.Exception("Member \"{0}\" cannot have multiple values", [memberName]);
                    }

                    if (!(Bridge.is(Granular.Compatibility.Linq.Enumerable.First(System.Object, values), System.String))) {
                        throw new Granular.Exception("Member \"{0}\" value is not an event handler name", [memberName]);
                    }

                    return Bridge.cast(Granular.Compatibility.Linq.Enumerable.First(System.Object, values), System.String);
                }
            }
        }
    });

    Bridge.define("System.Windows.Markup.EventAdapter", {
        statics: {
            fields: {
                adaptersCache: null
            },
            ctors: {
                init: function () {
                    this.adaptersCache = Granular.Collections.CacheDictionary$2(System.Windows.Markup.TypeMemberKey,System.Windows.Markup.IEventAdapter).CreateUsingStringKeys$1(System.Windows.Markup.EventAdapter.TryCreateAdapter, $asm.$.System.Windows.Markup.EventAdapter.f1);
                }
            },
            methods: {
                CreateAdapter: function (targetType, eventName) {
                    var eventAdapter = { };
                    return System.Windows.Markup.EventAdapter.adaptersCache.TryGetValue(new System.Windows.Markup.TypeMemberKey(targetType, eventName), eventAdapter) ? eventAdapter.v : null;
                },
                TryCreateAdapter: function (key, adapter) {
                    adapter.v = null;

                    var routedEvent = System.Windows.Markup.EventAdapter.GetRoutedEvent(key.Type, key.MemberName);
                    if (routedEvent != null) {
                        adapter.v = new System.Windows.Markup.RoutedEventAdapter(routedEvent);
                        return true;
                    }

                    var clrEvent = System.Windows.Markup.EventAdapter.GetClrEvent(key.Type, key.MemberName);
                    if (clrEvent != null) {
                        adapter.v = new System.Windows.Markup.ClrEventAdapter(clrEvent);
                        return true;
                    }

                    var eventProperty = System.Windows.Markup.EventAdapter.GetEventProperty(key.Type, key.MemberName);
                    if (eventProperty != null) {
                        adapter.v = new System.Windows.Markup.EventPropertyAdapter(eventProperty);
                        return true;
                    }

                    return false;
                },
                GetRoutedEvent: function (containingType, eventName) {
                    return System.Windows.EventManager.GetEvent(containingType, eventName);
                },
                GetClrEvent: function (containingType, eventName) {
                    return Bridge.Reflection.getMembers(containingType, 2, 84 | 256, eventName);
                },
                GetEventProperty: function (containingType, eventName) {
                    var eventProperty = Granular.Extensions.TypeExtensions.GetInstanceProperty(containingType, eventName);
                    return eventProperty != null && System.Reflection.PropertyInfoExtensions.IsDelegate(eventProperty) ? eventProperty : null;
                }
            }
        }
    });

    Bridge.ns("System.Windows.Markup.EventAdapter", $asm.$);

    Bridge.apply($asm.$.System.Windows.Markup.EventAdapter, {
        f1: function (typeMemberKey) {
            return typeMemberKey.StringKey;
        }
    });

    Bridge.define("System.Windows.Markup.InitializeContext", {
        props: {
            Target: null,
            ParentContext: null,
            ValueSource: 0,
            NameScope: null,
            TemplatedParent: null,
            Root: null
        },
        ctors: {
            ctor: function () {
                System.Windows.Markup.InitializeContext.$ctor1.call(this, null, null, new System.Windows.NameScope(), null, System.Windows.BaseValueSource.Local);
                //
            },
            $ctor1: function (target, parentContext, nameScope, templatedParent, valueSource) {
                this.$initialize();
                this.Target = target;
                this.ParentContext = parentContext;

                this.NameScope = nameScope;
                this.TemplatedParent = templatedParent;
                this.ValueSource = valueSource;

                this.Root = parentContext != null && parentContext.Root != null ? parentContext.Root : this.Target;
            }
        }
    });

    Bridge.define("System.Windows.Markup.InitializeContextExtensions", {
        statics: {
            methods: {
                SetTarget: function (context, target) {
                    return new System.Windows.Markup.InitializeContext.$ctor1(target, context.ParentContext, context.NameScope, context.TemplatedParent, context.ValueSource);
                },
                SetNameScope: function (context, nameScope) {
                    return new System.Windows.Markup.InitializeContext.$ctor1(context.Target, context.ParentContext, nameScope, context.TemplatedParent, context.ValueSource);
                },
                CreateChildContext: function (context, child) {
                    return new System.Windows.Markup.InitializeContext.$ctor1(child, context, context.NameScope, context.TemplatedParent, context.ValueSource);
                }
            }
        }
    });

    Bridge.define("System.Windows.Markup.ISupportInitialize", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Markup.IValueProvider", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Markup.KnownTypes", {
        statics: {
            fields: {
                typeConverterCache: null
            },
            ctors: {
                init: function () {
                    this.typeConverterCache = Granular.Collections.CacheDictionary$2(Function,System.Windows.Markup.ITypeConverter).CreateUsingStringKeys(System.Windows.Markup.KnownTypes.ResolveTypeConverter, $asm.$.System.Windows.Markup.KnownTypes.f1);
                }
            },
            methods: {
                GetTypeConverter: function (type) {
                    return System.Windows.Markup.KnownTypes.typeConverterCache.GetValue(type);
                },
                ResolveTypeConverter: function (type) {
                    if (Bridge.referenceEquals(type, System.Object)) {
                        return System.Windows.Markup.ObjectTypeConverter.Default;
                    }

                    if (Bridge.referenceEquals(type, System.String)) {
                        return System.Windows.Markup.StringTypeConverter.Default;
                    }

                    if (Bridge.referenceEquals(type, System.Boolean)) {
                        return System.Windows.Markup.BooleanTypeConverter.Default;
                    }

                    if (Bridge.referenceEquals(type, System.Int32)) {
                        return System.Windows.Markup.Int32TypeConverter.Default;
                    }

                    if (Bridge.referenceEquals(type, System.Double)) {
                        return System.Windows.Markup.DoubleTypeConverter.Default;
                    }

                    if (Bridge.referenceEquals(type, System.TimeSpan)) {
                        return System.Windows.Markup.TimeSpanTypeConverter.Default;
                    }

                    if (Bridge.Reflection.isEnum(type)) {
                        return new System.Windows.Markup.EnumTypeConverter(type);
                    }

                    if (Bridge.referenceEquals(type, Function)) {
                        return System.Windows.Markup.TypeTypeConverter.Default;
                    }

                    if (Bridge.referenceEquals(type, System.Uri)) {
                        return System.Windows.Markup.UriTypeConverter.Default;
                    }

                    if (Bridge.Reflection.isGenericType(type) && Bridge.referenceEquals(Bridge.Reflection.getGenericTypeDefinition(type), System.Nullable$1)) {
                        return System.Windows.Markup.KnownTypes.GetTypeConverter(Granular.Compatibility.Linq.Enumerable.First(Bridge.global.Function, Bridge.Reflection.getGenericArguments(type)));
                    }

                    var typeConverterAttribute = Bridge.as(Granular.Compatibility.Linq.Enumerable.FirstOrDefault(System.Object, Bridge.Reflection.getAttributes(type, System.Windows.Markup.TypeConverterAttribute, false)), System.Windows.Markup.TypeConverterAttribute);
                    if (typeConverterAttribute != null) {
                        return Bridge.as(Bridge.createInstance(typeConverterAttribute.ConverterType), System.Windows.Markup.ITypeConverter);
                    }

                    return null;
                }
            }
        }
    });

    Bridge.ns("System.Windows.Markup.KnownTypes", $asm.$);

    Bridge.apply($asm.$.System.Windows.Markup.KnownTypes, {
        f1: function (type) {
            return Bridge.Reflection.getTypeFullName(type);
        }
    });

    Bridge.define("System.Windows.Markup.PropertyAdapter", {
        statics: {
            fields: {
                adaptersCache: null
            },
            ctors: {
                init: function () {
                    this.adaptersCache = Granular.Collections.CacheDictionary$2(System.Windows.Markup.TypeMemberKey,System.Windows.Markup.IPropertyAdapter).CreateUsingStringKeys$1(System.Windows.Markup.PropertyAdapter.TryCreateAdapter, $asm.$.System.Windows.Markup.PropertyAdapter.f1);
                }
            },
            methods: {
                CreateAdapter: function (targetType, propertyName) {
                    var propertyAdapter = { };
                    return System.Windows.Markup.PropertyAdapter.adaptersCache.TryGetValue(new System.Windows.Markup.TypeMemberKey(targetType, propertyName), propertyAdapter) ? propertyAdapter.v : null;
                },
                TryCreateAdapter: function (key, adapter) {
                    adapter.v = null;

                    var dependencyProperty = System.Windows.DependencyProperty.GetProperty(key.Type, key.MemberName);
                    if (dependencyProperty != null) {
                        adapter.v = new System.Windows.Markup.DependencyPropertyAdapter(dependencyProperty);
                        return true;
                    }

                    var clrProperty = System.Windows.Markup.PropertyAdapter.GetClrProperty(key.Type, key.MemberName);
                    if (clrProperty != null) {
                        adapter.v = new System.Windows.Markup.ClrPropertyAdapter(clrProperty);
                        return true;
                    }

                    return false;
                },
                GetClrProperty: function (containingType, propertyName) {
                    var propertyInfo = Granular.Extensions.TypeExtensions.GetInstanceProperty(containingType, propertyName);
                    return propertyInfo != null && !System.Reflection.PropertyInfoExtensions.IsDelegate(propertyInfo) ? propertyInfo : null;
                }
            }
        }
    });

    Bridge.ns("System.Windows.Markup.PropertyAdapter", $asm.$);

    Bridge.apply($asm.$.System.Windows.Markup.PropertyAdapter, {
        f1: function (typeMemberKey) {
            return typeMemberKey.StringKey;
        }
    });

    Bridge.define("System.Windows.Markup.PropertyPathParser", {
        statics: {
            fields: {
                lexer: null
            },
            ctors: {
                init: function () {
                    this.lexer = new System.Windows.Markup.Lexer([new System.Windows.Markup.RegexTokenDefinition(Bridge.box(System.Windows.Markup.PropertyPathParser.TokenType.Terminal, System.Windows.Markup.PropertyPathParser.TokenType, System.Enum.toStringFn(System.Windows.Markup.PropertyPathParser.TokenType)), new RegExp("^[\\(\\)\\[\\]\\.,]")), new System.Windows.Markup.RegexTokenDefinition(Bridge.box(System.Windows.Markup.PropertyPathParser.TokenType.Value, System.Windows.Markup.PropertyPathParser.TokenType, System.Enum.toStringFn(System.Windows.Markup.PropertyPathParser.TokenType)), new RegExp("^[^\\(\\)\\[\\]\\.\\,]*"))]);
                }
            }
        },
        fields: {
            text: null,
            namespaces: null,
            sourceUri: null,
            tokens: null
        },
        ctors: {
            ctor: function (text, namespaces, sourceUri) {
                this.$initialize();
                this.text = text;
                this.namespaces = namespaces;
                this.sourceUri = sourceUri;
            }
        },
        methods: {
            Parse: function () {
                this.tokens = new (Granular.Collections.ReadOnlyStack$1(System.Windows.Markup.Token))(System.Windows.Markup.PropertyPathParser.lexer.GetTokens(this.text));

                var elements = new (System.Collections.Generic.List$1(System.Windows.IPropertyPathElement)).ctor();

                elements.add(this.MatchElement(this.namespaces, this.sourceUri));

                while (!this.tokens.IsEmpty) {
                    this.MatchTerminal(".");
                    elements.add(this.MatchElement(this.namespaces, this.sourceUri));
                }

                return elements;
            },
            MatchElement: function (namespaces, sourceUri) {
                this.VerifyTokensExists();

                var propertyName = this.TryMatchPropertyName(namespaces);
                var indexRawValues = this.TryMatchIndexRawValues();

                if (propertyName.IsEmpty && !System.Linq.Enumerable.from(indexRawValues).any()) {
                    throw new Granular.Exception("Can't parse \"{0}\", Property name or Index parameters were expected, \"{1}\" was found at index {2}", [this.text, this.tokens.Peek().Value, Bridge.box(this.tokens.Peek().Start, System.Int32)]);
                }

                return System.Linq.Enumerable.from(indexRawValues).any() ? Bridge.cast(new System.Windows.IndexPropertyPathElement(propertyName, indexRawValues, namespaces, sourceUri), System.Windows.IPropertyPathElement) : new System.Windows.PropertyPathElement(propertyName);
            },
            TryMatchPropertyName: function (namespaces) {
                if (!this.tokens.IsEmpty && Bridge.referenceEquals(this.tokens.Peek().Value, "(")) {
                    this.MatchTerminal("(");

                    var propertyName = this.MatchValue();

                    if (!this.tokens.IsEmpty && Bridge.referenceEquals(this.tokens.Peek().Value, ".")) {
                        this.MatchTerminal(".");
                        propertyName = System.String.format("{0}.{1}", propertyName, this.MatchValue());
                    }

                    this.MatchTerminal(")");

                    var xamlName = System.Windows.Markup.XamlName.FromPrefixedName(propertyName, namespaces);

                    if (xamlName.IsEmpty) {
                        throw new Granular.Exception("Can't parse \"{0}\", Can't parse property name \"{1}\" at index {2}, is namespace missing?", [this.text, propertyName, Bridge.box(((((this.tokens.Peek().Start - propertyName.length) | 0) - 1) | 0), System.Int32)]);
                    }

                    return xamlName;
                }

                if (!this.tokens.IsEmpty && System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.tokens.Peek().Id), System.Int32)) === System.Windows.Markup.PropertyPathParser.TokenType.Value) {
                    return new System.Windows.Markup.XamlName(this.MatchValue());
                }

                return System.Windows.Markup.XamlName.Empty;
            },
            TryMatchIndexRawValues: function () {
                var values = new (System.Collections.Generic.List$1(System.String)).ctor();

                if (!this.tokens.IsEmpty && Bridge.referenceEquals(this.tokens.Peek().Value, "[")) {
                    this.MatchTerminal("[");
                    values.add(this.MatchValue());

                    while (!this.tokens.IsEmpty && Bridge.referenceEquals(this.tokens.Peek().Value, ",")) {
                        this.MatchTerminal(",");
                        values.add(this.MatchValue());
                    }

                    this.MatchTerminal("]");
                }

                return values;
            },
            MatchValue: function () {
                this.VerifyTokensExists();

                var token = this.tokens.Pop();

                if (System.Nullable.getValue(Bridge.cast(Bridge.unbox(token.Id), System.Int32)) !== System.Windows.Markup.PropertyPathParser.TokenType.Value) {
                    throw new Granular.Exception("Can't parse \"{0}\", \"{1}\" was not expected at index {2}", [this.text, token.Value, Bridge.box(token.Start, System.Int32)]);
                }

                return token.Value;
            },
            MatchTerminal: function (terminal) {
                this.VerifyTokensExists();

                var token = this.tokens.Pop();

                if (System.Nullable.getValue(Bridge.cast(Bridge.unbox(token.Id), System.Int32)) !== System.Windows.Markup.PropertyPathParser.TokenType.Terminal || !Bridge.referenceEquals(token.Value, terminal)) {
                    throw new Granular.Exception("Can't parse \"{0}\", \"{1}\" is expected, \"{2}\" was found at index {3}", [this.text, terminal, token.Value, Bridge.box(token.Start, System.Int32)]);
                }

                return token;
            },
            VerifyTokensExists: function () {
                if (this.tokens.IsEmpty) {
                    throw new Granular.Exception("Can't parse \"{0}\", stream was terminated unexpectedly", [this.text]);
                }
            }
        }
    });

    Bridge.define("System.Windows.Markup.PropertyPathParser.TokenType", {
        $kind: "enum",
        statics: {
            fields: {
                Terminal: 0,
                Value: 1
            }
        }
    });

    Bridge.define("System.Windows.Markup.SupportsValueProviderAttribute", {
        inherits: [System.Attribute]
    });

    Bridge.define("System.Windows.Markup.TypeConverter", {
        statics: {
            fields: {
                Empty: null
            },
            ctors: {
                init: function () {
                    this.Empty = new System.Windows.Markup.TypeConverter.EmptyTypeConverter();
                }
            },
            methods: {
                TryGetTypeConverter: function (sourceType, targetType, typeConverter) {
                    if (Bridge.Reflection.isAssignableFrom(targetType, sourceType)) {
                        typeConverter.v = System.Windows.Markup.TypeConverter.Empty;
                        return true;
                    }

                    typeConverter.v = System.Windows.Markup.KnownTypes.GetTypeConverter(targetType);
                    return typeConverter.v != null;
                },
                GetTypeConverter: function (sourceType, targetType) {
                    var typeConverter = { };

                    if (!System.Windows.Markup.TypeConverter.TryGetTypeConverter(sourceType, targetType, typeConverter)) {
                        throw new Granular.Exception("Can't create type converter from \"{0}\" to \"{1}\"", [Bridge.Reflection.getTypeName(sourceType), Bridge.Reflection.getTypeName(targetType)]);
                    }

                    return typeConverter.v;
                },
                TryConvertValue: function (value, type, namespaces, sourceUri, result) {
                    var typeConverter = { };

                    if (System.Windows.Markup.TypeConverter.TryGetTypeConverter(Bridge.getType(value), type, typeConverter)) {
                        result.v = typeConverter.v.System$Windows$Markup$ITypeConverter$ConvertFrom(namespaces, sourceUri, value);
                        return true;
                    }

                    result.v = null;
                    return false;
                },
                ConvertValue: function (value, type, namespaces, sourceUri) {
                    var result = { };

                    if (!System.Windows.Markup.TypeConverter.TryConvertValue(value, type, namespaces, sourceUri, result)) {
                        throw new Granular.Exception("Can't convert \"{0}\" to {1}", [value, Bridge.Reflection.getTypeName(type)]);
                    }

                    return result.v;
                }
            }
        }
    });

    Bridge.define("System.Windows.Markup.TypeConverterAttribute", {
        inherits: [System.Attribute],
        props: {
            ConverterType: null
        },
        ctors: {
            ctor: function (converterType) {
                this.$initialize();
                System.Attribute.ctor.call(this);
                this.ConverterType = converterType;
            }
        }
    });

    Bridge.define("System.Windows.Markup.TypeMemberKey", {
        fields: {
            hashCode: 0
        },
        props: {
            Type: null,
            MemberName: null,
            StringKey: null
        },
        ctors: {
            ctor: function (type, memberName) {
                this.$initialize();
                this.Type = type;
                this.MemberName = memberName;
                this.StringKey = (Bridge.Reflection.getTypeFullName(this.Type) || "") + "," + (this.MemberName || "");

                this.hashCode = Bridge.getHashCode(this.StringKey);
            }
        },
        methods: {
            equals: function (obj) {
                var other = Bridge.as(obj, System.Windows.Markup.TypeMemberKey);

                return Bridge.referenceEquals(this, other) || !Bridge.referenceEquals(other, null) && Bridge.equals(this.Type, other.Type) && Bridge.equals(this.MemberName, other.MemberName);
            },
            getHashCode: function () {
                return this.hashCode;
            },
            toString: function () {
                return System.String.format("{0}.{1}", Bridge.Reflection.getTypeFullName(this.Type), this.MemberName);
            }
        }
    });

    Bridge.define("System.Windows.Markup.TypeParser", {
        statics: {
            fields: {
                ClrNamespacePrefix: null,
                AssemblyQualifier: null,
                resolvedTypesCache: null,
                xmlnsDefinitionAttributesCache: null
            },
            ctors: {
                init: function () {
                    this.ClrNamespacePrefix = "clr-namespace:";
                    this.AssemblyQualifier = ";assembly=";
                    this.resolvedTypesCache = Granular.Collections.CacheDictionary$2(System.Windows.Markup.XamlName,Function).CreateUsingStringKeys$1(System.Windows.Markup.TypeParser.TryResolveType, $asm.$.System.Windows.Markup.TypeParser.f1);
                }
            },
            methods: {
                ParseType: function (prefixedTypeName, namespaces) {
                    return System.Windows.Markup.TypeParser.ParseType$1(System.Windows.Markup.XamlName.FromPrefixedName(prefixedTypeName, namespaces));
                },
                ParseType$1: function (name) {
                    var type = { };

                    if (!System.Windows.Markup.TypeParser.TryParseType$1(name, type)) {
                        throw new Granular.Exception("Type \"{0}\" wasn't found", [name]);
                    }

                    return type.v;
                },
                TryParseType: function (prefixedTypeName, namespaces, type) {
                    return System.Windows.Markup.TypeParser.TryParseType$1(System.Windows.Markup.XamlName.FromPrefixedName(prefixedTypeName, namespaces), type);
                },
                TryParseType$1: function (name, type) {
                    return System.Windows.Markup.TypeParser.resolvedTypesCache.TryGetValue(name, type);
                },
                TryResolveType: function (name, type) {
                    if (System.Windows.Markup.XamlTypes.TryParseXamlType(name, type)) {
                        return true;
                    }

                    var extensionName = new System.Windows.Markup.XamlName(System.String.format("{0}Extension", name.LocalName), name.NamespaceName);

                    return System.Windows.Markup.TypeParser.TryGetType$2(name, type) || System.Windows.Markup.TypeParser.TryGetType$2(extensionName, type);
                },
                TryGetType$2: function (xamlName, type) {
                    var $t;
                    if (Granular.Compatibility.String.StartsWith$1(xamlName.NamespaceName, System.Windows.Markup.TypeParser.ClrNamespacePrefix)) {
                        var clrNamespace = System.Windows.Markup.TypeParser.GetClrNamespace(xamlName.NamespaceName.substr(System.Windows.Markup.TypeParser.ClrNamespacePrefix.length));
                        var assemblyName = System.Windows.Markup.TypeParser.GetAssemblyName(xamlName.NamespaceName.substr(System.Windows.Markup.TypeParser.ClrNamespacePrefix.length));

                        if (System.Windows.Markup.TypeParser.TryGetType(xamlName.LocalName, clrNamespace, assemblyName, type)) {
                            return true;
                        }

                        return false;
                    }

                    $t = Bridge.getEnumerator(System.Windows.Markup.TypeParser.GetXmlnsDefinitionAttributes(), System.Windows.Markup.XmlnsDefinitionAttribute);
                    try {
                        while ($t.moveNext()) {
                            var xmlnsDefinition = $t.Current;
                            if (Bridge.referenceEquals(xmlnsDefinition.XmlNamespace, xamlName.NamespaceName) && System.Windows.Markup.TypeParser.TryGetType(xamlName.LocalName, xmlnsDefinition.ClrNamespace, xmlnsDefinition.AssemblyName, type)) {
                                return true;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$dispose();
                        }
                    }
                    type.v = null;
                    return false;
                },
                TryGetType: function (localName, clrNamespace, assemblyName, type) {
                    var $t;
                    if (!Granular.Extensions.StringExtensions.IsNullOrEmpty(assemblyName)) {
                        return System.Windows.Markup.TypeParser.TryGetType$1(System.String.format("{0}.{1}, {2}", clrNamespace, localName, assemblyName), type);
                    }

                    if (System.Windows.Markup.TypeParser.TryGetType$1(System.String.format("{0}.{1}", clrNamespace, localName), type)) {
                        return true;
                    }

                    $t = Bridge.getEnumerator(System.AppDomain.getAssemblies());
                    try {
                        while ($t.moveNext()) {
                            var assembly = $t.Current;
                            if (System.Windows.Markup.TypeParser.TryGetType$1(System.String.format("{0}.{1}, {2}", clrNamespace, localName, System.AssemblyExtensions.GetName(assembly).Name), type)) {
                                return true;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$dispose();
                        }
                    }
                    type.v = null;
                    return false;
                },
                TryGetType$1: function (qualifiedTypeName, type) {
                    type.v = Bridge.Reflection.getType(qualifiedTypeName);
                    return type.v != null;
                },
                GetClrNamespace: function (qualifiedNamespace) {
                    var assemblyQualifierIndex = System.String.indexOf(qualifiedNamespace, System.Windows.Markup.TypeParser.AssemblyQualifier);
                    return assemblyQualifierIndex === -1 ? qualifiedNamespace : qualifiedNamespace.substr(0, assemblyQualifierIndex);
                },
                GetAssemblyName: function (qualifiedNamespace) {
                    var assemblyQualifierIndex = System.String.indexOf(qualifiedNamespace, System.Windows.Markup.TypeParser.AssemblyQualifier);
                    return assemblyQualifierIndex === -1 ? "" : qualifiedNamespace.substr(((assemblyQualifierIndex + System.Windows.Markup.TypeParser.AssemblyQualifier.length) | 0));
                },
                GetXmlnsDefinitionAttributes: function () {
                    if (System.Windows.Markup.TypeParser.xmlnsDefinitionAttributesCache == null) {
                        System.Windows.Markup.TypeParser.xmlnsDefinitionAttributesCache = System.Linq.Enumerable.from(System.AppDomain.getAssemblies()).selectMany($asm.$.System.Windows.Markup.TypeParser.f2).toArray(System.Windows.Markup.XmlnsDefinitionAttribute);
                    }

                    return System.Windows.Markup.TypeParser.xmlnsDefinitionAttributesCache;
                }
            }
        }
    });

    Bridge.ns("System.Windows.Markup.TypeParser", $asm.$);

    Bridge.apply($asm.$.System.Windows.Markup.TypeParser, {
        f1: function (xamlName) {
            return xamlName.FullName;
        },
        f2: function (assembly) {
            return Granular.Extensions.AssemblyExtensions.GetCustomAttributesCached(System.Windows.Markup.XmlnsDefinitionAttribute, assembly);
        }
    });

    Bridge.define("System.Windows.Markup.XamlElementExtensions", {
        statics: {
            methods: {
                GetElementType: function (element) {
                    return System.Windows.Markup.TypeParser.ParseType$1(element.Name);
                }
            }
        }
    });

    Bridge.define("System.Windows.Markup.XamlLoader", {
        statics: {
            methods: {
                Load: function (resource) {
                    var factory = System.Windows.Markup.ElementFactory.FromXamlElement(resource, null);
                    return factory.System$Windows$Markup$IElementFactory$CreateElement(new System.Windows.Markup.InitializeContext.ctor());
                },
                Load$1: function (target, resource) {
                    var initializer = new System.Windows.Markup.ElementInitializer(resource);
                    initializer.System$Windows$Markup$IElementInitializer$InitializeElement(target, new System.Windows.Markup.InitializeContext.ctor());
                }
            }
        }
    });

    Bridge.define("System.Windows.Markup.XamlNameExtensions", {
        statics: {
            methods: {
                ResolveContainingType: function (name, defaultContainingType) {
                    return name.HasContainingTypeName ? System.Windows.Markup.TypeParser.ParseType$1(new System.Windows.Markup.XamlName(name.ContainingTypeName, name.NamespaceName)) : defaultContainingType;
                }
            }
        }
    });

    Bridge.define("System.Windows.Markup.XamlTypes", {
        statics: {
            methods: {
                TryParseXamlType: function (name, type) {
                    if (System.Windows.Markup.XamlName.op_Equality(name, System.Windows.Markup.XamlLanguage.NullTypeName)) {
                        type.v = System.Windows.Markup.XamlTypes.NullProvider;
                        return true;
                    }

                    if (System.Windows.Markup.XamlName.op_Equality(name, System.Windows.Markup.XamlLanguage.TypeTypeName)) {
                        type.v = System.Windows.Markup.XamlTypes.TypeProvider;
                        return true;
                    }

                    type.v = null;
                    return false;
                },
                ParseXamlType: function (xamlName) {
                    var type = { };

                    if (!System.Windows.Markup.XamlTypes.TryParseXamlType(xamlName, type)) {
                        throw new Granular.Exception("Type {0} wasn't found", [xamlName]);
                    }

                    return type.v;
                }
            }
        }
    });

    Bridge.define("System.Windows.Markup.XmlnsDefinitionAttribute", {
        inherits: [System.Attribute],
        props: {
            XmlNamespace: null,
            ClrNamespace: null,
            AssemblyName: null
        },
        ctors: {
            ctor: function (xmlNamespace, clrNamespace, assemblyName) {
                if (assemblyName === void 0) { assemblyName = null; }

                this.$initialize();
                System.Attribute.ctor.call(this);
                this.XmlNamespace = xmlNamespace;
                this.ClrNamespace = clrNamespace;
                this.AssemblyName = assemblyName;
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.AnimatableExtensions", {
        statics: {
            methods: {
                ClearAnimationClocks: function (animatable, dependencyProperty, layerOwner) {
                    if (layerOwner === void 0) { layerOwner = null; }
                    animatable.System$Windows$Media$Animation$IAnimatable$SetAnimationClocks(dependencyProperty, System.Array.init(0, null, System.Windows.Media.Animation.AnimationTimelineClock), layerOwner);
                },
                ApplyAnimationClock: function (animatable, dependencyProperty, animationClock, handoffBehavior, layerOwner) {
                    if (handoffBehavior === void 0) { handoffBehavior = 0; }
                    if (layerOwner === void 0) { layerOwner = null; }
                    var animationClocks = animationClock != null ? System.Array.init([animationClock], System.Windows.Media.Animation.AnimationTimelineClock) : System.Array.init(0, null, System.Windows.Media.Animation.AnimationTimelineClock);
                    System.Windows.Media.Animation.AnimatableExtensions.ApplyAnimationClocks(animatable, dependencyProperty, animationClocks, handoffBehavior, layerOwner);
                },
                ApplyAnimationClocks: function (animatable, dependencyProperty, animationClocks, handoffBehavior, layerOwner) {
                    if (handoffBehavior === void 0) { handoffBehavior = 0; }
                    if (layerOwner === void 0) { layerOwner = null; }
                    if (handoffBehavior === System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace) {
                        animatable.System$Windows$Media$Animation$IAnimatable$SetAnimationClocks(dependencyProperty, animationClocks, layerOwner);
                    } else {
                        animatable.System$Windows$Media$Animation$IAnimatable$AddAnimationClocks(dependencyProperty, animationClocks, layerOwner);
                    }
                },
                BeginAnimation: function (animatable, dependencyProperty, animation, handoffBehavior, layerOwner) {
                    if (handoffBehavior === void 0) { handoffBehavior = 0; }
                    if (layerOwner === void 0) { layerOwner = null; }
                    var animationClock = Bridge.cast(animation.CreateClock(), System.Windows.Media.Animation.AnimationTimelineClock);
                    System.Windows.Media.Animation.AnimatableExtensions.ApplyAnimationClock(animatable, dependencyProperty, animationClock, handoffBehavior, layerOwner);
                    animationClock.Begin(animatable.System$Windows$Media$Animation$IAnimatable$RootClock);
                }
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.IRootClock", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Media.Animation.IClock", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Media.Animation.AnimationLayer", {
        inherits: [System.IDisposable],
        statics: {
            fields: {
                UnsetValue: null
            },
            ctors: {
                init: function () {
                    this.UnsetValue = new System.Windows.Data.NamedObject("AnimationLayer.UnsetValue");
                }
            }
        },
        fields: {
            clocks: null,
            snapshotValue: null
        },
        events: {
            ClockInvalidated: null
        },
        props: {
            HasValue: {
                get: function () {
                    return System.Linq.Enumerable.from(this.clocks).any($asm.$.System.Windows.Media.Animation.AnimationLayer.f1);
                }
            },
            IsEmpty: {
                get: function () {
                    return !System.Linq.Enumerable.from(this.clocks).any();
                }
            }
        },
        alias: ["dispose", "System$IDisposable$dispose"],
        ctors: {
            ctor: function () {
                this.$initialize();
                this.clocks = System.Array.init(0, null, System.Windows.Media.Animation.AnimationTimelineClock);
                this.snapshotValue = System.Windows.Media.Animation.AnimationLayer.UnsetValue;
            }
        },
        methods: {
            GetValue: function (defaultDestinationValue) {
                var $t;
                var defaultOriginValue = Bridge.referenceEquals(this.snapshotValue, System.Windows.Media.Animation.AnimationLayer.UnsetValue) ? defaultDestinationValue : this.snapshotValue;

                $t = Bridge.getEnumerator(this.clocks, System.Windows.Media.Animation.AnimationTimelineClock);
                try {
                    while ($t.moveNext()) {
                        var clock = $t.Current;
                        if (clock.CurrentState.ProgressState === System.Windows.Media.Animation.ClockProgressState.Active || clock.IsFilling) {
                            defaultOriginValue = clock.GetValue(defaultOriginValue, defaultDestinationValue);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                return defaultOriginValue;
            },
            SetClocks: function (newClocks, defaultDestinationValue) {
                this.DetachClocks(this.clocks);

                this.snapshotValue = System.Linq.Enumerable.from(newClocks).any() ? this.GetValue(defaultDestinationValue) : System.Windows.Media.Animation.AnimationLayer.UnsetValue;
                this.clocks = System.Linq.Enumerable.from(newClocks).toArray();

                this.AttachClocks(this.clocks);
            },
            AddClocks: function (newClocks) {
                if (System.Linq.Enumerable.from(newClocks).except(this.clocks).count() !== System.Linq.Enumerable.from(newClocks).count()) {
                    throw new Granular.Exception("Can't add clocks that already exist on the animation layer");
                }

                this.AttachClocks(newClocks);

                this.clocks = System.Linq.Enumerable.from(this.clocks).concat(newClocks).toArray(System.Windows.Media.Animation.AnimationTimelineClock);
            },
            RemoveClocks: function (oldClocks) {
                if (System.Linq.Enumerable.from(oldClocks).except(this.clocks).count() !== 0) {
                    throw new Granular.Exception("Can't remove clocks that don't exist on the animation layer");
                }

                this.DetachClocks(oldClocks);

                this.clocks = System.Linq.Enumerable.from(this.clocks).except(oldClocks).toArray(System.Windows.Media.Animation.AnimationTimelineClock);
            },
            AttachClocks: function (newClocks) {
                var $t;
                $t = Bridge.getEnumerator(newClocks, System.Windows.Media.Animation.AnimationTimelineClock);
                try {
                    while ($t.moveNext()) {
                        var clock = $t.Current;
                        clock.addInvalidated(Bridge.fn.cacheBind(this, this.OnClockInvalidated));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }},
            DetachClocks: function (oldClocks) {
                var $t;
                $t = Bridge.getEnumerator(oldClocks, System.Windows.Media.Animation.AnimationTimelineClock);
                try {
                    while ($t.moveNext()) {
                        var clock = $t.Current;
                        clock.removeInvalidated(Bridge.fn.cacheBind(this, this.OnClockInvalidated));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }},
            OnClockInvalidated: function (sender, e) {
                Granular.Extensions.EventHandlerExtensions.Raise$2(this.ClockInvalidated, this);
            },
            dispose: function () {
                this.DetachClocks(this.clocks);
            }
        }
    });

    Bridge.ns("System.Windows.Media.Animation.AnimationLayer", $asm.$);

    Bridge.apply($asm.$.System.Windows.Media.Animation.AnimationLayer, {
        f1: function (clock) {
            return clock.CurrentState.ProgressState === System.Windows.Media.Animation.ClockProgressState.Active || clock.IsFilling;
        }
    });

    Bridge.define("System.Windows.Media.Animation.AnimationLayerCollection", {
        fields: {
            defaultLayer: null,
            layers: null
        },
        events: {
            LayerInvalidated: null
        },
        props: {
            HasValue: {
                get: function () {
                    return this.defaultLayer.HasValue || System.Linq.Enumerable.from(this.layers.getValues()).any($asm.$.System.Windows.Media.Animation.AnimationLayerCollection.f1);
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                this.defaultLayer = new System.Windows.Media.Animation.AnimationLayer();
                this.defaultLayer.addClockInvalidated(Bridge.fn.cacheBind(this, this.OnAnimationLayerClockInvalidated));

                this.layers = new (System.Collections.Generic.Dictionary$2(System.Windows.Media.Animation.AnimationLayerKey,System.Windows.Media.Animation.AnimationLayer))();
            }
        },
        methods: {
            GetValue: function (defaultDestinationValue) {
                var $t;
                $t = Bridge.getEnumerator(this.layers.getValues(), System.Windows.Media.Animation.AnimationLayer);
                try {
                    while ($t.moveNext()) {
                        var layer = $t.Current;
                        defaultDestinationValue = layer.GetValue(defaultDestinationValue);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                return this.defaultLayer.GetValue(defaultDestinationValue);
            },
            SetClocks: function (newClocks, defaultDestinationValue, key) {
                if (System.Linq.Enumerable.from(newClocks).any() || Bridge.referenceEquals(key, System.Windows.Media.Animation.AnimationLayerKey.Default)) {
                    this.GetAnimationLayer(key).SetClocks(newClocks, defaultDestinationValue);
                } else {
                    this.RemoveAnimationLayer(key);
                }

                Granular.Extensions.EventHandlerExtensions.Raise$2(this.LayerInvalidated, this);
            },
            AddClocks: function (newClocks, key) {
                this.GetAnimationLayer(key).AddClocks(newClocks);
                Granular.Extensions.EventHandlerExtensions.Raise$2(this.LayerInvalidated, this);
            },
            RemoveClocks: function (newClocks, key) {
                var animationLayer = this.GetAnimationLayer(key);

                animationLayer.RemoveClocks(newClocks);

                if (!Bridge.referenceEquals(key, System.Windows.Media.Animation.AnimationLayerKey.Default) && animationLayer.IsEmpty) {
                    this.RemoveAnimationLayer(key);
                }

                Granular.Extensions.EventHandlerExtensions.Raise$2(this.LayerInvalidated, this);
            },
            GetAnimationLayer: function (key) {
                if (Bridge.referenceEquals(key, System.Windows.Media.Animation.AnimationLayerKey.Default)) {
                    return this.defaultLayer;
                }

                var layer = { };

                if (!this.layers.tryGetValue(key, layer)) {
                    layer.v = new System.Windows.Media.Animation.AnimationLayer();
                    layer.v.addClockInvalidated(Bridge.fn.cacheBind(this, this.OnAnimationLayerClockInvalidated));

                    this.layers.add(key, layer.v);
                }

                return layer.v;
            },
            RemoveAnimationLayer: function (key) {
                var layer = { };

                if (Bridge.referenceEquals(key, System.Windows.Media.Animation.AnimationLayerKey.Default)) {
                    throw new Granular.Exception("Can't remove default animation layer");
                }

                if (this.layers.tryGetValue(key, layer)) {
                    layer.v.removeClockInvalidated(Bridge.fn.cacheBind(this, this.OnAnimationLayerClockInvalidated));
                    layer.v.dispose();

                    this.layers.remove(key);
                }
            },
            OnAnimationLayerClockInvalidated: function (sender, e) {
                Granular.Extensions.EventHandlerExtensions.Raise$2(this.LayerInvalidated, this);
            }
        }
    });

    Bridge.ns("System.Windows.Media.Animation.AnimationLayerCollection", $asm.$);

    Bridge.apply($asm.$.System.Windows.Media.Animation.AnimationLayerCollection, {
        f1: function (layer) {
            return layer.HasValue;
        }
    });

    Bridge.define("System.Windows.Media.Animation.AnimationLayerKey", {
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Media.Animation.AnimationLayerKey(null);
                }
            },
            methods: {
                FromLayerOwner: function (layerOwner) {
                    return layerOwner == null ? System.Windows.Media.Animation.AnimationLayerKey.Default : new System.Windows.Media.Animation.AnimationLayerKey(layerOwner);
                }
            }
        },
        fields: {
            layerOwner: null
        },
        ctors: {
            ctor: function (layerOwner) {
                this.$initialize();
                this.layerOwner = layerOwner;
            }
        },
        methods: {
            equals: function (obj) {
                var other = Bridge.as(obj, System.Windows.Media.Animation.AnimationLayerKey);

                return Bridge.referenceEquals(this, other) || !Bridge.referenceEquals(other, null) && Bridge.equals(this.layerOwner, other.layerOwner);
            },
            getHashCode: function () {
                return this.layerOwner == null ? 0 : Bridge.getHashCode(this.layerOwner);
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.IEasingFunction", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Media.Animation.ClockProgressState", {
        $kind: "enum",
        statics: {
            fields: {
                BeforeStarted: 0,
                Active: 1,
                AfterEnded: 2
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.ClockState", {
        statics: {
            fields: {
                Empty: null
            },
            ctors: {
                init: function () {
                    this.Empty = new System.Windows.Media.Animation.ClockState(System.Windows.Media.Animation.ClockProgressState.BeforeStarted, 0, 0, Granular.Compatibility.TimeSpan.MinValue, Granular.Compatibility.TimeSpan.MaxValue);
                }
            }
        },
        props: {
            ProgressState: 0,
            Progress: 0,
            Iteration: 0,
            PreviousTick: null,
            NextTick: null
        },
        ctors: {
            init: function () {
                this.PreviousTick = new System.TimeSpan();
                this.NextTick = new System.TimeSpan();
            },
            ctor: function (progressState, progress, iteration, previousTick, nextTick) {
                this.$initialize();
                this.ProgressState = progressState;
                this.Progress = progress;
                this.Iteration = iteration;
                this.PreviousTick = previousTick;
                this.NextTick = nextTick;
            }
        }
    });

    Bridge.definei("System.Windows.Media.Animation.IAnimationOperations$1", function (T) { return {
        $kind: "interface"
    }; });

    Bridge.define("System.Windows.Media.Animation.EasingMode", {
        $kind: "enum",
        statics: {
            fields: {
                EaseIn: 0,
                EaseOut: 1,
                EaseInOut: 2
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.FillBehavior", {
        $kind: "enum",
        statics: {
            fields: {
                HoldEnd: 0,
                Stop: 1
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.HandoffBehavior", {
        $kind: "enum",
        statics: {
            fields: {
                SnapshotAndReplace: 0,
                Compose: 1
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.KeyTime", {
        statics: {
            fields: {
                Paced: null,
                Uniform: null
            },
            ctors: {
                init: function () {
                    this.Paced = new System.Windows.Media.Animation.KeyTime(System.Windows.Media.Animation.KeyTimeType.Paced, System.TimeSpan.zero, Number.NaN);
                    this.Uniform = new System.Windows.Media.Animation.KeyTime(System.Windows.Media.Animation.KeyTimeType.Uniform, System.TimeSpan.zero, Number.NaN);
                }
            },
            methods: {
                FromTimeSpan: function (timeSpan) {
                    return new System.Windows.Media.Animation.KeyTime(System.Windows.Media.Animation.KeyTimeType.TimeSpan, timeSpan, Number.NaN);
                },
                FromPercent: function (percent) {
                    return new System.Windows.Media.Animation.KeyTime(System.Windows.Media.Animation.KeyTimeType.Percent, System.TimeSpan.zero, percent);
                },
                Parse: function (value) {
                    value = value.trim();

                    if (Bridge.referenceEquals(value, "Paced")) {
                        return System.Windows.Media.Animation.KeyTime.Paced;
                    }

                    if (Bridge.referenceEquals(value, "Uniform")) {
                        return System.Windows.Media.Animation.KeyTime.Uniform;
                    }

                    if (System.String.endsWith(value, "%")) {
                        var percent = { };
                        if (System.Double.tryParse(value.substr(0, ((value.length - 1) | 0)), null, percent)) {
                            return System.Windows.Media.Animation.KeyTime.FromPercent(percent.v / 100);
                        }
                    }

                    var timeSpan = { };
                    if (Granular.Compatibility.TimeSpan.TryParse(value, timeSpan)) {
                        return System.Windows.Media.Animation.KeyTime.FromTimeSpan(timeSpan.v);
                    }

                    throw new Granular.Exception("Can't parse KeyTime value \"{0}\"", [value]);
                }
            }
        },
        props: {
            Type: 0,
            TimeSpan: null,
            Percent: 0,
            HasTimeSpan: {
                get: function () {
                    return this.Type === System.Windows.Media.Animation.KeyTimeType.TimeSpan;
                }
            },
            HasPercent: {
                get: function () {
                    return this.Type === System.Windows.Media.Animation.KeyTimeType.Percent;
                }
            },
            IsPaced: {
                get: function () {
                    return this.Type === System.Windows.Media.Animation.KeyTimeType.Paced;
                }
            },
            IsUniform: {
                get: function () {
                    return this.Type === System.Windows.Media.Animation.KeyTimeType.Uniform;
                }
            }
        },
        ctors: {
            init: function () {
                this.TimeSpan = new System.TimeSpan();
            },
            ctor: function (type, timeSpan, percent) {
                this.$initialize();
                this.Type = type;
                this.TimeSpan = timeSpan;
                this.Percent = percent;
            }
        },
        methods: {
            equals: function (obj) {
                var other = Bridge.as(obj, System.Windows.Media.Animation.KeyTime);

                return Bridge.referenceEquals(this, other) || !Bridge.referenceEquals(other, null) && Bridge.equals(Bridge.box(this.Type, System.Windows.Media.Animation.KeyTimeType, System.Enum.toStringFn(System.Windows.Media.Animation.KeyTimeType)), Bridge.box(other.Type, System.Windows.Media.Animation.KeyTimeType, System.Enum.toStringFn(System.Windows.Media.Animation.KeyTimeType))) && Bridge.equals(this.TimeSpan, other.TimeSpan) && Bridge.equals(Bridge.box(this.Percent, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(other.Percent, System.Double, System.Double.format, System.Double.getHashCode));
            },
            getHashCode: function () {
                return Bridge.getHashCode(this.Type) ^ Bridge.getHashCode(this.TimeSpan) ^ System.Double.getHashCode(this.Percent);
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.KeyTimeType", {
        $kind: "enum",
        statics: {
            fields: {
                Uniform: 0,
                Percent: 1,
                TimeSpan: 2,
                Paced: 3
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.RepeatBehavior", {
        statics: {
            fields: {
                Forever: null,
                OneTime: null
            },
            ctors: {
                init: function () {
                    this.Forever = new System.Windows.Media.Animation.RepeatBehavior(Number.POSITIVE_INFINITY, System.TimeSpan.zero);
                    this.OneTime = new System.Windows.Media.Animation.RepeatBehavior(1, System.TimeSpan.zero);
                }
            },
            methods: {
                FromRepeatCount: function (count) {
                    return new System.Windows.Media.Animation.RepeatBehavior(count, System.TimeSpan.zero);
                },
                FromTimeSpan: function (timeSpan) {
                    return new System.Windows.Media.Animation.RepeatBehavior(Number.NaN, timeSpan);
                },
                Parse: function (value) {
                    value = value.trim();

                    if (Bridge.referenceEquals(value, "Forever")) {
                        return System.Windows.Media.Animation.RepeatBehavior.Forever;
                    }

                    if (Bridge.referenceEquals(value, "OneTime")) {
                        return System.Windows.Media.Animation.RepeatBehavior.OneTime;
                    }

                    if (System.String.endsWith(value, "x")) {
                        var count = { };
                        if (System.Double.tryParse(value.substr(0, ((value.length - 1) | 0)), null, count)) {
                            return System.Windows.Media.Animation.RepeatBehavior.FromRepeatCount(count.v);
                        }
                    }

                    var timeSpan = { };
                    if (Granular.Compatibility.TimeSpan.TryParse(value, timeSpan)) {
                        return System.Windows.Media.Animation.RepeatBehavior.FromTimeSpan(timeSpan.v);
                    }

                    throw new Granular.Exception("Can't parse RepeatBehavior value \"{0}\"", [value]);
                }
            }
        },
        props: {
            Count: 0,
            Duration: null
        },
        ctors: {
            init: function () {
                this.Duration = new System.TimeSpan();
            },
            ctor: function (count, duration) {
                this.$initialize();
                this.Count = count;
                this.Duration = duration;
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.RootClock.ClockSchedule", {
        props: {
            Clock: null,
            NextTick: null
        },
        ctors: {
            init: function () {
                this.NextTick = new System.TimeSpan();
            },
            ctor: function (clock) {
                this.$initialize();
                this.Clock = clock;
                this.NextTick = clock.System$Windows$Media$Animation$IClock$FirstTick;
            }
        },
        methods: {
            Tick: function (time) {
                var state = this.Clock.System$Windows$Media$Animation$IClock$Tick(time);
                this.NextTick = state.NextTick;
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.Storyboard.TargetKey", {
        fields: {
            hashCode: 0
        },
        props: {
            Target: null,
            TargetProperty: null
        },
        ctors: {
            ctor: function (target, targetProperty) {
                this.$initialize();
                this.Target = target;
                this.TargetProperty = targetProperty;
                this.hashCode = Bridge.getHashCode(this.Target) ^ this.TargetProperty.getHashCode();
            }
        },
        methods: {
            equals: function (obj) {
                var other = Bridge.as(obj, System.Windows.Media.Animation.Storyboard.TargetKey);

                return Bridge.referenceEquals(this, other) || !Bridge.referenceEquals(other, null) && Bridge.equals(this.Target, other.Target) && Bridge.equals(this.TargetProperty, other.TargetProperty);
            },
            getHashCode: function () {
                return this.hashCode;
            }
        }
    });

    Bridge.define("System.Windows.Media.Brushes", {
        statics: {
            fields: {
                brushes: null
            },
            props: {
                AliceBlue: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.AliceBlue);
                    }
                },
                AntiqueWhite: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.AntiqueWhite);
                    }
                },
                Aqua: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Aqua);
                    }
                },
                Aquamarine: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Aquamarine);
                    }
                },
                Azure: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Azure);
                    }
                },
                Beige: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Beige);
                    }
                },
                Bisque: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Bisque);
                    }
                },
                Black: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Black);
                    }
                },
                BlanchedAlmond: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.BlanchedAlmond);
                    }
                },
                Blue: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Blue);
                    }
                },
                BlueViolet: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.BlueViolet);
                    }
                },
                Brown: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Brown);
                    }
                },
                BurlyWood: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.BurlyWood);
                    }
                },
                CadetBlue: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.CadetBlue);
                    }
                },
                Chartreuse: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Chartreuse);
                    }
                },
                Chocolate: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Chocolate);
                    }
                },
                Coral: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Coral);
                    }
                },
                CornflowerBlue: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.CornflowerBlue);
                    }
                },
                Cornsilk: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Cornsilk);
                    }
                },
                Crimson: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Crimson);
                    }
                },
                Cyan: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Cyan);
                    }
                },
                DarkBlue: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.DarkBlue);
                    }
                },
                DarkCyan: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.DarkCyan);
                    }
                },
                DarkGoldenrod: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.DarkGoldenrod);
                    }
                },
                DarkGray: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.DarkGray);
                    }
                },
                DarkGreen: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.DarkGreen);
                    }
                },
                DarkKhaki: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.DarkKhaki);
                    }
                },
                DarkMagenta: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.DarkMagenta);
                    }
                },
                DarkOliveGreen: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.DarkOliveGreen);
                    }
                },
                DarkOrange: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.DarkOrange);
                    }
                },
                DarkOrchid: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.DarkOrchid);
                    }
                },
                DarkRed: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.DarkRed);
                    }
                },
                DarkSalmon: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.DarkSalmon);
                    }
                },
                DarkSeaGreen: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.DarkSeaGreen);
                    }
                },
                DarkSlateBlue: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.DarkSlateBlue);
                    }
                },
                DarkSlateGray: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.DarkSlateGray);
                    }
                },
                DarkTurquoise: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.DarkTurquoise);
                    }
                },
                DarkViolet: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.DarkViolet);
                    }
                },
                DeepPink: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.DeepPink);
                    }
                },
                DeepSkyBlue: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.DeepSkyBlue);
                    }
                },
                DimGray: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.DimGray);
                    }
                },
                DodgerBlue: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.DodgerBlue);
                    }
                },
                Firebrick: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Firebrick);
                    }
                },
                FloralWhite: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.FloralWhite);
                    }
                },
                ForestGreen: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.ForestGreen);
                    }
                },
                Fuchsia: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Fuchsia);
                    }
                },
                Gainsboro: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Gainsboro);
                    }
                },
                GhostWhite: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.GhostWhite);
                    }
                },
                Gold: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Gold);
                    }
                },
                Goldenrod: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Goldenrod);
                    }
                },
                Gray: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Gray);
                    }
                },
                Green: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Green);
                    }
                },
                GreenYellow: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.GreenYellow);
                    }
                },
                Honeydew: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Honeydew);
                    }
                },
                HotPink: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.HotPink);
                    }
                },
                IndianRed: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.IndianRed);
                    }
                },
                Indigo: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Indigo);
                    }
                },
                Ivory: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Ivory);
                    }
                },
                Khaki: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Khaki);
                    }
                },
                Lavender: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Lavender);
                    }
                },
                LavenderBlush: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.LavenderBlush);
                    }
                },
                LawnGreen: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.LawnGreen);
                    }
                },
                LemonChiffon: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.LemonChiffon);
                    }
                },
                LightBlue: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.LightBlue);
                    }
                },
                LightCoral: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.LightCoral);
                    }
                },
                LightCyan: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.LightCyan);
                    }
                },
                LightGoldenrodYellow: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.LightGoldenrodYellow);
                    }
                },
                LightGray: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.LightGray);
                    }
                },
                LightGreen: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.LightGreen);
                    }
                },
                LightPink: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.LightPink);
                    }
                },
                LightSalmon: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.LightSalmon);
                    }
                },
                LightSeaGreen: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.LightSeaGreen);
                    }
                },
                LightSkyBlue: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.LightSkyBlue);
                    }
                },
                LightSlateGray: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.LightSlateGray);
                    }
                },
                LightSteelBlue: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.LightSteelBlue);
                    }
                },
                LightYellow: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.LightYellow);
                    }
                },
                Lime: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Lime);
                    }
                },
                LimeGreen: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.LimeGreen);
                    }
                },
                Linen: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Linen);
                    }
                },
                Magenta: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Magenta);
                    }
                },
                Maroon: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Maroon);
                    }
                },
                MediumAquamarine: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.MediumAquamarine);
                    }
                },
                MediumBlue: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.MediumBlue);
                    }
                },
                MediumOrchid: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.MediumOrchid);
                    }
                },
                MediumPurple: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.MediumPurple);
                    }
                },
                MediumSeaGreen: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.MediumSeaGreen);
                    }
                },
                MediumSlateBlue: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.MediumSlateBlue);
                    }
                },
                MediumSpringGreen: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.MediumSpringGreen);
                    }
                },
                MediumTurquoise: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.MediumTurquoise);
                    }
                },
                MediumVioletRed: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.MediumVioletRed);
                    }
                },
                MidnightBlue: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.MidnightBlue);
                    }
                },
                MintCream: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.MintCream);
                    }
                },
                MistyRose: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.MistyRose);
                    }
                },
                Moccasin: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Moccasin);
                    }
                },
                NavajoWhite: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.NavajoWhite);
                    }
                },
                Navy: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Navy);
                    }
                },
                OldLace: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.OldLace);
                    }
                },
                Olive: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Olive);
                    }
                },
                OliveDrab: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.OliveDrab);
                    }
                },
                Orange: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Orange);
                    }
                },
                OrangeRed: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.OrangeRed);
                    }
                },
                Orchid: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Orchid);
                    }
                },
                PaleGoldenrod: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.PaleGoldenrod);
                    }
                },
                PaleGreen: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.PaleGreen);
                    }
                },
                PaleTurquoise: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.PaleTurquoise);
                    }
                },
                PaleVioletRed: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.PaleVioletRed);
                    }
                },
                PapayaWhip: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.PapayaWhip);
                    }
                },
                PeachPuff: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.PeachPuff);
                    }
                },
                Peru: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Peru);
                    }
                },
                Pink: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Pink);
                    }
                },
                Plum: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Plum);
                    }
                },
                PowderBlue: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.PowderBlue);
                    }
                },
                Purple: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Purple);
                    }
                },
                Red: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Red);
                    }
                },
                RosyBrown: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.RosyBrown);
                    }
                },
                RoyalBlue: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.RoyalBlue);
                    }
                },
                SaddleBrown: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.SaddleBrown);
                    }
                },
                Salmon: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Salmon);
                    }
                },
                SandyBrown: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.SandyBrown);
                    }
                },
                SeaGreen: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.SeaGreen);
                    }
                },
                SeaShell: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.SeaShell);
                    }
                },
                Sienna: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Sienna);
                    }
                },
                Silver: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Silver);
                    }
                },
                SkyBlue: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.SkyBlue);
                    }
                },
                SlateBlue: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.SlateBlue);
                    }
                },
                SlateGray: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.SlateGray);
                    }
                },
                Snow: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Snow);
                    }
                },
                SpringGreen: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.SpringGreen);
                    }
                },
                SteelBlue: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.SteelBlue);
                    }
                },
                Tan: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Tan);
                    }
                },
                Teal: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Teal);
                    }
                },
                Thistle: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Thistle);
                    }
                },
                Tomato: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Tomato);
                    }
                },
                Transparent: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Transparent);
                    }
                },
                Turquoise: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Turquoise);
                    }
                },
                Violet: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Violet);
                    }
                },
                Wheat: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Wheat);
                    }
                },
                White: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.White);
                    }
                },
                WhiteSmoke: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.WhiteSmoke);
                    }
                },
                Yellow: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.Yellow);
                    }
                },
                YellowGreen: {
                    get: function () {
                        return System.Windows.Media.Brushes.brushes.GetValue(System.Windows.Media.Colors.YellowGreen);
                    }
                }
            },
            ctors: {
                init: function () {
                    this.brushes = Granular.Collections.CacheDictionary$2(System.Windows.Media.Color,System.Windows.Media.SolidColorBrush).Create(System.Windows.Media.Brushes.CreateBrush);
                }
            },
            methods: {
                CreateBrush: function (color) {
                    var solidColorBrush = new System.Windows.Media.SolidColorBrush.$ctor1(color);
                    solidColorBrush.Freeze();
                    return solidColorBrush;
                }
            }
        }
    });

    Bridge.define("System.Windows.Media.BrushMappingMode", {
        $kind: "enum",
        statics: {
            fields: {
                Absolute: 0,
                RelativeToBoundingBox: 1
            }
        }
    });

    Bridge.define("System.Windows.Media.ColorExtensions", {
        statics: {
            methods: {
                ApplyOpacity: function (color, opacity) {
                    return opacity === 1 ? color : System.Windows.Media.Color.FromArgb(Bridge.Int.clipu8(opacity * color.A), color.R, color.G, color.B);
                }
            }
        }
    });

    Bridge.define("System.Windows.Media.Colors", {
        statics: {
            props: {
                AliceBlue: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4293982463);
                    }
                },
                AntiqueWhite: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294634455);
                    }
                },
                Aqua: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4278255615);
                    }
                },
                Aquamarine: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4286578644);
                    }
                },
                Azure: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4293984255);
                    }
                },
                Beige: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294309340);
                    }
                },
                Bisque: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294960324);
                    }
                },
                Black: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4278190080);
                    }
                },
                BlanchedAlmond: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294962125);
                    }
                },
                Blue: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4278190335);
                    }
                },
                BlueViolet: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4287245282);
                    }
                },
                Brown: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4289014314);
                    }
                },
                BurlyWood: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4292786311);
                    }
                },
                CadetBlue: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4284456608);
                    }
                },
                Chartreuse: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4286578432);
                    }
                },
                Chocolate: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4291979550);
                    }
                },
                Coral: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294934352);
                    }
                },
                CornflowerBlue: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4284782061);
                    }
                },
                Cornsilk: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294965468);
                    }
                },
                Crimson: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4292613180);
                    }
                },
                Cyan: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4278255615);
                    }
                },
                DarkBlue: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4278190219);
                    }
                },
                DarkCyan: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4278225803);
                    }
                },
                DarkGoldenrod: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4290283019);
                    }
                },
                DarkGray: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4289309097);
                    }
                },
                DarkGreen: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4278215680);
                    }
                },
                DarkKhaki: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4290623339);
                    }
                },
                DarkMagenta: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4287299723);
                    }
                },
                DarkOliveGreen: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4283788079);
                    }
                },
                DarkOrange: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294937600);
                    }
                },
                DarkOrchid: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4288230092);
                    }
                },
                DarkRed: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4287299584);
                    }
                },
                DarkSalmon: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4293498490);
                    }
                },
                DarkSeaGreen: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4287609999);
                    }
                },
                DarkSlateBlue: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4282924427);
                    }
                },
                DarkSlateGray: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4281290575);
                    }
                },
                DarkTurquoise: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4278243025);
                    }
                },
                DarkViolet: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4287889619);
                    }
                },
                DeepPink: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294907027);
                    }
                },
                DeepSkyBlue: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4278239231);
                    }
                },
                DimGray: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4285098345);
                    }
                },
                DodgerBlue: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4280193279);
                    }
                },
                Firebrick: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4289864226);
                    }
                },
                FloralWhite: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294966000);
                    }
                },
                ForestGreen: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4280453922);
                    }
                },
                Fuchsia: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294902015);
                    }
                },
                Gainsboro: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4292664540);
                    }
                },
                GhostWhite: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294506751);
                    }
                },
                Gold: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294956800);
                    }
                },
                Goldenrod: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4292519200);
                    }
                },
                Gray: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4286611584);
                    }
                },
                Green: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4278222848);
                    }
                },
                GreenYellow: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4289593135);
                    }
                },
                Honeydew: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4293984240);
                    }
                },
                HotPink: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294928820);
                    }
                },
                IndianRed: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4291648604);
                    }
                },
                Indigo: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4283105410);
                    }
                },
                Ivory: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294967280);
                    }
                },
                Khaki: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4293977740);
                    }
                },
                Lavender: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4293322490);
                    }
                },
                LavenderBlush: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294963445);
                    }
                },
                LawnGreen: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4286381056);
                    }
                },
                LemonChiffon: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294965965);
                    }
                },
                LightBlue: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4289583334);
                    }
                },
                LightCoral: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4293951616);
                    }
                },
                LightCyan: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4292935679);
                    }
                },
                LightGoldenrodYellow: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294638290);
                    }
                },
                LightGray: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4292072403);
                    }
                },
                LightGreen: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4287688336);
                    }
                },
                LightPink: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294948545);
                    }
                },
                LightSalmon: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294942842);
                    }
                },
                LightSeaGreen: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4280332970);
                    }
                },
                LightSkyBlue: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4287090426);
                    }
                },
                LightSlateGray: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4286023833);
                    }
                },
                LightSteelBlue: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4289774814);
                    }
                },
                LightYellow: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294967264);
                    }
                },
                Lime: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4278255360);
                    }
                },
                LimeGreen: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4281519410);
                    }
                },
                Linen: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294635750);
                    }
                },
                Magenta: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294902015);
                    }
                },
                Maroon: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4286578688);
                    }
                },
                MediumAquamarine: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4284927402);
                    }
                },
                MediumBlue: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4278190285);
                    }
                },
                MediumOrchid: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4290401747);
                    }
                },
                MediumPurple: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4287852763);
                    }
                },
                MediumSeaGreen: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4282168177);
                    }
                },
                MediumSlateBlue: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4286277870);
                    }
                },
                MediumSpringGreen: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4278254234);
                    }
                },
                MediumTurquoise: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4282962380);
                    }
                },
                MediumVioletRed: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4291237253);
                    }
                },
                MidnightBlue: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4279834992);
                    }
                },
                MintCream: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294311930);
                    }
                },
                MistyRose: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294960353);
                    }
                },
                Moccasin: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294960309);
                    }
                },
                NavajoWhite: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294958765);
                    }
                },
                Navy: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4278190208);
                    }
                },
                OldLace: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294833638);
                    }
                },
                Olive: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4286611456);
                    }
                },
                OliveDrab: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4285238819);
                    }
                },
                Orange: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294944000);
                    }
                },
                OrangeRed: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294919424);
                    }
                },
                Orchid: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4292505814);
                    }
                },
                PaleGoldenrod: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4293847210);
                    }
                },
                PaleGreen: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4288215960);
                    }
                },
                PaleTurquoise: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4289720046);
                    }
                },
                PaleVioletRed: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4292571283);
                    }
                },
                PapayaWhip: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294963157);
                    }
                },
                PeachPuff: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294957753);
                    }
                },
                Peru: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4291659071);
                    }
                },
                Pink: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294951115);
                    }
                },
                Plum: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4292714717);
                    }
                },
                PowderBlue: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4289781990);
                    }
                },
                Purple: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4286578816);
                    }
                },
                Red: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294901760);
                    }
                },
                RosyBrown: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4290547599);
                    }
                },
                RoyalBlue: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4282477025);
                    }
                },
                SaddleBrown: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4287317267);
                    }
                },
                Salmon: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294606962);
                    }
                },
                SandyBrown: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294222944);
                    }
                },
                SeaGreen: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4281240407);
                    }
                },
                SeaShell: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294964718);
                    }
                },
                Sienna: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4288696877);
                    }
                },
                Silver: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4290822336);
                    }
                },
                SkyBlue: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4287090411);
                    }
                },
                SlateBlue: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4285160141);
                    }
                },
                SlateGray: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4285563024);
                    }
                },
                Snow: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294966010);
                    }
                },
                SpringGreen: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4278255487);
                    }
                },
                SteelBlue: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4282811060);
                    }
                },
                Tan: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4291998860);
                    }
                },
                Teal: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4278222976);
                    }
                },
                Thistle: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4292394968);
                    }
                },
                Tomato: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294927175);
                    }
                },
                Transparent: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(16777215);
                    }
                },
                Turquoise: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4282441936);
                    }
                },
                Violet: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4293821166);
                    }
                },
                Wheat: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294303411);
                    }
                },
                White: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294967295);
                    }
                },
                WhiteSmoke: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294309365);
                    }
                },
                Yellow: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4294967040);
                    }
                },
                YellowGreen: {
                    get: function () {
                        return System.Windows.Media.Color.FromUInt32(4288335154);
                    }
                }
            }
        }
    });

    Bridge.define("System.Windows.Media.ContainerRenderElementExtensions", {
        statics: {
            methods: {
                SetChildren: function (container, children) {
                    var $t, $t1;
                    if (System.Linq.Enumerable.from(container.System$Windows$Media$IContainerRenderElement$Children).sequenceEqual(children)) {
                        return;
                    }

                    $t = Bridge.getEnumerator(System.Linq.Enumerable.from(container.System$Windows$Media$IContainerRenderElement$Children).toArray());
                    try {
                        while ($t.moveNext()) {
                            var child = $t.Current;
                            container.System$Windows$Media$IContainerRenderElement$RemoveChild(child);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$dispose();
                        }
                    }
                    var index = 0;
                    $t1 = Bridge.getEnumerator(children, System.Object);
                    try {
                        while ($t1.moveNext()) {
                            var child1 = $t1.Current;
                            container.System$Windows$Media$IContainerRenderElement$InsertChild(index, child1);
                            index = (index + 1) | 0;
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$dispose();
                        }
                    }}
            }
        }
    });

    Bridge.define("System.Windows.Media.DashStyles", {
        statics: {
            fields: {
                solid: null,
                dash: null,
                dashDot: null,
                dashDotDot: null,
                dot: null
            },
            props: {
                Solid: {
                    get: function () {
                        if (System.Windows.Media.DashStyles.solid == null) {
                            System.Windows.Media.DashStyles.solid = new System.Windows.Media.DashStyle.ctor();
                            System.Windows.Media.DashStyles.solid.Freeze();
                        }

                        return System.Windows.Media.DashStyles.solid;
                    }
                },
                Dash: {
                    get: function () {
                        if (System.Windows.Media.DashStyles.dash == null) {
                            System.Windows.Media.DashStyles.dash = new System.Windows.Media.DashStyle.$ctor1(System.Array.init([2, 2], System.Double), 1);
                            System.Windows.Media.DashStyles.dash.Freeze();
                        }

                        return System.Windows.Media.DashStyles.dash;
                    }
                },
                DashDot: {
                    get: function () {
                        if (System.Windows.Media.DashStyles.dashDot == null) {
                            System.Windows.Media.DashStyles.dashDot = new System.Windows.Media.DashStyle.$ctor1(System.Array.init([2, 2, 0, 2], System.Double), 1);
                            System.Windows.Media.DashStyles.dashDot.Freeze();
                        }

                        return System.Windows.Media.DashStyles.dashDot;
                    }
                },
                DashDotDot: {
                    get: function () {
                        if (System.Windows.Media.DashStyles.dashDotDot == null) {
                            System.Windows.Media.DashStyles.dashDotDot = new System.Windows.Media.DashStyle.$ctor1(System.Array.init([2, 2, 0, 2, 0, 2], System.Double), 1);
                            System.Windows.Media.DashStyles.dashDotDot.Freeze();
                        }

                        return System.Windows.Media.DashStyles.dashDotDot;
                    }
                },
                Dot: {
                    get: function () {
                        if (System.Windows.Media.DashStyles.dot == null) {
                            System.Windows.Media.DashStyles.dot = new System.Windows.Media.DashStyle.$ctor1(System.Array.init([0, 2], System.Double), 0);
                            System.Windows.Media.DashStyles.dot.Freeze();
                        }

                        return System.Windows.Media.DashStyles.dot;
                    }
                }
            }
        }
    });

    Bridge.define("System.Windows.Media.DrawingContext");

    Bridge.define("System.Windows.Media.FontFamily", {
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Media.FontFamily.$ctor1("");
                }
            },
            methods: {
                Parse: function (value) {
                    return new System.Windows.Media.FontFamily.ctor(System.Linq.Enumerable.from(System.String.split(value, [44].map(function(i) {{ return String.fromCharCode(i); }}))).select($asm.$.System.Windows.Media.FontFamily.f1).toArray(System.String));
                }
            }
        },
        props: {
            FamilyName: {
                get: function () {
                    return System.Linq.Enumerable.from(this.FamilyNames).firstOrDefault(null, null);
                }
            },
            FamilyNames: null
        },
        ctors: {
            $ctor1: function (familyName) {
                this.$initialize();
                this.FamilyNames = System.Array.init([familyName], System.String);
            },
            ctor: function (familyNames) {
                this.$initialize();
                this.FamilyNames = familyNames;
            }
        }
    });

    Bridge.ns("System.Windows.Media.FontFamily", $asm.$);

    Bridge.apply($asm.$.System.Windows.Media.FontFamily, {
        f1: function (s) {
            return s.trim();
        }
    });

    Bridge.define("System.Windows.Media.FormattedText", {
        props: {
            Text: null,
            Typeface: null,
            Size: 0,
            Foreground: null,
            FlowDirection: 0,
            LineHeight: 0,
            MaxLineCount: 0,
            MaxTextHeight: 0,
            MaxTextWidth: 0,
            TextAlignment: 0,
            Trimming: 0
        },
        ctors: {
            ctor: function (textToFormat, culture, flowDirection, typeface, size, foreground) {
                this.$initialize();
                this.Text = textToFormat;
                this.Typeface = typeface;
                this.Size = size;
                this.Foreground = foreground;
                this.FlowDirection = flowDirection;
                this.LineHeight = Number.NaN;
                this.MaxLineCount = 2147483647;
                this.MaxTextWidth = Number.POSITIVE_INFINITY;
                this.MaxTextHeight = Number.POSITIVE_INFINITY;
            }
        }
    });

    Bridge.define("System.Windows.Media.GradientSpreadMethod", {
        $kind: "enum",
        statics: {
            fields: {
                Pad: 0,
                Reflect: 1,
                Repeat: 2
            }
        }
    });

    Bridge.define("System.Windows.Media.IBorderRenderElement", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Media.IBrushRenderResource", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Media.IContainerRenderElement", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Media.IDrawingShapeRenderElement", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Media.IDrawingImageRenderElement", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Media.IDrawingTextRenderElement", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Media.IGeometryRenderResource", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Media.IImageRenderElement", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Media.IImageSourceRenderResource", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Media.IRenderElementFactory", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Media.ITextBlockRenderElement", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Media.ITextBoxRenderElement", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Media.ITransformRenderResource", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Media.Matrix", {
        statics: {
            fields: {
                Identity: null
            },
            ctors: {
                init: function () {
                    this.Identity = new System.Windows.Media.Matrix(1, 0, 0, 1, 0, 0);
                }
            },
            methods: {
                RotationMatrix: function (radians, centerX, centerY) {
                    if (centerX === void 0) { centerX = 0.0; }
                    if (centerY === void 0) { centerY = 0.0; }
                    var sin = Math.sin(radians);
                    var cos = Math.cos(radians);
                    var offsetX = (centerX * (1.0 - cos)) + (centerY * sin);
                    var offsetY = (centerY * (1.0 - cos)) - (centerX * sin);

                    return new System.Windows.Media.Matrix(cos, sin, -sin, cos, offsetX, offsetY);
                },
                ScalingMatrix: function (scaleX, scaleY, centerX, centerY) {
                    if (centerX === void 0) { centerX = 0.0; }
                    if (centerY === void 0) { centerY = 0.0; }
                    var offsetX = centerX - scaleX * centerX;
                    var offsetY = centerY - scaleY * centerY;

                    return new System.Windows.Media.Matrix(scaleX, 0, 0, scaleY, offsetX, offsetY);
                },
                SkewMatrix: function (radiansX, radiansY, centerX, centerY) {
                    if (centerX === void 0) { centerX = 0.0; }
                    if (centerY === void 0) { centerY = 0.0; }
                    var offsetX = -centerY * Math.tan(radiansX);
                    var offsetY = -centerX * Math.tan(radiansY);

                    return new System.Windows.Media.Matrix(1, Math.tan(radiansY), Math.tan(radiansX), 1, offsetX, offsetY);
                },
                TranslationMatrix: function (offsetX, offsetY) {
                    return new System.Windows.Media.Matrix(1, 0, 0, 1, offsetX, offsetY);
                },
                Parse: function (value) {
                    var values = System.Linq.Enumerable.from(System.String.split(value, [44].map(function(i) {{ return String.fromCharCode(i); }}))).select($asm.$.System.Windows.Media.Matrix.f1).toArray(System.Double);

                    if (values.length === 6) {
                        return new System.Windows.Media.Matrix(values[System.Array.index(0, values)], values[System.Array.index(1, values)], values[System.Array.index(2, values)], values[System.Array.index(3, values)], values[System.Array.index(4, values)], values[System.Array.index(5, values)]);
                    }

                    throw new Granular.Exception("Can't parse Matrix value \"{0}\"", [value]);
                },
                op_Equality: function (matrix1, matrix2) {
                    return Bridge.equals(matrix1, matrix2);
                },
                op_Inequality: function (matrix1, matrix2) {
                    return !(System.Windows.Media.Matrix.op_Equality(matrix1, matrix2));
                },
                op_Multiply: function (matrix1, matrix2) {
                    if (matrix1.IsIdentity) {
                        return matrix2;
                    }

                    if (matrix2.IsIdentity) {
                        return matrix1;
                    }

                    var m11 = matrix1.M11 * matrix2.M11 + matrix1.M12 * matrix2.M21;
                    var m12 = matrix1.M11 * matrix2.M12 + matrix1.M12 * matrix2.M22;
                    var m21 = matrix1.M21 * matrix2.M11 + matrix1.M22 * matrix2.M21;
                    var m22 = matrix1.M21 * matrix2.M12 + matrix1.M22 * matrix2.M22;
                    var offsetX = matrix1.OffsetX * matrix2.M11 + matrix1.OffsetY * matrix2.M21 + matrix2.OffsetX;
                    var offsetY = matrix1.OffsetX * matrix2.M12 + matrix1.OffsetY * matrix2.M22 + matrix2.OffsetY;

                    return new System.Windows.Media.Matrix(m11, m12, m21, m22, offsetX, offsetY);
                },
                op_Multiply$1: function (point, matrix) {
                    if (matrix.IsIdentity) {
                        return point;
                    }

                    var x = point.X * matrix.M11 + point.Y * matrix.M21 + matrix.OffsetX;
                    var y = point.X * matrix.M12 + point.Y * matrix.M22 + matrix.OffsetY;

                    return new System.Windows.Point.$ctor1(x, y);
                }
            }
        },
        fields: {
            inverse: null
        },
        props: {
            M11: 0,
            M12: 0,
            M21: 0,
            M22: 0,
            OffsetX: 0,
            OffsetY: 0,
            IsIdentity: {
                get: function () {
                    return Bridge.referenceEquals(this, System.Windows.Media.Matrix.Identity) || this.M11 === 1 && this.M12 === 0 && this.M21 === 0 && this.M22 === 1 && this.OffsetX === 0 && this.OffsetY === 0;
                }
            },
            IsTranslation: {
                get: function () {
                    return this.M11 === 1 && this.M12 === 0 && this.M21 === 0 && this.M22 === 1;
                }
            },
            IsScaling: {
                get: function () {
                    return this.M12 === 0 && this.M21 === 0 && this.OffsetX === 0 && this.OffsetY === 0;
                }
            },
            Inverse: {
                get: function () {
                    if (System.Windows.Media.Matrix.op_Equality(this.inverse, null)) {
                        this.inverse = this.GetInverseMatrix();
                    }

                    return this.inverse;
                }
            }
        },
        ctors: {
            ctor: function (m11, m12, m21, m22, offsetX, offsetY) {
                this.$initialize();
                this.M11 = m11;
                this.M12 = m12;
                this.M21 = m21;
                this.M22 = m22;
                this.OffsetX = offsetX;
                this.OffsetY = offsetY;
            }
        },
        methods: {
            toString: function () {
                if (this.IsIdentity) {
                    return "IdentityMatrix";
                }

                if (this.IsTranslation) {
                    return System.String.format("TranslationMatrix({0}, {1})", Bridge.box(Bridge.Math.round(this.OffsetX, 2, 6), System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(Bridge.Math.round(this.OffsetY, 2, 6), System.Double, System.Double.format, System.Double.getHashCode));
                }

                if (this.IsScaling) {
                    return System.String.format("ScalingMatrix({0}, {1})", Bridge.box(Bridge.Math.round(this.M11, 2, 6), System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(Bridge.Math.round(this.M22, 2, 6), System.Double, System.Double.format, System.Double.getHashCode));
                }

                return System.String.format("Matrix({0}, {1}, {2}, {3}, {4}, {5})", Bridge.box(Bridge.Math.round(this.M11, 2, 6), System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(Bridge.Math.round(this.M12, 2, 6), System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(Bridge.Math.round(this.M21, 2, 6), System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(Bridge.Math.round(this.M22, 2, 6), System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(Bridge.Math.round(this.OffsetX, 2, 6), System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(Bridge.Math.round(this.OffsetY, 2, 6), System.Double, System.Double.format, System.Double.getHashCode));
            },
            equals: function (obj) {
                var other = Bridge.as(obj, System.Windows.Media.Matrix);

                return Bridge.referenceEquals(this, other) || !Bridge.referenceEquals(other, null) && Granular.Compatibility.EqualityComparer.Double.equals2(this.M11, other.M11) && Granular.Compatibility.EqualityComparer.Double.equals2(this.M12, other.M12) && Granular.Compatibility.EqualityComparer.Double.equals2(this.M21, other.M21) && Granular.Compatibility.EqualityComparer.Double.equals2(this.M22, other.M22) && Granular.Compatibility.EqualityComparer.Double.equals2(this.OffsetX, other.OffsetX) && Granular.Compatibility.EqualityComparer.Double.equals2(this.OffsetY, other.OffsetY);
            },
            getHashCode: function () {
                return System.Double.getHashCode(this.M11) ^ System.Double.getHashCode(this.M12) ^ System.Double.getHashCode(this.M21) ^ System.Double.getHashCode(this.M22) ^ System.Double.getHashCode(this.OffsetX) ^ System.Double.getHashCode(this.OffsetY);
            },
            IsClose: function (matrix) {
                return Granular.Extensions.DoubleExtensions.IsClose(this.M11, matrix.M11) && Granular.Extensions.DoubleExtensions.IsClose(this.M12, matrix.M12) && Granular.Extensions.DoubleExtensions.IsClose(this.M21, matrix.M21) && Granular.Extensions.DoubleExtensions.IsClose(this.M22, matrix.M22) && Granular.Extensions.DoubleExtensions.IsClose(this.OffsetX, matrix.OffsetX) && Granular.Extensions.DoubleExtensions.IsClose(this.OffsetY, matrix.OffsetY);
            },
            GetInverseMatrix: function () {
                var determinant = this.M11 * this.M22 - this.M12 * this.M21;
                return new System.Windows.Media.Matrix(this.M22 / determinant, -this.M12 / determinant, -this.M21 / determinant, this.M11 / determinant, (this.M21 * this.OffsetY - this.M22 * this.OffsetX) / determinant, -(this.M11 * this.OffsetY - this.M12 * this.OffsetX) / determinant);
            }
        }
    });

    Bridge.ns("System.Windows.Media.Matrix", $asm.$);

    Bridge.apply($asm.$.System.Windows.Media.Matrix, {
        f1: function (v) {
            return System.Double.parse(v);
        }
    });

    Bridge.define("System.Windows.Media.MatrixExtensions", {
        statics: {
            methods: {
                IsNullOrIdentity: function (matrix) {
                    return Bridge.referenceEquals(matrix, null) || matrix.IsIdentity;
                },
                GetContainingRect: function (matrix, rect) {
                    var vertices = System.Linq.Enumerable.from(System.Windows.RectExtensions.GetCorners(rect)).select(function (corner) {
                            return System.Windows.Media.Matrix.op_Multiply$1(corner, matrix);
                        }).toArray(System.Windows.Point);

                    var left = System.Linq.Enumerable.from(vertices).select($asm.$.System.Windows.Media.MatrixExtensions.f1).min();
                    var right = System.Linq.Enumerable.from(vertices).select($asm.$.System.Windows.Media.MatrixExtensions.f1).max();
                    var top = System.Linq.Enumerable.from(vertices).select($asm.$.System.Windows.Media.MatrixExtensions.f2).min();
                    var bottom = System.Linq.Enumerable.from(vertices).select($asm.$.System.Windows.Media.MatrixExtensions.f2).max();

                    return new System.Windows.Rect.$ctor1(left, top, right - left, bottom - top);
                },
                GetApproximatedRect$1: function (matrix, size) {
                    return System.Windows.Media.MatrixExtensions.GetApproximatedRect(matrix, new System.Windows.Rect.$ctor3(size));
                },
                GetApproximatedRect: function (matrix, rect) {
                    var vertices = System.Linq.Enumerable.from(System.Windows.RectExtensions.GetCorners(rect)).select(function (corner) {
                            return System.Windows.Media.Matrix.op_Multiply$1(corner, matrix);
                        }).toArray(System.Windows.Point);

                    var verticesX = System.Linq.Enumerable.from(vertices).select($asm.$.System.Windows.Media.MatrixExtensions.f1).orderBy($asm.$.System.Windows.Media.MatrixExtensions.f3).toArray(System.Double);
                    var verticesY = System.Linq.Enumerable.from(vertices).select($asm.$.System.Windows.Media.MatrixExtensions.f2).orderBy($asm.$.System.Windows.Media.MatrixExtensions.f4).toArray(System.Double);

                    var left = (verticesX[System.Array.index(0, verticesX)] + verticesX[System.Array.index(1, verticesX)]) / 2;
                    var right = (verticesX[System.Array.index(2, verticesX)] + verticesX[System.Array.index(3, verticesX)]) / 2;
                    var top = (verticesY[System.Array.index(0, verticesY)] + verticesY[System.Array.index(1, verticesY)]) / 2;
                    var bottom = (verticesY[System.Array.index(2, verticesY)] + verticesY[System.Array.index(3, verticesY)]) / 2;

                    return new System.Windows.Rect.$ctor1(left, top, right - left, bottom - top);
                },
                GetContainingSize: function (matrix, size) {
                    return System.Windows.Media.MatrixExtensions.GetContainingRect(matrix, new System.Windows.Rect.$ctor3(size)).Size;
                },
                GetContainedSize: function (matrix, containerSize) {
                    var w = containerSize.Width;
                    var h = containerSize.Height;

                    // Each width unit of the contained size, will add "a" units to the transformed width and "b" units to the transformed height
                    var transformedWidth = System.Windows.PointExtensions.Abs((System.Windows.Media.Matrix.op_Multiply$1(new System.Windows.Point.$ctor1(1, 0), matrix)));
                    var a = transformedWidth.X;
                    var b = transformedWidth.Y;

                    // Each height unit of the contained size, will add "c" units to the transformed width and "d" units to the transformed height
                    var transformedHeight = System.Windows.PointExtensions.Abs((System.Windows.Media.Matrix.op_Multiply$1(new System.Windows.Point.$ctor1(0, 1), matrix)));
                    var c = transformedHeight.X;
                    var d = transformedHeight.Y;

                    if (a === 0 && c === 0 || b === 0 && d === 0) {
                        return System.Windows.Size.Zero;
                    }

                    // Find a contained size (x, y) with maximum area (x * y) where
                    //      w >= a * x + c * y
                    //      h >= b * x + d * y
                    //
                    // The solution is on one of these constrains egeds (where the area derivative is zero) or in the intersection
                    //
                    // The area on the first constrain edge is:
                    //      area1(x) = x * (w - a * x) / c
                    //
                    // The maximum is at:
                    //      area1'(x) = (w - 2 * a * x) / c = 0
                    //      x = w / (2 * a)
                    //      y = Min((w - a * x) / c, (h - b * x) / d)

                    var determinant = a * d - b * c;

                    // Intersection size
                    var size0 = determinant !== 0 ? new System.Windows.Size(Granular.Extensions.DoubleExtensions.Max(((w * d - h * c) / determinant), 0), Granular.Extensions.DoubleExtensions.Max(((h * a - w * b) / determinant), 0)) : new System.Windows.Size(0, 0);

                    var GetConstrainedX = function (y) {
                        return Math.min(Granular.Extensions.DoubleExtensions.IsClose(a, 0) ? 0 : (w - c * y) / a, Granular.Extensions.DoubleExtensions.IsClose(b, 0) ? 0 : (h - d * y) / b);
                    };
                    var GetConstrainedY = function (x) {
                        return Math.min(Granular.Extensions.DoubleExtensions.IsClose(c, 0) ? 0 : (w - a * x) / c, Granular.Extensions.DoubleExtensions.IsClose(d, 0) ? 0 : (h - b * x) / d);
                    };

                    // Maximum size on the first constrain edge
                    var size1 = a > c ? new System.Windows.Size(w / (2 * a), Granular.Extensions.DoubleExtensions.Max(GetConstrainedY(w / (2 * a)), 0)) : new System.Windows.Size(Granular.Extensions.DoubleExtensions.Max(GetConstrainedX(w / (2 * c)), 0), w / (2 * c));

                    // Maximum size on the second constrain edge
                    var size2 = b > d ? new System.Windows.Size(h / (2 * b), Granular.Extensions.DoubleExtensions.Max(GetConstrainedY(h / (2 * b)), 0)) : new System.Windows.Size(Granular.Extensions.DoubleExtensions.Max(GetConstrainedX(h / (2 * d)), 0), h / (2 * d));

                    return System.Windows.SizeExtensions.MaxArea(System.Windows.SizeExtensions.MaxArea(size0, size1), size2);
                }
            }
        }
    });

    Bridge.ns("System.Windows.Media.MatrixExtensions", $asm.$);

    Bridge.apply($asm.$.System.Windows.Media.MatrixExtensions, {
        f1: function (vertex) {
            return vertex.X;
        },
        f2: function (vertex) {
            return vertex.Y;
        },
        f3: function (x) {
            return x;
        },
        f4: function (y) {
            return y;
        }
    });

    Bridge.define("System.Windows.Media.PenLineCap", {
        $kind: "enum",
        statics: {
            fields: {
                Flat: 0,
                Square: 1,
                Round: 2,
                Triangle: 3
            }
        }
    });

    Bridge.define("System.Windows.Media.PenLineJoin", {
        $kind: "enum",
        statics: {
            fields: {
                Miter: 0,
                Bevel: 1,
                Round: 2
            }
        }
    });

    Bridge.define("System.Windows.Media.RenderGradientStop", {
        props: {
            Color: null,
            Offset: 0
        },
        ctors: {
            ctor: function (color, offset) {
                this.$initialize();
                this.Color = color;
                this.Offset = offset;
            }
        }
    });

    Bridge.define("System.Windows.Media.RenderImageState", {
        $kind: "enum",
        statics: {
            fields: {
                Idle: 0,
                DownloadProgress: 1,
                DownloadCompleted: 2,
                DownloadFailed: 3
            }
        }
    });

    Bridge.define("System.Windows.Media.Stretch", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                Fill: 1,
                Uniform: 2,
                UniformToFill: 3
            }
        }
    });

    Bridge.define("System.Windows.Media.TileMode", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                Tile: 1
            }
        }
    });

    Bridge.define("System.Windows.Media.TransformExtensions", {
        statics: {
            methods: {
                IsNullOrIdentity: function (transform) {
                    return Bridge.referenceEquals(transform, null) || Bridge.referenceEquals(transform, System.Windows.Media.Transform.Identity);
                }
            }
        }
    });

    Bridge.define("System.Windows.Media.Typeface", {
        props: {
            FontFamily: null,
            Stretch: 0,
            Style: 0,
            Weight: 0
        },
        ctors: {
            ctor: function (typefaceName, style, weight, stretch) {
                if (style === void 0) { style = 0; }
                if (weight === void 0) { weight = 0; }
                if (stretch === void 0) { stretch = 0; }

                System.Windows.Media.Typeface.$ctor1.call(this, new System.Windows.Media.FontFamily.$ctor1(typefaceName), style, weight, stretch);
                //
            },
            $ctor1: function (fontFamily, style, weight, stretch) {
                if (style === void 0) { style = 0; }
                if (weight === void 0) { weight = 0; }
                if (stretch === void 0) { stretch = 0; }

                this.$initialize();
                this.FontFamily = fontFamily;
                this.Style = style;
                this.Weight = weight;
                this.Stretch = stretch;
            }
        }
    });

    Bridge.define("System.Windows.Media.VisualExtensions", {
        statics: {
            methods: {
                IsAncestorOf: function (visual, descendant) {
                    while (descendant != null) {
                        if (Bridge.referenceEquals(descendant.VisualParent, visual)) {
                            return true;
                        }

                        descendant = descendant.VisualParent;
                    }

                    return false;
                },
                GetVisualPath: function (visual, ancestor) {
                    return new (Bridge.GeneratorEnumerable$1(System.Windows.Media.Visual))(Bridge.fn.bind(this, function (visual, ancestor) {
                        var $step = 0,
                            $jumpFromFinally,
                            $returnValue,
                            currentVisual,
                            $async_e;

                        var $enumerator = new (Bridge.GeneratorEnumerator$1(System.Windows.Media.Visual))(Bridge.fn.bind(this, function () {
                            try {
                                for (;;) {
                                    switch ($step) {
                                        case 0: {
                                            currentVisual = visual;
                                            $step = 1;
                                            continue;
                                        }
                                        case 1: {
                                            if ( !Bridge.referenceEquals(currentVisual, ancestor) ) {
                                                    $step = 2;
                                                    continue;
                                                } 
                                                $step = 4;
                                                continue;
                                        }
                                        case 2: {
                                            if (currentVisual == null) {
                                                    throw new Granular.Exception("Visual \"{0}\" is not an ancestor of \"{1}\"", [ancestor, visual]);
                                                }

                                                $enumerator.current = currentVisual;
                                                $step = 3;
                                                return true;
                                        }
                                        case 3: {
                                            currentVisual = currentVisual.VisualParent;

                                                $step = 1;
                                                continue;
                                        }
                                        case 4: {

                                        }
                                        default: {
                                            return false;
                                        }
                                    }
                                }
                            } catch($async_e1) {
                                $async_e = System.Exception.create($async_e1);
                                throw $async_e;
                            }
                        }));
                        return $enumerator;
                    }, arguments));
                }
            }
        }
    });

    Bridge.define("System.Windows.Media.VisualWeakReference", {
        inherits: [System.IDisposable],
        fields: {
            ancestor: null
        },
        props: {
            Visual: null
        },
        alias: ["dispose", "System$IDisposable$dispose"],
        ctors: {
            ctor: function (visual, ancestor) {
                this.$initialize();
                this.Visual = visual;
                this.ancestor = ancestor;

                visual.addVisualAncestorChanged(Bridge.fn.cacheBind(this, this.OnVisualAncestorChanged));
            }
        },
        methods: {
            dispose: function () {
                if (this.Visual != null) {
                    this.Visual.removeVisualAncestorChanged(Bridge.fn.cacheBind(this, this.OnVisualAncestorChanged));
                    this.Visual = null;
                }
            },
            OnVisualAncestorChanged: function (sender, e) {
                if (!System.Windows.Media.VisualExtensions.IsAncestorOf(this.ancestor, this.Visual)) {
                    this.dispose();
                }
            }
        }
    });

    Bridge.define("System.Windows.Point", {
        statics: {
            fields: {
                Empty: null,
                Zero: null
            },
            ctors: {
                init: function () {
                    this.Empty = new System.Windows.Point.ctor();
                    this.Zero = new System.Windows.Point.$ctor1(0, 0);
                }
            },
            methods: {
                Parse: function (value) {
                    var values = System.Linq.Enumerable.from(System.String.split(value, [44].map(function(i) {{ return String.fromCharCode(i); }}))).select($asm.$.System.Windows.Point.f1).toArray(System.Double);

                    if (values.length === 2) {
                        return new System.Windows.Point.$ctor1(values[System.Array.index(0, values)], values[System.Array.index(1, values)]);
                    }

                    throw new Granular.Exception("Can't parse Point value \"{0}\"", [value]);
                },
                IsNullOrEmpty: function (point) {
                    return Bridge.referenceEquals(point, null) || point.IsEmpty;
                },
                op_Equality: function (point1, point2) {
                    return Bridge.equals(point1, point2);
                },
                op_Inequality: function (point1, point2) {
                    return !(System.Windows.Point.op_Equality(point1, point2));
                },
                op_UnaryNegation: function (point) {
                    if (System.Windows.Point.op_Equality(point, System.Windows.Point.Zero)) {
                        return point;
                    }

                    return new System.Windows.Point.$ctor1(-point.X, -point.Y);
                },
                op_Addition: function (point1, point2) {
                    if (System.Windows.Point.op_Equality(point1, System.Windows.Point.Zero)) {
                        return point2;
                    }

                    if (System.Windows.Point.op_Equality(point2, System.Windows.Point.Zero)) {
                        return point1;
                    }

                    return new System.Windows.Point.$ctor1(point1.X + point2.X, point1.Y + point2.Y);
                },
                op_Subtraction: function (point1, point2) {
                    if (System.Windows.Point.op_Equality(point1, System.Windows.Point.Zero)) {
                        return System.Windows.Point.op_UnaryNegation(point2);
                    }

                    if (System.Windows.Point.op_Equality(point2, System.Windows.Point.Zero)) {
                        return point1;
                    }

                    return new System.Windows.Point.$ctor1(point1.X - point2.X, point1.Y - point2.Y);
                },
                op_Multiply$1: function (point, scalar) {
                    if (scalar === 1 || Bridge.referenceEquals(point, System.Windows.Point.Zero)) {
                        return point;
                    }

                    return new System.Windows.Point.$ctor1(point.X * scalar, point.Y * scalar);
                },
                op_Multiply: function (scalar, point) {
                    return System.Windows.Point.op_Multiply$1(point, scalar);
                },
                op_Multiply$2: function (point, size) {
                    return new System.Windows.Point.$ctor1(point.X * size.Width, point.Y * size.Height);
                },
                op_Multiply$3: function (size, point) {
                    return System.Windows.Point.op_Multiply$2(point, size);
                },
                op_Division: function (point, scalar) {
                    return new System.Windows.Point.$ctor1(point.X / scalar, point.Y / scalar);
                },
                op_Explicit: function (size) {
                    return new System.Windows.Point.$ctor1(size.Width, size.Height);
                }
            }
        },
        props: {
            X: 0,
            Y: 0,
            IsEmpty: false
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                this.X = Number.NaN;
                this.Y = Number.NaN;
                this.IsEmpty = true;
            },
            $ctor1: function (x, y) {
                this.$initialize();
                if (Granular.Extensions.DoubleExtensions.IsNaN(x) || Granular.Extensions.DoubleExtensions.IsNaN(y)) {
                    throw new Granular.Exception("Can't create point with NaN values");
                }

                this.X = x;
                this.Y = y;
                this.IsEmpty = false;
            }
        },
        methods: {
            toString: function () {
                return System.String.format("Point({0}, {1})", Bridge.box(Bridge.Math.round(this.X, 2, 6), System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(Bridge.Math.round(this.Y, 2, 6), System.Double, System.Double.format, System.Double.getHashCode));
            },
            equals: function (obj) {
                var other = Bridge.as(obj, System.Windows.Point);

                return Bridge.referenceEquals(this, other) || !Bridge.referenceEquals(other, null) && Granular.Compatibility.EqualityComparer.Double.equals2(this.X, other.X) && Granular.Compatibility.EqualityComparer.Double.equals2(this.Y, other.Y);
            },
            getHashCode: function () {
                return System.Double.getHashCode(this.X) ^ System.Double.getHashCode(this.Y);
            }
        }
    });

    Bridge.ns("System.Windows.Point", $asm.$);

    Bridge.apply($asm.$.System.Windows.Point, {
        f1: function (v) {
            return System.Double.parse(v);
        }
    });

    Bridge.define("System.Windows.PointExtensions", {
        statics: {
            methods: {
                IsNullOrEmpty: function (point) {
                    return System.Windows.Point.IsNullOrEmpty(point);
                },
                DefaultIfNullOrEmpty: function (point, defaultValue) {
                    if (defaultValue === void 0) { defaultValue = null; }
                    return System.Windows.Point.IsNullOrEmpty(point) ? (defaultValue || System.Windows.Point.Zero) : point;
                },
                IsClose: function ($this, point) {
                    return Granular.Extensions.DoubleExtensions.IsClose($this.X, point.X) && Granular.Extensions.DoubleExtensions.IsClose($this.Y, point.Y);
                },
                Min: function ($this, point) {
                    if ($this.IsEmpty) {
                        return point;
                    }

                    if (point.IsEmpty) {
                        return $this;
                    }

                    if ($this.X < point.X && $this.Y < point.Y) {
                        return $this;
                    }

                    if ($this.X >= point.X && $this.Y >= point.Y) {
                        return point;
                    }

                    return new System.Windows.Point.$ctor1(Math.min($this.X, point.X), Math.min($this.Y, point.Y));
                },
                Max: function ($this, point) {
                    if ($this.IsEmpty) {
                        return point;
                    }

                    if (point.IsEmpty) {
                        return $this;
                    }

                    if ($this.X > point.X && $this.Y > point.Y) {
                        return $this;
                    }

                    if ($this.X <= point.X && $this.Y <= point.Y) {
                        return point;
                    }

                    return new System.Windows.Point.$ctor1(Math.max($this.X, point.X), Math.max($this.Y, point.Y));
                },
                Bounds: function (point, minimum, maximum) {
                    if (minimum.X > maximum.X || minimum.Y > maximum.Y) {
                        throw new Granular.Exception("Invalid bounds (minimum: {0}, maximum: {1})", [minimum, maximum]);
                    }

                    return System.Windows.PointExtensions.Min(System.Windows.PointExtensions.Max(point, minimum), maximum);
                },
                GetLength: function (point) {
                    return Math.sqrt(System.Windows.PointExtensions.GetLengthSqr(point));
                },
                GetLengthSqr: function (point) {
                    return point.X * point.X + point.Y * point.Y;
                },
                Abs: function (point) {
                    return point.X >= 0 && point.Y >= 0 ? point : new System.Windows.Point.$ctor1(Granular.Extensions.DoubleExtensions.Abs(point.X), Granular.Extensions.DoubleExtensions.Abs(point.Y));
                },
                GetAngle: function (point) {
                    if (point.Y === 0) {
                        return point.X < 0 ? Math.PI : 0;
                    }

                    if (point.X === 0) {
                        return point.Y < 0 ? -1.5707963267948966 : 1.5707963267948966;
                    }

                    return Bridge.Int.sign(point.Y) * Math.acos(point.X / System.Windows.PointExtensions.GetLength(point));
                }
            }
        }
    });

    Bridge.define("System.Windows.PropertyPath", {
        statics: {
            fields: {
                Empty: null
            },
            ctors: {
                init: function () {
                    this.Empty = new System.Windows.PropertyPath(System.Array.init(0, null, System.Windows.IPropertyPathElement));
                }
            },
            methods: {
                Parse: function (value, namespaces) {
                    if (namespaces === void 0) { namespaces = null; }
                    var parser = new System.Windows.Markup.PropertyPathParser(value, namespaces || System.Windows.Markup.XamlNamespaces.Empty, null);
                    return new System.Windows.PropertyPath(parser.Parse());
                },
                FromDependencyProperty: function (dependencyProperty) {
                    return new System.Windows.PropertyPath(System.Array.init([new System.Windows.DependencyPropertyPathElement(dependencyProperty)], System.Windows.DependencyPropertyPathElement));
                }
            }
        },
        props: {
            Elements: null,
            IsEmpty: false
        },
        ctors: {
            ctor: function (elements) {
                this.$initialize();
                this.Elements = elements;
                this.IsEmpty = !Granular.Compatibility.Linq.Enumerable.Any(Bridge.global.System.Windows.IPropertyPathElement, this.Elements);
            }
        },
        methods: {
            toString: function () {
                return Granular.Compatibility.Linq.Enumerable.Aggregate(System.String, Granular.Compatibility.Linq.Enumerable.DefaultIfEmpty$1(System.String, Granular.Compatibility.Linq.Enumerable.Select(Bridge.global.System.Windows.IPropertyPathElement, System.String, this.Elements, $asm.$.System.Windows.PropertyPath.f1), ""), $asm.$.System.Windows.PropertyPath.f2);
            }
        }
    });

    Bridge.ns("System.Windows.PropertyPath", $asm.$);

    Bridge.apply($asm.$.System.Windows.PropertyPath, {
        f1: function (element) {
            return element.toString();
        },
        f2: function (s1, s2) {
            return System.String.format("{0}.{1}", s1, s2);
        }
    });

    Bridge.define("System.Windows.PropertyPathElementExtensions", {
        statics: {
            methods: {
                GetDependencyProperty: function (propertyPathElement, containingType) {
                    var dependencyProperty = { };
                    if (propertyPathElement.System$Windows$IPropertyPathElement$TryGetDependencyProperty(containingType, dependencyProperty)) {
                        return dependencyProperty.v;
                    }

                    throw new Granular.Exception("Type \"{0}\" does not contain a dependency property \"{1}\"", [Bridge.Reflection.getTypeName(containingType), propertyPathElement]);
                }
            }
        }
    });

    Bridge.define("System.Windows.PropertyPathExtensions", {
        statics: {
            methods: {
                GetBasePropertyPath: function (propertyPath) {
                    return Granular.Compatibility.Linq.Enumerable.Count(Bridge.global.System.Windows.IPropertyPathElement, propertyPath.Elements) > 1 ? new System.Windows.PropertyPath(Granular.Compatibility.Linq.Enumerable.Take(Bridge.global.System.Windows.IPropertyPathElement, propertyPath.Elements, ((Granular.Compatibility.Linq.Enumerable.Count(Bridge.global.System.Windows.IPropertyPathElement, propertyPath.Elements) - 1) | 0))) : System.Windows.PropertyPath.Empty;
                },
                Insert: function (propertyPath, index, element) {
                    var elements = Granular.Compatibility.Linq.Enumerable.ToArray(Bridge.global.System.Windows.IPropertyPathElement, Granular.Compatibility.Linq.Enumerable.Concat(Bridge.global.System.Windows.IPropertyPathElement, Granular.Compatibility.Linq.Enumerable.Concat(Bridge.global.System.Windows.IPropertyPathElement, Granular.Compatibility.Linq.Enumerable.Take(Bridge.global.System.Windows.IPropertyPathElement, propertyPath.Elements, index), System.Array.init([element], System.Windows.IPropertyPathElement)), Granular.Compatibility.Linq.Enumerable.Skip(Bridge.global.System.Windows.IPropertyPathElement, propertyPath.Elements, index)));
                    return new System.Windows.PropertyPath(elements);
                },
                TryGetValue: function (propertyPath, root, value) {
                    if (propertyPath.IsEmpty) {
                        value.v = null;
                        return false;
                    }

                    if (Granular.Compatibility.Linq.Enumerable.Count(Bridge.global.System.Windows.IPropertyPathElement, propertyPath.Elements) > 1) {
                        var baseValue = { };

                        if (!System.Windows.PropertyPathExtensions.TryGetValue(System.Windows.PropertyPathExtensions.GetBasePropertyPath(propertyPath), root, baseValue)) {
                            value.v = null;
                            return false;
                        }

                        root = baseValue.v;
                    }

                    return Granular.Compatibility.Linq.Enumerable.Last(Bridge.global.System.Windows.IPropertyPathElement, propertyPath.Elements).System$Windows$IPropertyPathElement$TryGetValue(root, value);
                }
            }
        }
    });

    Bridge.define("System.Windows.RectExtensions", {
        statics: {
            methods: {
                IsNullOrEmpty: function (rect) {
                    return Bridge.referenceEquals(rect, null) || rect.IsEmpty;
                },
                DefaultIfNullOrEmpty: function (rect, defaultValue) {
                    if (defaultValue === void 0) { defaultValue = null; }
                    return System.Windows.RectExtensions.IsNullOrEmpty(rect) ? (defaultValue || System.Windows.Rect.Zero) : rect;
                },
                IsClose: function ($this, rect) {
                    return System.Windows.PointExtensions.IsClose($this.Location, rect.Location) && System.Windows.SizeExtensions.IsClose($this.Size, rect.Size);
                },
                Contains: function (rect, point) {
                    return System.Windows.PointExtensions.IsNullOrEmpty(point) || !System.Windows.RectExtensions.IsNullOrEmpty(rect) && rect.Left <= point.X && point.X < rect.Right && rect.Top <= point.Y && point.Y < rect.Bottom;
                },
                Contains$1: function ($this, rect) {
                    return System.Windows.RectExtensions.IsNullOrEmpty(rect) || !System.Windows.RectExtensions.IsNullOrEmpty($this) && $this.Left <= rect.Left && $this.Top <= rect.Top && $this.Right >= rect.Right && $this.Bottom >= rect.Bottom;
                },
                Transform: function (rect, matrix) {
                    if (matrix.IsIdentity) {
                        return rect;
                    }

                    var topLeft = System.Windows.Media.Matrix.op_Multiply$1(System.Windows.RectExtensions.GetTopLeft(rect), matrix);
                    var topRight = System.Windows.Media.Matrix.op_Multiply$1(System.Windows.RectExtensions.GetTopRight(rect), matrix);
                    var bottomLeft = System.Windows.Media.Matrix.op_Multiply$1(System.Windows.RectExtensions.GetBottomLeft(rect), matrix);
                    var bottomRight = System.Windows.Media.Matrix.op_Multiply$1(System.Windows.RectExtensions.GetBottomRight(rect), matrix);

                    var location = new System.Windows.Point.$ctor1(Granular.Extensions.DoubleExtensions.Min(Granular.Extensions.DoubleExtensions.Min(Granular.Extensions.DoubleExtensions.Min(topLeft.X, topRight.X), bottomLeft.X), bottomRight.X), Granular.Extensions.DoubleExtensions.Min(Granular.Extensions.DoubleExtensions.Min(Granular.Extensions.DoubleExtensions.Min(topLeft.Y, topRight.Y), bottomLeft.Y), bottomRight.Y));

                    var size = new System.Windows.Size(Granular.Extensions.DoubleExtensions.Max(Granular.Extensions.DoubleExtensions.Max(Granular.Extensions.DoubleExtensions.Max(topLeft.X, topRight.X), bottomLeft.X), bottomRight.X) - location.X, Granular.Extensions.DoubleExtensions.Max(Granular.Extensions.DoubleExtensions.Max(Granular.Extensions.DoubleExtensions.Max(topLeft.Y, topRight.Y), bottomLeft.Y), bottomRight.Y) - location.Y);

                    return new System.Windows.Rect.$ctor2(location, size);
                },
                GetTopLeft: function (rect) {
                    return rect.Location;
                },
                GetTopRight: function (rect) {
                    return new System.Windows.Point.$ctor1(rect.Right, rect.Top);
                },
                GetBottomLeft: function (rect) {
                    return new System.Windows.Point.$ctor1(rect.Left, rect.Bottom);
                },
                GetBottomRight: function (rect) {
                    return new System.Windows.Point.$ctor1(rect.Right, rect.Bottom);
                },
                GetCorners: function (rect) {
                    return System.Array.init([System.Windows.RectExtensions.GetTopLeft(rect), System.Windows.RectExtensions.GetTopRight(rect), System.Windows.RectExtensions.GetBottomLeft(rect), System.Windows.RectExtensions.GetBottomRight(rect)], System.Windows.Point);
                },
                AddOffset: function (rect, offset) {
                    if (System.Windows.Point.op_Equality(offset, System.Windows.Point.Zero)) {
                        return rect;
                    }

                    return new System.Windows.Rect.$ctor2(System.Windows.Point.op_Addition(rect.Location, offset), rect.Size);
                },
                AddMargin: function (rect, margin) {
                    if (System.Windows.Thickness.op_Equality(margin, System.Windows.Thickness.Zero)) {
                        return rect;
                    }

                    return new System.Windows.Rect.$ctor2(System.Windows.Point.op_Subtraction(rect.Location, margin.Location), System.Windows.Size.op_Addition(rect.Size, margin.Size));
                },
                Union: function ($this, rect) {
                    if (System.Windows.RectExtensions.Contains$1($this, rect)) {
                        return $this;
                    }

                    if (System.Windows.RectExtensions.Contains$1(rect, $this)) {
                        return rect;
                    }

                    var left = Granular.Extensions.DoubleExtensions.Min($this.Left, rect.Left);
                    var top = Granular.Extensions.DoubleExtensions.Min($this.Top, rect.Top);
                    var right = Granular.Extensions.DoubleExtensions.Max($this.Right, rect.Right);
                    var bottom = Granular.Extensions.DoubleExtensions.Max($this.Bottom, rect.Bottom);

                    return new System.Windows.Rect.$ctor1(left, top, right - left, bottom - top);
                }
            }
        }
    });

    Bridge.define("System.Windows.ResourceContainerExtensions", {
        statics: {
            methods: {
                FindResource: function (resourceContainer, resourceKey) {
                    var value = { };

                    if (resourceContainer.System$Windows$IResourceContainer$TryGetResource(resourceKey, value)) {
                        return value.v;
                    }

                    throw new Granular.Exception("Resource \"{0}\" is not found", [resourceKey]);
                }
            }
        }
    });

    Bridge.define("System.Windows.ResourceDictionaryLocation", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                SourceAssembly: 1,
                ExternalAssembly: 2
            }
        }
    });

    Bridge.define("System.Windows.ResourcesChangedEventArgs", {
        statics: {
            fields: {
                Reset: null
            },
            ctors: {
                init: function () {
                    this.Reset = new System.Windows.ResourcesChangedEventArgs(null);
                }
            },
            methods: {
                FromKey: function (changedKey) {
                    return new System.Windows.ResourcesChangedEventArgs(System.Array.init([changedKey], System.Object));
                },
                FromKeyCollection: function (changedKeys) {
                    return new System.Windows.ResourcesChangedEventArgs(changedKeys);
                }
            }
        },
        fields: {
            changedKeys: null
        },
        ctors: {
            ctor: function (changedKeys) {
                this.$initialize();
                this.changedKeys = changedKeys;
            }
        },
        methods: {
            Contains: function (resourceKey) {
                return this.changedKeys == null ? true : System.Linq.Enumerable.from(this.changedKeys).contains(resourceKey);
            }
        }
    });

    Bridge.define("System.Windows.RoutedEvent", {
        fields: {
            hashCode: 0,
            classesHandlers: null
        },
        props: {
            Name: null,
            RoutingStrategy: 0,
            HandlerType: null,
            OwnerType: null,
            StringKey: null
        },
        ctors: {
            ctor: function (name, routingStrategy, handlerType, ownerType) {
                this.$initialize();
                this.Name = name;
                this.RoutingStrategy = routingStrategy;
                this.HandlerType = handlerType;
                this.OwnerType = ownerType;
                this.StringKey = (Bridge.Reflection.getTypeFullName(ownerType) || "") + "," + (name || "");
                this.hashCode = Bridge.getHashCode(this.StringKey);
            }
        },
        methods: {
            AddOwner: function (ownerType) {
                System.Windows.EventManager.AddOwner(this, ownerType);
                return this;
            },
            getHashCode: function () {
                return this.hashCode;
            },
            toString: function () {
                return System.String.format("{0}.{1}", Bridge.Reflection.getTypeFullName(this.OwnerType), this.Name);
            },
            RegisterClassHandler: function (classType, routedEventHandlerItem) {
                if (this.classesHandlers == null) {
                    this.classesHandlers = new (Granular.Collections.ListDictionary$2(Function,System.Windows.RoutedEventHandlerItem))();
                }

                this.classesHandlers.add(classType, routedEventHandlerItem);
            },
            GetClassHandlers: function (classType) {
                if (this.classesHandlers == null) {
                    return System.Array.init(0, null, System.Windows.RoutedEventHandlerItem);
                }

                var flattenedHandlers = null;
                var classesHandlesCount = 0;

                while (classType != null) {
                    var classHandlers = this.classesHandlers.getValues(classType);

                    if (System.Linq.Enumerable.from(classHandlers).any()) {
                        flattenedHandlers = flattenedHandlers != null ? System.Linq.Enumerable.from(classHandlers).concat(flattenedHandlers) : classHandlers;
                        classesHandlesCount = (classesHandlesCount + 1) | 0;
                    }

                    classType = Bridge.Reflection.getBaseType(classType);
                }

                return classesHandlesCount > 1 ? System.Linq.Enumerable.from(flattenedHandlers).toArray() : (flattenedHandlers || System.Array.init(0, null, System.Windows.RoutedEventHandlerItem));
            }
        }
    });

    Bridge.define("System.Windows.RoutedEventHandlerItem", {
        props: {
            Handler: null,
            HandledEventsToo: false
        },
        ctors: {
            ctor: function (handler, handledEventsToo) {
                this.$initialize();
                this.Handler = handler;
                this.HandledEventsToo = handledEventsToo;
            }
        }
    });

    Bridge.define("System.Windows.RoutingStrategy", {
        $kind: "enum",
        statics: {
            fields: {
                Tunnel: 0,
                Bubble: 1,
                Direct: 2
            }
        }
    });

    Bridge.define("System.Windows.Size", {
        statics: {
            fields: {
                Empty: null,
                Zero: null,
                Infinity: null
            },
            ctors: {
                init: function () {
                    this.Empty = new System.Windows.Size(Number.NaN, Number.NaN);
                    this.Zero = new System.Windows.Size(0, 0);
                    this.Infinity = new System.Windows.Size(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
                }
            },
            methods: {
                FromWidth: function (width) {
                    return new System.Windows.Size(width, Number.NaN);
                },
                FromHeight: function (height) {
                    return new System.Windows.Size(Number.NaN, height);
                },
                Parse: function (value) {
                    var values = System.Linq.Enumerable.from(System.String.split(value, [44].map(function(i) {{ return String.fromCharCode(i); }}))).select($asm.$.System.Windows.Size.f1).toArray(System.Double);

                    if (values.length === 2) {
                        return new System.Windows.Size(values[System.Array.index(0, values)], values[System.Array.index(1, values)]);
                    }

                    throw new Granular.Exception("Can't parse Size value \"{0}\"", [value]);
                },
                IsNullOrEmpty: function (size) {
                    return Bridge.referenceEquals(size, null) || size.IsEmpty;
                },
                op_Equality: function (size1, size2) {
                    return Bridge.equals(size1, size2);
                },
                op_Inequality: function (size1, size2) {
                    return !(System.Windows.Size.op_Equality(size1, size2));
                },
                op_UnaryNegation: function (size) {
                    if (System.Windows.Size.op_Equality(size, System.Windows.Size.Zero)) {
                        return size;
                    }

                    return new System.Windows.Size(-size.Width, -size.Height);
                },
                op_Addition: function (size1, size2) {
                    if (System.Windows.Size.op_Equality(size1, System.Windows.Size.Zero)) {
                        return size2;
                    }

                    if (System.Windows.Size.op_Equality(size2, System.Windows.Size.Zero)) {
                        return size1;
                    }

                    return new System.Windows.Size(size1.Width + size2.Width, size1.Height + size2.Height);
                },
                op_Subtraction: function (size1, size2) {
                    if (System.Windows.Size.op_Equality(size1, System.Windows.Size.Zero)) {
                        return System.Windows.Size.op_UnaryNegation(size2);
                    }

                    if (System.Windows.Size.op_Equality(size2, System.Windows.Size.Zero)) {
                        return size1;
                    }

                    return new System.Windows.Size(size1.Width - size2.Width, size1.Height - size2.Height);
                },
                op_Multiply$1: function (size, factor) {
                    if (factor === 1 || Bridge.referenceEquals(size, System.Windows.Size.Zero)) {
                        return size;
                    }

                    return new System.Windows.Size(size.Width * factor, size.Height * factor);
                },
                op_Multiply: function (factor, size) {
                    return System.Windows.Size.op_Multiply$1(size, factor);
                },
                op_Division: function (size, factor) {
                    if (factor === 1 || Bridge.referenceEquals(size, System.Windows.Size.Zero)) {
                        return size;
                    }

                    return new System.Windows.Size(size.Width / factor, size.Height / factor);
                },
                op_Explicit: function (point) {
                    return new System.Windows.Size(point.X, point.Y);
                }
            }
        },
        props: {
            Width: 0,
            Height: 0,
            IsWidthEmpty: false,
            IsHeightEmpty: false,
            IsEmpty: false,
            IsPartiallyEmpty: false
        },
        ctors: {
            ctor: function (width, height) {
                this.$initialize();
                this.Width = width;
                this.Height = height;

                this.IsWidthEmpty = isNaN(this.Width);
                this.IsHeightEmpty = isNaN(this.Height);
                this.IsEmpty = this.IsWidthEmpty && this.IsHeightEmpty;
                this.IsPartiallyEmpty = this.IsWidthEmpty || this.IsHeightEmpty;
            }
        },
        methods: {
            toString: function () {
                return System.String.format("Size({0}, {1})", Bridge.box(this.Width, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(this.Height, System.Double, System.Double.format, System.Double.getHashCode));
            },
            equals: function (obj) {
                var other = Bridge.as(obj, System.Windows.Size);

                return Bridge.referenceEquals(this, other) || !Bridge.referenceEquals(other, null) && Granular.Compatibility.EqualityComparer.Double.equals2(this.Width, other.Width) && Granular.Compatibility.EqualityComparer.Double.equals2(this.Height, other.Height);
            },
            getHashCode: function () {
                return System.Double.getHashCode(this.Width) ^ System.Double.getHashCode(this.Height);
            }
        }
    });

    Bridge.ns("System.Windows.Size", $asm.$);

    Bridge.apply($asm.$.System.Windows.Size, {
        f1: function (v) {
            return System.Double.parse(v);
        }
    });

    Bridge.define("System.Windows.SizeExtensions", {
        statics: {
            methods: {
                IsNullOrEmpty: function (size) {
                    return System.Windows.Size.IsNullOrEmpty(size);
                },
                DefaultIfNullOrEmpty: function (size, defaultValue) {
                    if (defaultValue === void 0) { defaultValue = null; }
                    return System.Windows.Size.IsNullOrEmpty(size) ? (defaultValue || System.Windows.Size.Zero) : size;
                },
                Combine: function (size, fallback) {
                    if (!size.IsPartiallyEmpty) {
                        return size;
                    }

                    if (size.IsEmpty) {
                        return fallback;
                    }

                    return new System.Windows.Size(size.IsWidthEmpty ? fallback.Width : size.Width, size.IsHeightEmpty ? fallback.Height : size.Height);
                },
                Min: function ($this, size) {
                    if ($this.IsEmpty) {
                        return size;
                    }

                    if (size.IsEmpty) {
                        return $this;
                    }

                    if (!$this.IsPartiallyEmpty && !size.IsPartiallyEmpty) {
                        if ($this.Width < size.Width && $this.Height < size.Height) {
                            return $this;
                        }

                        if ($this.Width >= size.Width && $this.Height >= size.Height) {
                            return size;
                        }
                    }

                    return new System.Windows.Size($this.IsWidthEmpty ? size.Width : (size.IsWidthEmpty ? $this.Width : Math.min($this.Width, size.Width)), $this.IsHeightEmpty ? size.Height : (size.IsHeightEmpty ? $this.Height : Math.min($this.Height, size.Height)));
                },
                Max: function ($this, size) {
                    if ($this.IsEmpty) {
                        return size;
                    }

                    if (size.IsEmpty) {
                        return $this;
                    }

                    if (!$this.IsPartiallyEmpty && !size.IsPartiallyEmpty) {
                        if ($this.Width > size.Width && $this.Height > size.Height) {
                            return $this;
                        }

                        if ($this.Width <= size.Width && $this.Height <= size.Height) {
                            return size;
                        }
                    }

                    return new System.Windows.Size($this.IsWidthEmpty ? size.Width : (size.IsWidthEmpty ? $this.Width : Math.max($this.Width, size.Width)), $this.IsHeightEmpty ? size.Height : (size.IsHeightEmpty ? $this.Height : Math.max($this.Height, size.Height)));
                },
                Bounds: function (size, minimum, maximum) {
                    if (minimum.Width > maximum.Width || minimum.Height > maximum.Height) {
                        throw new Granular.Exception("Invalid bounds (minimum: {0}, maximum: {1})", [minimum, maximum]);
                    }

                    return System.Windows.SizeExtensions.Min(System.Windows.SizeExtensions.Max(size, minimum), maximum);
                },
                IsClose: function ($this, size) {
                    return Granular.Extensions.DoubleExtensions.IsClose($this.Width, size.Width) && Granular.Extensions.DoubleExtensions.IsClose($this.Height, size.Height);
                },
                ToPoint: function (size) {
                    return new System.Windows.Point.$ctor1(size.Width, size.Height);
                },
                Contains: function (size, point) {
                    return 0 <= point.X && point.X < size.Width && 0 <= point.Y && point.Y < size.Height;
                },
                MaxArea: function ($this, size) {
                    return $this.Width * $this.Height > size.Width * size.Height ? $this : size;
                }
            }
        }
    });

    Bridge.define("System.Windows.StartupEventArgs", {
        statics: {
            fields: {
                Empty: null
            },
            ctors: {
                init: function () {
                    this.Empty = new System.Windows.StartupEventArgs();
                }
            }
        },
        props: {
            Args: null
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                this.Args = System.Array.init(0, null, System.String);
            }
        }
    });

    Bridge.define("System.Windows.StartupEventHandlerExtensions", {
        statics: {
            methods: {
                Raise: function (handler, sender, e) {
                    if (!Bridge.staticEquals(handler, null)) {
                        handler(sender, e);
                    }
                }
            }
        }
    });

    Bridge.define("System.Windows.Style", {
        fields: {
            targetType: null,
            key: null
        },
        props: {
            TargetType: {
                get: function () {
                    return this.targetType;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.targetType, value)) {
                        return;
                    }

                    this.targetType = value;
                }
            },
            Key: {
                get: function () {
                    var $t;
                    return ($t = this.key, $t != null ? $t : new System.Windows.StyleKey(this.TargetType));
                },
                set: function (value) {
                    this.key = value;
                }
            },
            BasedOn: null,
            Triggers: null,
            Setters: null
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                this.Triggers = new (Granular.Collections.ObservableCollection$1(System.Windows.ITrigger)).ctor();
                this.Setters = new (Granular.Collections.ObservableCollection$1(System.Windows.ITriggerAction)).ctor();
            }
        },
        methods: {
            Attach: function (element) {
                this.Attach$1(element, $asm.$.System.Windows.Style.f1);
            },
            Attach$1: function (element, settersFilter) {
                var $t, $t1;
                if (this.BasedOn != null) {
                    this.BasedOn.Attach$1(element, Bridge.fn.bind(this, function (setter) {
                        return !System.Linq.Enumerable.from(this.Setters).any(function (action) {
                                return action.System$Windows$ITriggerAction$IsActionOverlaps(setter);
                            }) && settersFilter(setter);
                    }));
                }

                $t = Bridge.getEnumerator(System.Linq.Enumerable.from(this.Setters).where(settersFilter));
                try {
                    while ($t.moveNext()) {
                        var action = $t.Current;
                        action.System$Windows$ITriggerAction$Apply(element, System.Windows.BaseValueSource.Style);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                $t1 = Bridge.getEnumerator(this.Triggers);
                try {
                    while ($t1.moveNext()) {
                        var trigger = $t1.Current;
                        trigger.System$Windows$ITrigger$Attach(element, System.Windows.BaseValueSource.StyleTrigger);
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$dispose();
                    }
                }},
            Detach: function (element) {
                this.Detach$1(element, $asm.$.System.Windows.Style.f1);
            },
            Detach$1: function (element, settersFilter) {
                var $t, $t1;
                if (this.BasedOn != null) {
                    this.BasedOn.Detach$1(element, Bridge.fn.bind(this, function (setter) {
                        return !System.Linq.Enumerable.from(this.Setters).any(function (action) {
                                return action.System$Windows$ITriggerAction$IsActionOverlaps(setter);
                            }) && settersFilter(setter);
                    }));
                }

                $t = Bridge.getEnumerator(System.Linq.Enumerable.from(this.Setters).where(settersFilter));
                try {
                    while ($t.moveNext()) {
                        var action = $t.Current;
                        action.System$Windows$ITriggerAction$Clean(element, System.Windows.BaseValueSource.Style);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                $t1 = Bridge.getEnumerator(this.Triggers);
                try {
                    while ($t1.moveNext()) {
                        var trigger = $t1.Current;
                        trigger.System$Windows$ITrigger$Detach(element, System.Windows.BaseValueSource.StyleTrigger);
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$dispose();
                    }
                }}
        }
    });

    Bridge.ns("System.Windows.Style", $asm.$);

    Bridge.apply($asm.$.System.Windows.Style, {
        f1: function (setter) {
            return true;
        }
    });

    Bridge.define("System.Windows.TemplatePartAttribute", {
        inherits: [System.Attribute],
        props: {
            Name: null,
            Type: null
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Attribute.ctor.call(this);
                //
            },
            $ctor1: function (name, type) {
                System.Windows.TemplatePartAttribute.ctor.call(this);
                this.Name = name;
                this.Type = type;
            }
        }
    });

    Bridge.define("System.Windows.TemplateVisualStateAttribute", {
        inherits: [System.Attribute],
        props: {
            GroupName: null,
            Name: null
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Attribute.ctor.call(this);
                //
            },
            $ctor1: function (groupName, name) {
                System.Windows.TemplateVisualStateAttribute.ctor.call(this);
                this.GroupName = groupName;
                this.Name = name;
            }
        }
    });

    Bridge.define("System.Windows.TextAlignment", {
        $kind: "enum",
        statics: {
            fields: {
                Left: 0,
                Right: 1,
                Center: 2,
                Justify: 3
            }
        }
    });

    Bridge.define("System.Windows.TextTrimming", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                CharacterEllipsis: 1
            }
        }
    });

    Bridge.define("System.Windows.TextWrapping", {
        $kind: "enum",
        statics: {
            fields: {
                Wrap: 0,
                NoWrap: 1
            }
        }
    });

    Bridge.define("System.Windows.ThemeInfoAttribute", {
        inherits: [System.Attribute],
        props: {
            GenericDictionaryLocation: 0
        },
        ctors: {
            $ctor1: function (themeDictionaryLocation, genericDictionaryLocation) {
                System.Windows.ThemeInfoAttribute.ctor.call(this, genericDictionaryLocation);
                //
            },
            ctor: function (genericDictionaryLocation) {
                this.$initialize();
                System.Attribute.ctor.call(this);
                this.GenericDictionaryLocation = genericDictionaryLocation;
            }
        }
    });

    Bridge.define("System.Windows.ThicknessExtensions", {
        statics: {
            methods: {
                DefaultIfNull: function (thickness, defaultValue) {
                    if (defaultValue === void 0) { defaultValue = null; }
                    return thickness || defaultValue || System.Windows.Thickness.Zero;
                }
            }
        }
    });

    Bridge.define("System.Windows.Threading.Dispatcher", {
        statics: {
            fields: {
                CurrentDispatcher: null
            },
            ctors: {
                init: function () {
                    this.CurrentDispatcher = new System.Windows.Threading.Dispatcher();
                }
            }
        },
        fields: {
            queue: null,
            disableProcessingRequests: 0,
            isProcessQueueScheduled: false,
            disableProcessingToken: null
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                this.queue = new (Granular.Collections.PriorityQueue$1(System.Windows.Threading.DispatcherOperation))(11);
                this.disableProcessingToken = new Granular.Disposable(Bridge.fn.cacheBind(this, this.EnableProcessing));
            }
        },
        methods: {
            Invoke$1: function (callback, priority) {
                if (priority === void 0) { priority = 9; }
                this.Invoke$2(new System.Windows.Threading.DispatcherOperation.ctor(callback, priority));
            },
            Invoke: function (TResult, callback, priority) {
                if (priority === void 0) { priority = 9; }
                var dispatcherOperation = new (System.Windows.Threading.DispatcherOperation$1(TResult))(callback, priority);
                this.Invoke$2(dispatcherOperation);
                return dispatcherOperation.Result$1;
            },
            Invoke$2: function (operation) {
                this.queue.Enqueue(operation.Priority, operation);

                var currentOperation = { };
                while (this.TryDequeue(currentOperation)) {
                    currentOperation.v.Invoke();

                    if (Bridge.referenceEquals(currentOperation.v, operation)) {
                        return;
                    }
                }

                if (this.disableProcessingRequests > 0) {
                    throw new Granular.Exception("Can't invoke an operation while the dispatcher processing is disabled");
                }

                throw new Granular.Exception("Can't invoke an inactive or aborted operation");
            },
            InvokeAsync: function (callback, priority) {
                if (priority === void 0) { priority = 9; }
                var dispatcherOperation = new System.Windows.Threading.DispatcherOperation.ctor(callback, priority);
                this.InvokeAsync$2(dispatcherOperation);
                return dispatcherOperation;
            },
            InvokeAsync$1: function (TResult, callback, priority) {
                if (priority === void 0) { priority = 9; }
                var dispatcherOperation = new (System.Windows.Threading.DispatcherOperation$1(TResult))(callback, priority);
                this.InvokeAsync$2(dispatcherOperation);
                return dispatcherOperation;
            },
            InvokeAsync$2: function (operation) {
                this.queue.Enqueue(operation.Priority, operation);
                this.ProcessQueueAsync();
            },
            ProcessQueueAsync: function () {
                if (this.isProcessQueueScheduled) {
                    return;
                }

                this.isProcessQueueScheduled = true;
                System.Windows.Threading.TaskSchedulerExtensions.ScheduleTask(System.Windows.ApplicationHost.Current.System$Windows$IApplicationHost$TaskScheduler, Bridge.fn.bind(this, $asm.$.System.Windows.Threading.Dispatcher.f1));
            },
            TryDequeue: function (operation) {
                while (this.disableProcessingRequests === 0 && this.queue.TryPeek(operation) && operation.v.Priority !== System.Windows.Threading.DispatcherPriority.Inactive) {
                    this.queue.Dequeue();

                    if (operation.v.Status !== System.Windows.Threading.DispatcherOperationStatus.Pending) {
                        continue;
                    }

                    return true;
                }

                operation.v = null;
                return false;
            },
            DisableProcessing: function () {
                this.disableProcessingRequests = (this.disableProcessingRequests + 1) | 0;
                return this.disableProcessingToken;
            },
            EnableProcessing: function () {
                this.disableProcessingRequests = (this.disableProcessingRequests - 1) | 0;

                if (this.disableProcessingRequests === 0) {
                    this.ProcessQueueAsync();
                }
            }
        }
    });

    Bridge.ns("System.Windows.Threading.Dispatcher", $asm.$);

    Bridge.apply($asm.$.System.Windows.Threading.Dispatcher, {
        f1: function () {
            this.isProcessQueueScheduled = false;

            var operation = { };
            if (!this.TryDequeue(operation)) {
                return;
            }

            if (operation.v.Status === System.Windows.Threading.DispatcherOperationStatus.Pending) {
                operation.v.Invoke();
                this.ProcessQueueAsync();
            }
        }
    });

    Bridge.define("System.Windows.Threading.DispatcherOperation", {
        fields: {
            action: null
        },
        events: {
            Completed: null,
            Aborted: null
        },
        props: {
            Priority: 0,
            Status: 0,
            Result: null
        },
        ctors: {
            ctor: function (action, priority) {
                System.Windows.Threading.DispatcherOperation.$ctor1.call(this, function () {
                    action();
                    return null;
                }, priority);
                //
            },
            $ctor1: function (action, priority) {
                this.$initialize();
                this.action = action;
                this.Priority = priority;
            }
        },
        methods: {
            Abort: function () {
                if (this.Status !== System.Windows.Threading.DispatcherOperationStatus.Pending) {
                    throw new Granular.Exception("Operation is \"{0}\" and cannot be aborted", [Bridge.box(this.Status, System.Windows.Threading.DispatcherOperationStatus, System.Enum.toStringFn(System.Windows.Threading.DispatcherOperationStatus))]);
                }

                this.Status = System.Windows.Threading.DispatcherOperationStatus.Aborted;
                Granular.Extensions.EventHandlerExtensions.Raise$2(this.Aborted, this);
            },
            Invoke: function () {
                if (this.Status !== System.Windows.Threading.DispatcherOperationStatus.Pending) {
                    throw new Granular.Exception("Operation is \"{0}\" and cannot be invoked", [Bridge.box(this.Status, System.Windows.Threading.DispatcherOperationStatus, System.Enum.toStringFn(System.Windows.Threading.DispatcherOperationStatus))]);
                }

                this.Status = System.Windows.Threading.DispatcherOperationStatus.Executing;
                this.Result = this.action();
                this.Status = System.Windows.Threading.DispatcherOperationStatus.Completed;
                Granular.Extensions.EventHandlerExtensions.Raise$2(this.Completed, this);
            }
        }
    });

    Bridge.define("System.Windows.Threading.DispatcherOperationStatus", {
        $kind: "enum",
        statics: {
            fields: {
                Pending: 0,
                Aborted: 1,
                Completed: 2,
                Executing: 3
            }
        }
    });

    Bridge.define("System.Windows.Threading.DispatcherPriority", {
        $kind: "enum",
        statics: {
            fields: {
                Invalid: -1,
                Inactive: 0,
                SystemIdle: 1,
                ApplicationIdle: 2,
                ContextIdle: 3,
                Background: 4,
                Input: 5,
                Loaded: 6,
                Render: 7,
                DataBind: 8,
                Normal: 9,
                Send: 10
            }
        }
    });

    Bridge.define("System.Windows.Threading.DispatcherTimer", {
        fields: {
            priority: 0,
            interval: null,
            isEnabled: false,
            dispatcher: null,
            scheduler: null,
            scheduledTask: null
        },
        events: {
            Tick: null
        },
        props: {
            Priority: {
                get: function () {
                    return this.priority;
                },
                set: function (value) {
                    if (this.IsEnabled) {
                        throw new Granular.Exception("Can't change an active DispatcherTimer priority");
                    }

                    this.priority = value;
                }
            },
            Interval: {
                get: function () {
                    return this.interval;
                },
                set: function (value) {
                    if (this.IsEnabled) {
                        throw new Granular.Exception("Can't change an active DispatcherTimer interval");
                    }

                    this.interval = value;
                }
            },
            IsEnabled: {
                get: function () {
                    return this.isEnabled;
                },
                set: function (value) {
                    if (this.isEnabled === value) {
                        return;
                    }

                    this.isEnabled = value;
                    if (this.isEnabled) {
                        this.ScheduleTask();
                    } else {
                        this.CancelTask();
                    }
                }
            }
        },
        ctors: {
            init: function () {
                this.interval = new System.TimeSpan();
            },
            ctor: function () {
                System.Windows.Threading.DispatcherTimer.$ctor1.call(this, System.Windows.Threading.Dispatcher.CurrentDispatcher, System.Windows.ApplicationHost.Current.System$Windows$IApplicationHost$TaskScheduler, System.TimeSpan.fromSeconds(1), System.Windows.Threading.DispatcherPriority.Normal);
                //
            },
            $ctor1: function (dispatcher, scheduler, interval, priority) {
                this.$initialize();
                this.dispatcher = dispatcher;
                this.scheduler = scheduler;
                this.Interval = interval;
                this.Priority = priority;
            }
        },
        methods: {
            Start: function () {
                this.IsEnabled = true;
            },
            Stop: function () {
                this.IsEnabled = false;
            },
            ScheduleTask: function () {
                if (!this.IsEnabled) {
                    return;
                }

                this.scheduledTask = this.scheduler.System$Windows$Threading$ITaskScheduler$ScheduleTask(this.Interval, Bridge.fn.bind(this, $asm.$.System.Windows.Threading.DispatcherTimer.f2));
            },
            CancelTask: function () {
                if (this.scheduledTask != null) {
                    this.scheduledTask.System$IDisposable$dispose();
                    this.scheduledTask = null;
                }
            }
        }
    });

    Bridge.ns("System.Windows.Threading.DispatcherTimer", $asm.$);

    Bridge.apply($asm.$.System.Windows.Threading.DispatcherTimer, {
        f1: function () {
            Granular.Extensions.EventHandlerExtensions.Raise$2(this.Tick, this);
        },
        f2: function () {
            this.dispatcher.InvokeAsync(Bridge.fn.bind(this, $asm.$.System.Windows.Threading.DispatcherTimer.f1), this.Priority);
            this.ScheduleTask();
        }
    });

    Bridge.define("System.Windows.Threading.ITaskScheduler", {
        $kind: "interface"
    });

    Bridge.define("System.Windows.Threading.TaskSchedulerExtensions", {
        statics: {
            methods: {
                ScheduleTask: function (taskScheduler, action) {
                    return taskScheduler.System$Windows$Threading$ITaskScheduler$ScheduleTask(System.TimeSpan.zero, action);
                }
            }
        }
    });

    Bridge.define("System.Windows.ValueSource", {
        props: {
            BaseValueSource: 0,
            IsExpression: false,
            IsCurrent: false,
            IsAnimated: false,
            IsCoerced: false
        },
        ctors: {
            ctor: function (baseValueSource, isExpression, isCurrent, isAnimated, isCoerced) {
                this.$initialize();
                this.BaseValueSource = baseValueSource;
                this.IsExpression = isExpression;
                this.IsCurrent = isCurrent;
                this.IsAnimated = isAnimated;
                this.IsCoerced = isCoerced;
            }
        }
    });

    Bridge.define("System.Windows.VerticalAlignment", {
        $kind: "enum",
        statics: {
            fields: {
                Top: 0,
                Center: 1,
                Bottom: 2,
                Stretch: 3
            }
        }
    });

    Bridge.define("System.Windows.Visibility", {
        $kind: "enum",
        statics: {
            fields: {
                Visible: 0,
                Hidden: 1,
                Collapsed: 2
            }
        }
    });

    Bridge.define("System.Windows.VisualStateManager", {
        statics: {
            fields: {
                VisualStateGroupsProperty: null
            },
            ctors: {
                init: function () {
                    this.VisualStateGroupsProperty = System.Windows.DependencyProperty.RegisterAttached("VisualStateGroups", System.Windows.FreezableCollection$1(System.Windows.VisualStateGroup), System.Windows.VisualStateManager, new System.Windows.FrameworkPropertyMetadata.ctor());
                }
            },
            methods: {
                GetVisualStateGroups: function (obj) {
                    return Bridge.cast(obj.GetValue(System.Windows.VisualStateManager.VisualStateGroupsProperty), System.Windows.FreezableCollection$1(System.Windows.VisualStateGroup));
                },
                SetVisualStateGroups: function (obj, value) {
                    obj.SetValue(System.Windows.VisualStateManager.VisualStateGroupsProperty, value);
                },
                GoToState: function (control, stateName, useTransitions) {
                    if (control.TemplateChild == null) {
                        return false;
                    }

                    var visualStateGroups = System.Windows.VisualStateManager.GetVisualStateGroups(control.TemplateChild);
                    if (visualStateGroups == null) {
                        return false;
                    }

                    var visualStateGroup = System.Linq.Enumerable.from(visualStateGroups).firstOrDefault(function (group) {
                            return System.Linq.Enumerable.from(group.States).any(function (state) {
                                    return Bridge.referenceEquals(state.Name, stateName);
                                });
                        }, null);
                    if (visualStateGroup == null) {
                        return false;
                    }

                    var visualState = System.Linq.Enumerable.from(visualStateGroup.States).first(function (state) {
                            return Bridge.referenceEquals(state.Name, stateName);
                        });

                    visualStateGroup.SetContainer(control);
                    return visualStateGroup.GoToState(visualState, useTransitions);
                }
            }
        }
    });

    Bridge.define("System.Windows.Application", {
        inherits: [System.Windows.IResourceContainer,System.Windows.Markup.IUriContext],
        statics: {
            fields: {
                SystemResources: null
            },
            props: {
                Current: null
            },
            ctors: {
                init: function () {
                    this.SystemResources = new System.Windows.SystemResources();
                }
            },
            methods: {
                LoadComponent: function (resourceLocator) {
                    return System.Windows.EmbeddedResourceLoader.LoadResourceElement(resourceLocator);
                },
                LoadComponent$1: function (component, resourceLocator) {
                    System.Windows.Markup.XamlLoader.Load$1(component, System.Windows.Markup.XamlParser.Parse(Granular.Compatibility.String.FromByteArray(System.Windows.EmbeddedResourceLoader.LoadResourceData(resourceLocator)), resourceLocator));
                }
            }
        },
        fields: {
            resources: null
        },
        events: {
            ResourcesChanged: null,
            Startup: null,
            LoadCompleted: null
        },
        props: {
            StartupUri: null,
            MainWindow: null,
            Resources: {
                get: function () {
                    return this.resources;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.resources, value)) {
                        return;
                    }

                    if (this.resources != null) {
                        this.resources.removeResourcesChanged(Bridge.fn.cacheBind(this, this.OnResourcesChanged));
                    }

                    this.resources = value;

                    if (this.resources != null) {
                        this.resources.addResourcesChanged(Bridge.fn.cacheBind(this, this.OnResourcesChanged));
                    }
                    Granular.Extensions.EventHandlerExtensions.Raise$4(Bridge.global.System.Windows.ResourcesChangedEventArgs, this.ResourcesChanged, this, System.Windows.ResourcesChangedEventArgs.Reset);
                }
            },
            System$Windows$IResourceContainer$IsEmpty: {
                get: function () {
                    return false;
                }
            },
            BaseUri: null
        },
        alias: [
            "addResourcesChanged", "System$Windows$IResourceContainer$addResourcesChanged",
            "removeResourcesChanged", "System$Windows$IResourceContainer$removeResourcesChanged",
            "BaseUri", "System$Windows$Markup$IUriContext$BaseUri",
            "TryGetResource", "System$Windows$IResourceContainer$TryGetResource"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                if (System.Windows.Application.Current != null) {
                    throw new Granular.Exception("Application instance was already created");
                }

                System.Windows.Application.Current = this;
            }
        },
        methods: {
            Run: function () {
                this.OnStartup(System.Windows.StartupEventArgs.Empty);
                System.Windows.StartupEventHandlerExtensions.Raise(this.Startup, this, System.Windows.StartupEventArgs.Empty);

                this.LoadStartupUri();

                this.OnLoadCompleted();
                Granular.Extensions.EventHandlerExtensions.Raise$2(this.LoadCompleted, this);
            },
            LoadStartupUri: function () {
                if (this.StartupUri == null) {
                    return;
                }

                var uri = System.UriExtensions.ResolveAbsoluteUri(this.StartupUri, this.BaseUri);
                var rootElement = System.Windows.Markup.XamlParser.Parse(Granular.Compatibility.String.FromByteArray(System.Windows.EmbeddedResourceLoader.LoadResourceData(uri)), uri);
                var classDirective = System.Linq.Enumerable.from(rootElement.Directives).firstOrDefault($asm.$.System.Windows.Application.f1, null);

                var $window = Bridge.as(Bridge.createInstance(Bridge.Reflection.getType(System.String.format("{0}, {1}", System.Windows.Markup.XamlMemberExtensions.GetSingleValue(classDirective), System.AssemblyExtensions.GetName(Bridge.Reflection.getTypeAssembly(Bridge.getType(this))).Name))), System.Windows.Window);
                if ($window != null) {
                    $window.Show();
                }
            },
            OnResourcesChanged: function (sender, e) {
                Granular.Extensions.EventHandlerExtensions.Raise$4(Bridge.global.System.Windows.ResourcesChangedEventArgs, this.ResourcesChanged, this, e);
            },
            TryGetResource: function (resourceKey, value) {
                if (this.Resources != null && this.Resources.tryGetValue(resourceKey, value)) {
                    return true;
                }

                if (System.Windows.Application.SystemResources.TryGetResource(resourceKey, value)) {
                    return true;
                }

                value.v = null;
                return false;
            },
            OnStartup: function (e) {
                //
            },
            OnLoadCompleted: function () {
                //
            }
        }
    });

    Bridge.ns("System.Windows.Application", $asm.$);

    Bridge.apply($asm.$.System.Windows.Application, {
        f1: function (directive) {
            return System.Windows.Markup.XamlName.op_Equality(directive.Name, System.Windows.Markup.XamlLanguage.ClassDirective);
        }
    });

    Bridge.define("System.Windows.ComponentResourceKey", {
        inherits: [System.Windows.IResourceKey,System.Windows.Markup.IMarkupExtension],
        props: {
            Assembly: {
                get: function () {
                    return this.TypeInTargetAssembly != null ? Bridge.Reflection.getTypeAssembly(this.TypeInTargetAssembly) : null;
                }
            },
            TypeInTargetAssembly: null,
            ResourceId: null
        },
        alias: [
            "Assembly", "System$Windows$IResourceKey$Assembly",
            "ProvideValue", "System$Windows$Markup$IMarkupExtension$ProvideValue"
        ],
        methods: {
            ProvideValue: function (context) {
                return this;
            },
            equals: function (obj) {
                var other = Bridge.as(obj, System.Windows.ComponentResourceKey);

                return Bridge.referenceEquals(this, other) || !Bridge.referenceEquals(other, null) && Bridge.equals(this.TypeInTargetAssembly, other.TypeInTargetAssembly) && Bridge.equals(this.ResourceId, other.ResourceId);
            },
            getHashCode: function () {
                return Bridge.getHashCode(this.TypeInTargetAssembly) ^ Bridge.getHashCode(this.ResourceId);
            },
            toString: function () {
                return System.String.format("ComponentResourceKey({0}, {1})", Bridge.Reflection.getTypeName(this.TypeInTargetAssembly), this.ResourceId);
            }
        }
    });

    Bridge.define("System.Windows.ContentElement", {
        inherits: [System.Windows.DependencyObject],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.DependencyObject.ctor.call(this);
                //
            }
        }
    });

    Bridge.define("System.Windows.Media.Visual", {
        inherits: [System.Windows.DependencyObject,System.Windows.IContextElement],
        fields: {
            visualParent: null,
            visualChildren: null,
            visualBackground: null,
            visualBounds: null,
            visualClip: null,
            visualClipToBounds: false,
            visualIsHitTestVisible: false,
            visualIsVisible: false,
            visualOpacity: 0,
            visualTransform: null,
            visualLevel: 0,
            visualRenderElement: null,
            renderElementFactory: null,
            renderChildrenOffset: 0,
            hitTestBounds: null,
            isHitTestBoundsValid: false
        },
        events: {
            VisualAncestorChanged: null,
            VisualParentChanged: null,
            VisualBoundsChanged: null,
            VisualTransformChanged: null
        },
        props: {
            VisualParent: {
                get: function () {
                    return this.visualParent;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.visualParent, value)) {
                        return;
                    }

                    if (this.visualParent != null) {
                        this.visualParent.removeVisualAncestorChanged(Bridge.fn.cacheBind(this, this.OnVisualAncestorChanged$1));
                    }

                    var oldVisualParent = this.visualParent;
                    this.visualParent = value;

                    if (this.visualParent != null) {
                        this.visualParent.addVisualAncestorChanged(Bridge.fn.cacheBind(this, this.OnVisualAncestorChanged$1));
                    }

                    this.OnVisualParentChanged(oldVisualParent, this.visualParent);
                    Granular.Extensions.EventHandlerExtensions.Raise$2(this.VisualParentChanged, this);

                    this.OnVisualAncestorChanged();
                    Granular.Extensions.EventHandlerExtensions.Raise$2(this.VisualAncestorChanged, this);
                }
            },
            System$Windows$IContextElement$ContextParent: {
                get: function () {
                    return this.VisualParent;
                }
            },
            VisualChildren: null,
            VisualOffset: {
                get: function () {
                    return this.VisualBounds.Location;
                }
            },
            VisualSize: {
                get: function () {
                    return this.VisualBounds.Size;
                }
            },
            VisualBackground: {
                get: function () {
                    return this.visualBackground;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.visualBackground, value)) {
                        return;
                    }

                    this.visualBackground = value;

                    if (this.visualRenderElement != null) {
                        this.visualRenderElement.System$Windows$Media$IVisualRenderElement$Background = this.visualBackground;
                    }
                }
            },
            VisualBounds: {
                get: function () {
                    return this.visualBounds;
                },
                set: function (value) {
                    if (System.Windows.Rect.op_Equality(this.visualBounds, value)) {
                        return;
                    }

                    this.visualBounds = value;

                    if (this.visualRenderElement != null) {
                        this.visualRenderElement.System$Windows$Media$IVisualRenderElement$Bounds = this.visualBounds;
                    }

                    this.InvalidateHitTestBounds();

                    this.OnVisualBoundsChanged();
                    Granular.Extensions.EventHandlerExtensions.Raise$2(this.VisualBoundsChanged, this);
                }
            },
            VisualClip: {
                get: function () {
                    return this.visualClip;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.visualClip, value)) {
                        return;
                    }

                    this.visualClip = value;

                    if (this.visualRenderElement != null) {
                        this.visualRenderElement.System$Windows$Media$IVisualRenderElement$Clip = this.visualClip;
                    }
                }
            },
            VisualClipToBounds: {
                get: function () {
                    return this.visualClipToBounds;
                },
                set: function (value) {
                    if (this.visualClipToBounds === value) {
                        return;
                    }

                    this.visualClipToBounds = value;

                    if (this.visualRenderElement != null) {
                        this.visualRenderElement.System$Windows$Media$IVisualRenderElement$ClipToBounds = this.visualClipToBounds;
                    }

                    this.InvalidateHitTestBounds();
                }
            },
            VisualIsHitTestVisible: {
                get: function () {
                    return this.visualIsHitTestVisible;
                },
                set: function (value) {
                    if (this.visualIsHitTestVisible === value) {
                        return;
                    }

                    this.visualIsHitTestVisible = value;

                    if (this.visualRenderElement != null) {
                        this.visualRenderElement.System$Windows$Media$IVisualRenderElement$IsHitTestVisible = this.visualIsHitTestVisible;
                    }
                }
            },
            VisualIsVisible: {
                get: function () {
                    return this.visualIsVisible;
                },
                set: function (value) {
                    if (this.visualIsVisible === value) {
                        return;
                    }

                    this.visualIsVisible = value;

                    if (this.visualRenderElement != null) {
                        this.visualRenderElement.System$Windows$Media$IVisualRenderElement$IsVisible = this.visualIsVisible;
                    }
                }
            },
            VisualOpacity: {
                get: function () {
                    return this.visualOpacity;
                },
                set: function (value) {
                    if (this.visualOpacity === value) {
                        return;
                    }

                    this.visualOpacity = value;

                    if (this.visualRenderElement != null) {
                        this.visualRenderElement.System$Windows$Media$IVisualRenderElement$Opacity = this.visualOpacity;
                    }
                }
            },
            VisualTransform: {
                get: function () {
                    return this.visualTransform;
                },
                set: function (value) {
                    if (System.Windows.Media.Matrix.op_Equality(this.visualTransform, value)) {
                        return;
                    }

                    this.visualTransform = value;

                    if (this.visualRenderElement != null) {
                        this.visualRenderElement.System$Windows$Media$IVisualRenderElement$Transform = this.visualTransform;
                    }

                    this.InvalidateHitTestBounds();

                    this.OnVisualTransformChanged();
                    Granular.Extensions.EventHandlerExtensions.Raise$2(this.VisualTransformChanged, this);
                }
            },
            VisualLevel: {
                get: function () {
                    if (this.visualLevel === -1) {
                        this.visualLevel = this.VisualParent != null ? ((this.VisualParent.VisualLevel + 1) | 0) : 0;
                    }

                    return this.visualLevel;
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.DependencyObject.ctor.call(this);
                this.visualChildren = new (System.Collections.Generic.List$1(System.Windows.Media.Visual)).ctor();
                this.VisualChildren = new (System.Collections.ObjectModel.ReadOnlyCollection$1(System.Windows.Media.Visual))(this.visualChildren);

                this.VisualBackground = null;
                this.VisualBounds = System.Windows.Rect.Zero;
                this.VisualClip = null;
                this.VisualClipToBounds = true;
                this.VisualIsHitTestVisible = true;
                this.VisualIsVisible = true;
                this.VisualOpacity = 1;
                this.VisualTransform = System.Windows.Media.Matrix.Identity;

                this.visualLevel = -1;
            }
        },
        methods: {
            System$Windows$IContextElement$addContextParentChanged: function (value) {
                this.addVisualAncestorChanged(value);
            },
            System$Windows$IContextElement$removeContextParentChanged: function (value) {
                this.removeVisualAncestorChanged(value);
            },
            AddVisualChild: function (child) {
                if (Bridge.referenceEquals(child.VisualParent, this)) {
                    return;
                }

                if (child.VisualParent != null) {
                    child.VisualParent.RemoveVisualChild(child);
                }

                child.VisualParent = this;
                this.visualChildren.add(child);

                var renderChildIndex = (this.visualChildren.Count - 1) | 0;
                if (this.visualRenderElement != null) {
                    this.visualRenderElement.System$Windows$Media$IContainerRenderElement$InsertChild(((this.renderChildrenOffset + renderChildIndex) | 0), child.GetRenderElement(this.renderElementFactory));
                }

                this.InvalidateHitTestBounds();
            },
            RemoveVisualChild: function (child) {
                if (!Bridge.referenceEquals(child.VisualParent, this)) {
                    return;
                }

                this.visualChildren.remove(child);
                child.VisualParent = null;

                if (this.visualRenderElement != null) {
                    this.visualRenderElement.System$Windows$Media$IContainerRenderElement$RemoveChild(child.GetRenderElement(this.renderElementFactory));
                }

                this.InvalidateHitTestBounds();
            },
            SetVisualChildIndex: function (child, newIndex) {
                var oldIndex = this.visualChildren.indexOf(child);
                if (oldIndex === -1 || oldIndex === newIndex) {
                    return;
                }

                this.visualChildren.remove(child);
                this.visualChildren.insert(newIndex, child);

                if (this.visualRenderElement != null) {
                    var childRenderElement = child.GetRenderElement(this.renderElementFactory);

                    this.visualRenderElement.System$Windows$Media$IContainerRenderElement$RemoveChild(childRenderElement);
                    this.visualRenderElement.System$Windows$Media$IContainerRenderElement$InsertChild(((this.renderChildrenOffset + newIndex) | 0), childRenderElement);
                }
            },
            ClearVisualChildren: function () {
                var $t;
                $t = Bridge.getEnumerator(this.visualChildren.toArray());
                try {
                    while ($t.moveNext()) {
                        var child = $t.Current;
                        this.RemoveVisualChild(child);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }},
            OnVisualParentChanged: function (oldVisualParent, newVisualParent) {
                //
            },
            OnVisualAncestorChanged: function () {
                this.visualLevel = -1;
            },
            OnVisualAncestorChanged$1: function (sender, e) {
                this.OnVisualAncestorChanged();
                Granular.Extensions.EventHandlerExtensions.Raise$2(this.VisualAncestorChanged, this);
            },
            GetRenderElement: function (factory) {
                var $t;
                if (this.visualRenderElement == null) {
                    this.renderElementFactory = factory;
                    this.visualRenderElement = factory.System$Windows$Media$IRenderElementFactory$CreateVisualRenderElement(this);

                    this.visualRenderElement.System$Windows$Media$IVisualRenderElement$Background = this.VisualBackground;
                    this.visualRenderElement.System$Windows$Media$IVisualRenderElement$Bounds = this.VisualBounds;
                    this.visualRenderElement.System$Windows$Media$IVisualRenderElement$Clip = this.VisualClip;
                    this.visualRenderElement.System$Windows$Media$IVisualRenderElement$ClipToBounds = this.VisualClipToBounds;
                    this.visualRenderElement.System$Windows$Media$IVisualRenderElement$IsHitTestVisible = this.VisualIsHitTestVisible;
                    this.visualRenderElement.System$Windows$Media$IVisualRenderElement$IsVisible = this.VisualIsVisible;
                    this.visualRenderElement.System$Windows$Media$IVisualRenderElement$Opacity = this.VisualOpacity;
                    this.visualRenderElement.System$Windows$Media$IVisualRenderElement$Transform = this.VisualTransform;

                    var content = this.CreateRenderElementContentOverride(factory);

                    if (content != null) {
                        this.renderChildrenOffset = 1;
                        this.visualRenderElement.System$Windows$Media$IContainerRenderElement$InsertChild(0, content);
                    }

                    var index = 0;
                    $t = Bridge.getEnumerator(this.VisualChildren);
                    try {
                        while ($t.moveNext()) {
                            var child = $t.Current;
                            child.GetRenderElement(factory);
                            this.visualRenderElement.System$Windows$Media$IContainerRenderElement$InsertChild(((this.renderChildrenOffset + index) | 0), child.GetRenderElement(factory));
                            index = (index + 1) | 0;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$dispose();
                        }
                    }}

                return this.visualRenderElement;
            },
            CreateRenderElementContentOverride: function (factory) {
                return null;
            },
            OnVisualBoundsChanged: function () {
                //
            },
            OnVisualTransformChanged: function () {
                //
            },
            OnVisualTransformValueChanged: function (sender, e) {
                this.InvalidateHitTestBounds();

                this.OnVisualTransformChanged();
                Granular.Extensions.EventHandlerExtensions.Raise$2(this.VisualTransformChanged, this);
            },
            InvalidateVisualTransform: function () {
                this.VisualTransform = this.GetVisualTransformOverride();
            },
            GetVisualTransformOverride: function () {
                return System.Windows.Media.Matrix.Identity;
            },
            PointToRoot: function (point) {
                return System.Windows.Media.Matrix.op_Multiply$1(point, this.TransformToAncestor(null));
            },
            PointFromRoot: function (point) {
                return System.Windows.Media.Matrix.op_Multiply$1(point, this.TransformToAncestor(null).Inverse);
            },
            TransformToAncestor: function (ancestor) {
                var transformMatrix = !System.Windows.Media.MatrixExtensions.IsNullOrIdentity(this.VisualTransform) ? this.VisualTransform : System.Windows.Media.Matrix.Identity;
                var offsetMatrix = System.Windows.Point.op_Inequality(this.VisualOffset, System.Windows.Point.Zero) ? System.Windows.Media.Matrix.TranslationMatrix(this.VisualOffset.X, this.VisualOffset.Y) : System.Windows.Media.Matrix.Identity;
                var parentMatrix = this.VisualParent != null && !Bridge.referenceEquals(this.VisualParent, ancestor) ? this.VisualParent.TransformToAncestor(ancestor) : System.Windows.Media.Matrix.Identity;

                var value = System.Windows.Media.Matrix.op_Multiply(System.Windows.Media.Matrix.op_Multiply(transformMatrix, offsetMatrix), parentMatrix);
                return value;
            },
            InvalidateHitTestBounds: function () {
                if (!this.isHitTestBoundsValid) {
                    return;
                }

                this.isHitTestBoundsValid = false;
                if (this.VisualParent != null) {
                    this.VisualParent.InvalidateHitTestBounds();
                }
            },
            GetHitTestBounds: function () {
                if (!this.isHitTestBoundsValid) {
                    this.hitTestBounds = this.GetHitTestBoundsOverride();
                    this.isHitTestBoundsValid = true;
                }

                return this.hitTestBounds;
            },
            GetHitTestBoundsOverride: function () {
                var $t;
                var bounds = new System.Windows.Rect.$ctor3(this.VisualBounds.Size);

                if (!this.VisualClipToBounds) {
                    $t = Bridge.getEnumerator(this.VisualChildren);
                    try {
                        while ($t.moveNext()) {
                            var child = $t.Current;
                            bounds = System.Windows.RectExtensions.Union(bounds, child.GetHitTestBounds());
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$dispose();
                        }
                    }}

                return System.Windows.RectExtensions.AddOffset(System.Windows.RectExtensions.Transform(bounds, this.VisualTransform), this.VisualBounds.Location);
            },
            System$Windows$IContextElement$TrySetContextParent: function (contextParent) {
                return false;
            }
        }
    });

    Bridge.define("System.Windows.Freezable", {
        inherits: [System.Windows.DependencyObject,System.Windows.IResourceContainer,System.Windows.INotifyChanged,System.Windows.IContextElement],
        fields: {
            contextParent: null,
            changed: null,
            parentResourceContainer: null
        },
        events: {
            ContextParentChanged: null,
            ResourcesChanged: null
        },
        props: {
            ContextParent: {
                get: function () {
                    return this.contextParent;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.contextParent, value)) {
                        return;
                    }

                    if (this.contextParent != null) {
                        this.contextParent.System$Windows$IContextElement$removeContextParentChanged(Bridge.fn.cacheBind(this, this.OnContextParentAncestorChanged));
                    }

                    this.contextParent = value;

                    if (this.contextParent != null) {
                        this.contextParent.System$Windows$IContextElement$addContextParentChanged(Bridge.fn.cacheBind(this, this.OnContextParentAncestorChanged));
                    }

                    Granular.Extensions.EventHandlerExtensions.Raise$2(this.ContextParentChanged, this);
                }
            },
            IsFrozen: false,
            ParentResourceContainer: {
                get: function () {
                    return this.parentResourceContainer;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.parentResourceContainer, value)) {
                        return;
                    }

                    var oldParentResourceContainer = this.parentResourceContainer;

                    if (this.parentResourceContainer != null) {
                        this.parentResourceContainer.System$Windows$IResourceContainer$removeResourcesChanged(Bridge.fn.cacheBind(this, this.OnParentResourcesChanged));
                    }

                    this.parentResourceContainer = value;

                    if (this.parentResourceContainer != null) {
                        this.parentResourceContainer.System$Windows$IResourceContainer$addResourcesChanged(Bridge.fn.cacheBind(this, this.OnParentResourcesChanged));
                    }

                    if (oldParentResourceContainer != null && !oldParentResourceContainer.System$Windows$IResourceContainer$IsEmpty || this.parentResourceContainer != null && !this.parentResourceContainer.System$Windows$IResourceContainer$IsEmpty) {
                        Granular.Extensions.EventHandlerExtensions.Raise$4(Bridge.global.System.Windows.ResourcesChangedEventArgs, this.ResourcesChanged, this, System.Windows.ResourcesChangedEventArgs.Reset);
                    }
                }
            },
            System$Windows$IResourceContainer$IsEmpty: {
                get: function () {
                    return this.ParentResourceContainer == null || this.ParentResourceContainer.System$Windows$IResourceContainer$IsEmpty;
                }
            }
        },
        alias: [
            "addContextParentChanged", "System$Windows$IContextElement$addContextParentChanged",
            "removeContextParentChanged", "System$Windows$IContextElement$removeContextParentChanged",
            "ContextParent", "System$Windows$IContextElement$ContextParent",
            "addChanged", "System$Windows$INotifyChanged$addChanged",
            "removeChanged", "System$Windows$INotifyChanged$removeChanged",
            "addResourcesChanged", "System$Windows$IResourceContainer$addResourcesChanged",
            "removeResourcesChanged", "System$Windows$IResourceContainer$removeResourcesChanged",
            "TryGetResource", "System$Windows$IResourceContainer$TryGetResource",
            "TrySetContextParent", "System$Windows$IContextElement$TrySetContextParent"
        ],
        methods: {
            addChanged: function (value) {
                if (this.IsFrozen) {
                    return;
                }

                this.changed = Bridge.fn.combine(this.changed, value);
            },
            removeChanged: function (value) {
                if (this.IsFrozen) {
                    return;
                }

                this.changed = Bridge.fn.remove(this.changed, value);
            },
            OnParentResourcesChanged: function (sender, e) {
                Granular.Extensions.EventHandlerExtensions.Raise$4(Bridge.global.System.Windows.ResourcesChangedEventArgs, this.ResourcesChanged, this, e);
            },
            TryGetResource: function (resourceKey, value) {
                if (this.ParentResourceContainer != null) {
                    return this.ParentResourceContainer.System$Windows$IResourceContainer$TryGetResource(resourceKey, value);
                }

                value.v = null;
                return false;
            },
            Freeze: function () {
                this.IsFrozen = true;
                this.changed = null;
                this.ParentResourceContainer = null;
            },
            OnPropertyChanged: function (e) {
                this.VerifyNotFrozen$1(e.Property);

                if (!e.IsSubPropertyChange) {
                    if (Bridge.is(e.OldValue, System.Windows.IContextElement)) {
                        Bridge.cast(e.OldValue, System.Windows.IContextElement).System$Windows$IContextElement$TrySetContextParent(null);
                    }

                    if (Bridge.is(e.NewValue, System.Windows.IContextElement)) {
                        Bridge.cast(e.NewValue, System.Windows.IContextElement).System$Windows$IContextElement$TrySetContextParent(this);
                    }
                }

                this.RaiseChanged();
            },
            OnSubPropertyChanged: function (sender, e) {
                this.VerifyNotFrozen();

                this.RaiseChanged();
            },
            RaiseChanged: function () {
                Granular.Extensions.EventHandlerExtensions.Raise$2(this.changed, this);
            },
            TrySetContextParent: function (contextParent) {
                if (this.IsFrozen) {
                    return false;
                }

                this.ContextParent = contextParent;
                this.ParentResourceContainer = Bridge.as(contextParent, System.Windows.IResourceContainer);
                return true;
            },
            OnContextParentAncestorChanged: function (sender, e) {
                Granular.Extensions.EventHandlerExtensions.Raise$2(this.ContextParentChanged, this);
            },
            VerifyNotFrozen: function () {
                if (this.IsFrozen) {
                    throw new Granular.Exception("\"{0}\" is frozen and cannot be changed", [this]);
                }
            },
            VerifyNotFrozen$1: function (changedProperty) {
                if (this.IsFrozen) {
                    throw new Granular.Exception("\"{0}\" is frozen, property \"{1}\" cannot be changed", [this, changedProperty]);
                }
            }
        }
    });

    Bridge.define("System.Windows.Controls.ContentPresenter.DefaultContentTemplate", {
        inherits: [System.Windows.IFrameworkTemplate],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Controls.ContentPresenter.DefaultContentTemplate();
                }
            }
        },
        alias: [
            "Attach", "System$Windows$IFrameworkTemplate$Attach",
            "Detach", "System$Windows$IFrameworkTemplate$Detach"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                //
            }
        },
        methods: {
            Attach: function (element) {
                var $t;
                var textBlock = new System.Windows.Controls.TextBlock();
                textBlock.SetValue(System.Windows.Controls.TextBlock.TextProperty, ($t = new System.Windows.Data.Binding(), $t.Source = element, $t.Path = System.Windows.PropertyPath.FromDependencyProperty(System.Windows.Controls.ContentPresenter.ContentProperty), $t.Mode = System.Windows.Data.BindingMode.OneWay, $t.Converter = System.Windows.Controls.ContentPresenter.DefaultContentTemplate.ToStringConverter.Default, $t));

                element.TemplateChild = textBlock;
            },
            Detach: function (element) {
                element.TemplateChild = null;
            }
        }
    });

    Bridge.define("System.Windows.Controls.ContentPresenter.DefaultContentTemplate.ToStringConverter", {
        inherits: [System.Windows.Data.IValueConverter],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Controls.ContentPresenter.DefaultContentTemplate.ToStringConverter();
                }
            }
        },
        alias: [
            "Convert", "System$Windows$Data$IValueConverter$Convert",
            "ConvertBack", "System$Windows$Data$IValueConverter$ConvertBack"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                //
            }
        },
        methods: {
            Convert: function (value, targetType, parameter) {
                return value != null ? value.toString() : "";
            },
            ConvertBack: function (value, targetType, parameter) {
                return null;
            }
        }
    });

    Bridge.define("System.Windows.Controls.ContentPresenter.UIElementTemplate", {
        inherits: [System.Windows.IFrameworkTemplate],
        props: {
            Content: null
        },
        alias: [
            "Attach", "System$Windows$IFrameworkTemplate$Attach",
            "Detach", "System$Windows$IFrameworkTemplate$Detach"
        ],
        ctors: {
            ctor: function (content) {
                this.$initialize();
                this.Content = content;
            }
        },
        methods: {
            Attach: function (element) {
                element.TemplateChild = this.Content;
            },
            Detach: function (element) {
                element.TemplateChild = null;
            }
        }
    });

    Bridge.define("System.Windows.FrameworkTemplate", {
        inherits: [System.Windows.DependencyObject,System.Windows.IFrameworkTemplate],
        statics: {
            fields: {
                Empty: null
            },
            ctors: {
                init: function () {
                    this.Empty = new System.Windows.FrameworkTemplate.EmptyFrameworkTemplate();
                }
            }
        },
        props: {
            FrameworkElementFactory: null,
            Triggers: null
        },
        alias: [
            "Attach", "System$Windows$IFrameworkTemplate$Attach",
            "Detach", "System$Windows$IFrameworkTemplate$Detach"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.DependencyObject.ctor.call(this);
                this.Triggers = new (Granular.Collections.ObservableCollection$1(System.Windows.ITrigger)).ctor();
            }
        },
        methods: {
            Attach: function (element) {
                var $t;
                element.TemplateChild = this.CreateVisualTree(element);

                $t = Bridge.getEnumerator(this.Triggers);
                try {
                    while ($t.moveNext()) {
                        var trigger = $t.Current;
                        trigger.System$Windows$ITrigger$Attach(element, System.Windows.BaseValueSource.TemplateTrigger);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }},
            Detach: function (element) {
                var $t;
                $t = Bridge.getEnumerator(this.Triggers);
                try {
                    while ($t.moveNext()) {
                        var trigger = $t.Current;
                        trigger.System$Windows$ITrigger$Detach(element, System.Windows.BaseValueSource.TemplateTrigger);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                element.TemplateChild = null;
            },
            CreateVisualTree: function (templatedParent) {
                if (this.FrameworkElementFactory == null) {
                    throw new Granular.Exception("FrameworkTemplate is not initialized");
                }

                return this.FrameworkElementFactory.System$Windows$IFrameworkElementFactory$CreateElement(templatedParent);
            }
        }
    });

    Bridge.define("System.Windows.Controls.ItemContainerGenerator", {
        inherits: [System.Windows.Controls.Primitives.IItemContainerGenerator,System.IDisposable],
        fields: {
            host: null,
            generatedContainers: null
        },
        events: {
            ItemsChanged: null
        },
        props: {
            ItemsCount: {
                get: function () {
                    return this.host.System$Windows$Controls$Primitives$IGeneratorHost$View.Count;
                }
            }
        },
        alias: [
            "addItemsChanged", "System$Windows$Controls$Primitives$IItemContainerGenerator$addItemsChanged",
            "removeItemsChanged", "System$Windows$Controls$Primitives$IItemContainerGenerator$removeItemsChanged",
            "ItemsCount", "System$Windows$Controls$Primitives$IItemContainerGenerator$ItemsCount",
            "dispose", "System$IDisposable$dispose",
            "Generate", "System$Windows$Controls$Primitives$IItemContainerGenerator$Generate",
            "RemoveRange", "System$Windows$Controls$Primitives$IItemContainerGenerator$RemoveRange",
            "ContainerFromItem", "System$Windows$Controls$Primitives$IItemContainerGenerator$ContainerFromItem",
            "ItemFromContainer", "System$Windows$Controls$Primitives$IItemContainerGenerator$ItemFromContainer",
            "IndexFromContainer", "System$Windows$Controls$Primitives$IItemContainerGenerator$IndexFromContainer"
        ],
        ctors: {
            ctor: function (host) {
                this.$initialize();
                this.host = host;
                this.host.System$Windows$Controls$Primitives$IGeneratorHost$View.addCollectionChanged(Bridge.fn.cacheBind(this, this.OnViewCollectionChanged));

                this.generatedContainers = new (System.Collections.Generic.List$1(System.Windows.Controls.ItemContainerGenerator.GeneratedItemContainer)).ctor();
            }
        },
        methods: {
            dispose: function () {
                this.host.System$Windows$Controls$Primitives$IGeneratorHost$View.removeCollectionChanged(Bridge.fn.cacheBind(this, this.OnViewCollectionChanged));
                this.RemoveRange(0, this.ItemsCount);
            },
            OnViewCollectionChanged: function (sender, e) {
                var oldItemsCount = System.Linq.Enumerable.from(e.OldItems).count();
                var newItemsCount = System.Linq.Enumerable.from(e.NewItems).count();
                var oldContainersCount = System.Linq.Enumerable.from(this.generatedContainers).where(function (container) {
                        return container.Index >= e.OldStartingIndex && container.Index < ((e.OldStartingIndex + oldItemsCount) | 0);
                    }).count();

                if (e.Action === Granular.Collections.NotifyCollectionChangedAction.Add) {
                    this.ShiftGeneratedContainersIndex(e.NewStartingIndex, newItemsCount);
                }

                if (e.Action === Granular.Collections.NotifyCollectionChangedAction.Remove) {
                    this.RemoveRange(e.OldStartingIndex, oldItemsCount);
                    this.ShiftGeneratedContainersIndex(e.OldStartingIndex, ((-oldItemsCount) | 0));
                }

                if (e.Action === Granular.Collections.NotifyCollectionChangedAction.Move) {
                    this.SwitchGeneratedContainersIndex(e.OldStartingIndex, e.NewStartingIndex, newItemsCount);
                }

                if (e.Action === Granular.Collections.NotifyCollectionChangedAction.Replace) {
                    this.RefershRange(e.NewStartingIndex, newItemsCount);
                }

                if (e.Action === Granular.Collections.NotifyCollectionChangedAction.Reset) {
                    this.RemoveRange(0, this.ItemsCount);
                }
                Granular.Extensions.EventHandlerExtensions.Raise$4(Bridge.global.System.Windows.Controls.Primitives.ItemsChangedEventArgs, this.ItemsChanged, this, new System.Windows.Controls.Primitives.ItemsChangedEventArgs(e.Action, e.OldStartingIndex, e.NewStartingIndex, newItemsCount, oldContainersCount));
            },
            Generate: function (index) {
                var container = System.Linq.Enumerable.from(this.generatedContainers).firstOrDefault(function (c) {
                        return c.Index === index;
                    }, null);

                if (container == null) {
                    container = new System.Windows.Controls.ItemContainerGenerator.GeneratedItemContainer(this.host.System$Windows$Controls$Primitives$IGeneratorHost$GetContainerForItem(this.host.System$Windows$Controls$Primitives$IGeneratorHost$View.getItem(index)), this.host.System$Windows$Controls$Primitives$IGeneratorHost$View.getItem(index), index);
                    this.host.System$Windows$Controls$Primitives$IGeneratorHost$PrepareContainerForItem(container.Item, container.Container);
                    this.generatedContainers.add(container);
                }

                return container.Container;
            },
            RemoveRange: function (startIndex, count) {
                var i = 0;

                while (i < this.generatedContainers.Count) {
                    var container = this.generatedContainers.getItem(i);

                    if (container.Index >= startIndex && container.Index < ((startIndex + count) | 0)) {
                        this.Remove(container);
                        continue;
                    }

                    i = (i + 1) | 0;
                }
            },
            Remove: function (container) {
                this.generatedContainers.remove(container);
                this.host.System$Windows$Controls$Primitives$IGeneratorHost$ClearContainerForItem(container.Item, container.Container);
            },
            RefershRange: function (startIndex, count) {
                var $t;
                $t = Bridge.getEnumerator(this.generatedContainers);
                try {
                    while ($t.moveNext()) {
                        var container = $t.Current;
                        if (container.Index >= startIndex && container.Index < ((startIndex + count) | 0)) {
                            this.Refersh(container);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }},
            Refersh: function (container) {
                this.host.System$Windows$Controls$Primitives$IGeneratorHost$ClearContainerForItem(container.Item, container.Container);

                container.Item = this.host.System$Windows$Controls$Primitives$IGeneratorHost$View.getItem(container.Index);
                container.Container = this.host.System$Windows$Controls$Primitives$IGeneratorHost$GetContainerForItem(this.host.System$Windows$Controls$Primitives$IGeneratorHost$View.getItem(container.Index));

                this.host.System$Windows$Controls$Primitives$IGeneratorHost$PrepareContainerForItem(container.Item, container.Container);
            },
            ContainerFromItem: function (item) {
                var generatedItemContainer = System.Linq.Enumerable.from(this.generatedContainers).firstOrDefault(function (c) {
                        return Bridge.referenceEquals(c.Item, item);
                    }, null);
                return generatedItemContainer != null ? generatedItemContainer.Container : null;
            },
            ItemFromContainer: function (container) {
                var generatedItemContainer = System.Linq.Enumerable.from(this.generatedContainers).firstOrDefault(function (c) {
                        return Bridge.referenceEquals(c.Container, container);
                    }, null);
                return generatedItemContainer != null ? generatedItemContainer.Item : null;
            },
            IndexFromContainer: function (container) {
                var generatedItemContainer = System.Linq.Enumerable.from(this.generatedContainers).firstOrDefault(function (c) {
                        return Bridge.referenceEquals(c.Container, container);
                    }, null);
                return generatedItemContainer != null ? generatedItemContainer.Index : -1;
            },
            ShiftGeneratedContainersIndex: function (startIndex, offset) {
                var $t;
                $t = Bridge.getEnumerator(this.generatedContainers);
                try {
                    while ($t.moveNext()) {
                        var container = $t.Current;
                        if (container.Index >= startIndex) {
                            container.Index = (container.Index + offset) | 0;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }},
            SwitchGeneratedContainersIndex: function (sourceIndex, targetIndex, count) {
                var $t;
                var offset = (targetIndex - sourceIndex) | 0;

                $t = Bridge.getEnumerator(this.generatedContainers);
                try {
                    while ($t.moveNext()) {
                        var container = $t.Current;
                        if (container.Index >= sourceIndex && container.Index < ((sourceIndex + count) | 0)) {
                            container.Index = (container.Index + offset) | 0;
                        } else if (container.Index >= sourceIndex && container.Index < targetIndex || container.Index >= targetIndex && container.Index < sourceIndex) {
                            container.Index = (container.Index - offset) | 0;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }}
        }
    });

    Bridge.define("System.Windows.Controls.ItemsControl.DefaultItemsPanelTemplate", {
        inherits: [System.Windows.IFrameworkTemplate],
        alias: [
            "Attach", "System$Windows$IFrameworkTemplate$Attach",
            "Detach", "System$Windows$IFrameworkTemplate$Detach"
        ],
        methods: {
            Attach: function (element) {
                element.TemplateChild = new System.Windows.Controls.StackPanel();
            },
            Detach: function (element) {
                element.TemplateChild = null;
            }
        }
    });

    Bridge.define("System.Windows.Controls.ListBox.ExtendedSelectionBehavior", {
        inherits: [System.Windows.Controls.ListBox.ISelectionBehavior],
        fields: {
            listBox: null
        },
        alias: [
            "SetClickSelection", "System$Windows$Controls$ListBox$ISelectionBehavior$SetClickSelection",
            "SetFocusChangeSelection", "System$Windows$Controls$ListBox$ISelectionBehavior$SetFocusChangeSelection"
        ],
        ctors: {
            ctor: function (listBox) {
                this.$initialize();
                this.listBox = listBox;
            }
        },
        methods: {
            SetClickSelection: function (item, modifiers) {
                if (modifiers === System.Windows.Input.ModifierKeys.None) {
                    this.listBox.SetSelectionAnchor(item);
                    this.listBox.SetSingleSelection(item);
                } else if (modifiers === System.Windows.Input.ModifierKeys.Shift) {
                    this.listBox.SetRangeSelection(item);
                } else if (modifiers === System.Windows.Input.ModifierKeys.Control) {
                    this.listBox.SetSelectionAnchor(item);
                    this.listBox.ToggleSelection(item);
                }
            },
            SetFocusChangeSelection: function (item, modifiers) {
                if (modifiers === System.Windows.Input.ModifierKeys.None) {
                    this.listBox.SetSelectionAnchor(item);
                    this.listBox.SetSingleSelection(item);
                } else if (modifiers === System.Windows.Input.ModifierKeys.Shift) {
                    this.listBox.SetRangeSelection(item);
                }
            }
        }
    });

    Bridge.define("System.Windows.Controls.ListBox.MultipleSelectionBehavior", {
        inherits: [System.Windows.Controls.ListBox.ISelectionBehavior],
        fields: {
            listBox: null
        },
        alias: [
            "SetClickSelection", "System$Windows$Controls$ListBox$ISelectionBehavior$SetClickSelection",
            "SetFocusChangeSelection", "System$Windows$Controls$ListBox$ISelectionBehavior$SetFocusChangeSelection"
        ],
        ctors: {
            ctor: function (listBox) {
                this.$initialize();
                this.listBox = listBox;
            }
        },
        methods: {
            SetClickSelection: function (item, modifiers) {
                this.listBox.SetSelectionAnchor(item);
                this.listBox.ToggleSelection(item);
            },
            SetFocusChangeSelection: function (item, modifiers) {
                //
            }
        }
    });

    Bridge.define("System.Windows.Controls.ListBox.SingleSelectionBehavior", {
        inherits: [System.Windows.Controls.ListBox.ISelectionBehavior],
        fields: {
            listBox: null
        },
        alias: [
            "SetClickSelection", "System$Windows$Controls$ListBox$ISelectionBehavior$SetClickSelection",
            "SetFocusChangeSelection", "System$Windows$Controls$ListBox$ISelectionBehavior$SetFocusChangeSelection"
        ],
        ctors: {
            ctor: function (listBox) {
                this.$initialize();
                this.listBox = listBox;
            }
        },
        methods: {
            SetClickSelection: function (item, modifiers) {
                if (modifiers !== System.Windows.Input.ModifierKeys.Control) {
                    this.listBox.SetSingleSelection(item);
                } else {
                    this.listBox.SetSelectionAnchor(item);
                    this.listBox.ToggleSingleSelection(item);
                }
            },
            SetFocusChangeSelection: function (item, modifiers) {
                if (modifiers !== System.Windows.Input.ModifierKeys.Control) {
                    this.listBox.SetSingleSelection(item);
                }
            }
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.DragCompletedEventArgs", {
        inherits: [System.Windows.RoutedEventArgs],
        props: {
            IsCanceled: false
        },
        ctors: {
            ctor: function (routedEvent, originalSource, isCanceled) {
                this.$initialize();
                System.Windows.RoutedEventArgs.ctor.call(this, routedEvent, originalSource);
                this.IsCanceled = isCanceled;
            }
        },
        methods: {
            InvokeEventHandler: function (handler, target) {
                if (Bridge.is(handler, Function)) {
                    handler(target, this);
                } else {
                    System.Windows.RoutedEventArgs.prototype.InvokeEventHandler.call(this, handler, target);
                }
            }
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.DragDeltaEventArgs", {
        inherits: [System.Windows.RoutedEventArgs],
        props: {
            Delta: null
        },
        ctors: {
            ctor: function (routedEvent, originalSource, delta) {
                this.$initialize();
                System.Windows.RoutedEventArgs.ctor.call(this, routedEvent, originalSource);
                this.Delta = delta;
            }
        },
        methods: {
            InvokeEventHandler: function (handler, target) {
                if (Bridge.is(handler, Function)) {
                    handler(target, this);
                } else {
                    System.Windows.RoutedEventArgs.prototype.InvokeEventHandler.call(this, handler, target);
                }
            }
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.DragStartedEventArgs", {
        inherits: [System.Windows.RoutedEventArgs],
        ctors: {
            ctor: function (routedEvent, originalSource) {
                this.$initialize();
                System.Windows.RoutedEventArgs.ctor.call(this, routedEvent, originalSource);
                //
            }
        },
        methods: {
            InvokeEventHandler: function (handler, target) {
                if (Bridge.is(handler, Function)) {
                    handler(target, this);
                } else {
                    System.Windows.RoutedEventArgs.prototype.InvokeEventHandler.call(this, handler, target);
                }
            }
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.Placement.AbsolutePlacement", {
        inherits: [System.Windows.Controls.Primitives.Placement.PlacementBase],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Controls.Primitives.Placement.AbsolutePlacement();
                }
            }
        },
        methods: {
            GetTargetArea: function (targetObjectRect, placementRectangle, mouseBounds, containerBounds) {
                return !placementRectangle.IsEmpty ? System.Windows.RectExtensions.AddOffset(placementRectangle, containerBounds.Location) : containerBounds;
            }
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.Placement.AbsolutePointPlacement", {
        inherits: [System.Windows.Controls.Primitives.Placement.PlacementBase],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Controls.Primitives.Placement.AbsolutePointPlacement();
                }
            }
        },
        methods: {
            GetTargetArea: function (targetObjectRect, placementRectangle, mouseBounds, containerBounds) {
                return !placementRectangle.IsEmpty ? System.Windows.RectExtensions.AddOffset(placementRectangle, containerBounds.Location) : containerBounds;
            },
            GetRightEdgePopupAlignmentPoint: function (popupSize, currentAlignmentPoint) {
                return new System.Windows.Point.$ctor1(popupSize.Width, currentAlignmentPoint.Y);
            },
            GetBottomEdgePopupAlignmentPoint: function (popupSize, currentAlignmentPoint) {
                return new System.Windows.Point.$ctor1(currentAlignmentPoint.X, popupSize.Height);
            }
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.Placement.BottomPlacement", {
        inherits: [System.Windows.Controls.Primitives.Placement.PlacementBase],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Controls.Primitives.Placement.BottomPlacement();
                }
            }
        },
        methods: {
            GetTargetOrigin: function (targetArea) {
                return System.Windows.RectExtensions.GetBottomLeft(targetArea);
            },
            GetBottomEdgePopupAlignmentPoint: function (popupSize, currentAlignmentPoint) {
                return new System.Windows.Point.$ctor1(currentAlignmentPoint.X, popupSize.Height);
            },
            GetBottomEdgeTargetOrigin: function (targetArea, currentTargetOrigin) {
                return new System.Windows.Point.$ctor1(currentTargetOrigin.X, targetArea.Top);
            }
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.Placement.CenterPlacement", {
        inherits: [System.Windows.Controls.Primitives.Placement.PlacementBase],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Controls.Primitives.Placement.CenterPlacement();
                }
            }
        },
        methods: {
            GetTargetOrigin: function (targetArea) {
                return new System.Windows.Point.$ctor1(targetArea.Left + targetArea.Width / 2, targetArea.Top + targetArea.Height / 2);
            },
            GetPopupAlignmentPoint: function (popupSize) {
                return new System.Windows.Point.$ctor1(popupSize.Width / 2, popupSize.Height / 2);
            }
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.Placement.LeftPlacement", {
        inherits: [System.Windows.Controls.Primitives.Placement.PlacementBase],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Controls.Primitives.Placement.LeftPlacement();
                }
            }
        },
        methods: {
            GetPopupAlignmentPoint: function (popupSize) {
                return System.Windows.Controls.Primitives.Placement.GetTopRight(popupSize);
            },
            GetLeftEdgeTargetOrigin: function (targetArea, currentTargetOrigin) {
                return new System.Windows.Point.$ctor1(targetArea.Right, currentTargetOrigin.Y);
            },
            GetLeftEdgePopupAlignmentPoint: function (popupSize, currentAlignmentPoint) {
                return new System.Windows.Point.$ctor1(0, currentAlignmentPoint.Y);
            }
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.Placement.MousePlacement", {
        inherits: [System.Windows.Controls.Primitives.Placement.PlacementBase],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Controls.Primitives.Placement.MousePlacement();
                }
            }
        },
        methods: {
            GetTargetArea: function (targetObjectRect, placementRectangle, mouseBounds, containerBounds) {
                return mouseBounds;
            },
            GetTargetOrigin: function (targetArea) {
                return System.Windows.RectExtensions.GetBottomLeft(targetArea);
            },
            GetBottomEdgeTargetOrigin: function (targetArea, currentTargetOrigin) {
                return new System.Windows.Point.$ctor1(currentTargetOrigin.X, targetArea.Top);
            },
            GetBottomEdgePopupAlignmentPoint: function (popupSize, currentAlignmentPoint) {
                return new System.Windows.Point.$ctor1(currentAlignmentPoint.X, popupSize.Height);
            }
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.Placement.MousePointPlacement", {
        inherits: [System.Windows.Controls.Primitives.Placement.PlacementBase],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Controls.Primitives.Placement.MousePointPlacement();
                }
            }
        },
        methods: {
            GetTargetArea: function (targetObjectRect, placementRectangle, mouseBounds, containerBounds) {
                return mouseBounds;
            },
            GetBottomEdgePopupAlignmentPoint: function (popupSize, currentAlignmentPoint) {
                return new System.Windows.Point.$ctor1(currentAlignmentPoint.X, popupSize.Height);
            },
            GetRightEdgePopupAlignmentPoint: function (popupSize, currentAlignmentPoint) {
                return new System.Windows.Point.$ctor1(popupSize.Width, currentAlignmentPoint.Y);
            }
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.Placement.RelativePlacement", {
        inherits: [System.Windows.Controls.Primitives.Placement.PlacementBase],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Controls.Primitives.Placement.RelativePlacement();
                }
            }
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.Placement.RelativePointPlacement", {
        inherits: [System.Windows.Controls.Primitives.Placement.PlacementBase],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Controls.Primitives.Placement.RelativePointPlacement();
                }
            }
        },
        methods: {
            GetBottomEdgePopupAlignmentPoint: function (popupSize, currentAlignmentPoint) {
                return new System.Windows.Point.$ctor1(currentAlignmentPoint.X, popupSize.Height);
            },
            GetRightEdgePopupAlignmentPoint: function (popupSize, currentAlignmentPoint) {
                return new System.Windows.Point.$ctor1(popupSize.Width, currentAlignmentPoint.Y);
            }
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.Placement.RightPlacement", {
        inherits: [System.Windows.Controls.Primitives.Placement.PlacementBase],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Controls.Primitives.Placement.RightPlacement();
                }
            }
        },
        methods: {
            GetTargetOrigin: function (targetArea) {
                return System.Windows.RectExtensions.GetTopRight(targetArea);
            },
            GetRightEdgeTargetOrigin: function (targetArea, currentTargetOrigin) {
                return new System.Windows.Point.$ctor1(targetArea.Left, currentTargetOrigin.Y);
            },
            GetRightEdgePopupAlignmentPoint: function (popupSize, currentAlignmentPoint) {
                return new System.Windows.Point.$ctor1(popupSize.Width, currentAlignmentPoint.Y);
            }
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.Placement.TopPlacement", {
        inherits: [System.Windows.Controls.Primitives.Placement.PlacementBase],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Controls.Primitives.Placement.TopPlacement();
                }
            }
        },
        methods: {
            GetPopupAlignmentPoint: function (popupSize) {
                return System.Windows.Controls.Primitives.Placement.GetBottomLeft(popupSize);
            },
            GetTopEdgeTargetOrigin: function (targetArea, currentTargetOrigin) {
                return new System.Windows.Point.$ctor1(currentTargetOrigin.X, targetArea.Bottom);
            },
            GetTopEdgePopupAlignmentPoint: function (popupSize, currentAlignmentPoint) {
                return new System.Windows.Point.$ctor1(currentAlignmentPoint.X, 0);
            }
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.ScrollEventArgs", {
        inherits: [System.Windows.RoutedEventArgs],
        props: {
            NewValue: 0,
            ScrollEventType: 0
        },
        ctors: {
            ctor: function (routedEvent, originalSource, scrollEventType, newValue) {
                this.$initialize();
                System.Windows.RoutedEventArgs.ctor.call(this, routedEvent, originalSource);
                this.ScrollEventType = scrollEventType;
                this.NewValue = newValue;
            }
        },
        methods: {
            InvokeEventHandler: function (handler, target) {
                if (Bridge.is(handler, Function)) {
                    handler(target, this);
                } else {
                    System.Windows.RoutedEventArgs.prototype.InvokeEventHandler.call(this, handler, target);
                }
            }
        }
    });

    Bridge.define("System.Windows.Controls.ScrollChangedEventArgs", {
        inherits: [System.Windows.RoutedEventArgs],
        props: {
            Offset: null,
            OffsetChange: null,
            Extent: null,
            ExtentChange: null,
            Viewport: null,
            ViewportChange: null
        },
        ctors: {
            ctor: function (routedEvent, originalSource, offset, offsetChange, extent, extentChange, viewport, viewportChange) {
                this.$initialize();
                System.Windows.RoutedEventArgs.ctor.call(this, routedEvent, originalSource);
                this.Offset = offset;
                this.OffsetChange = offsetChange;
                this.Extent = extent;
                this.ExtentChange = extentChange;
                this.Viewport = viewport;
                this.ViewportChange = viewportChange;
            }
        },
        methods: {
            InvokeEventHandler: function (handler, target) {
                if (Bridge.is(handler, Function)) {
                    handler(target, this);
                } else {
                    System.Windows.RoutedEventArgs.prototype.InvokeEventHandler.call(this, handler, target);
                }
            }
        }
    });

    Bridge.define("System.Windows.Controls.ScrollContentPresenter.InnerScrollInfo", {
        inherits: [System.Windows.Controls.Primitives.IScrollInfo],
        props: {
            ExtentSize: null,
            ViewportSize: null,
            CanHorizontallyScroll: false,
            CanVerticallyScroll: false,
            Offset: null
        },
        alias: [
            "ExtentSize", "System$Windows$Controls$Primitives$IScrollInfo$ExtentSize",
            "ViewportSize", "System$Windows$Controls$Primitives$IScrollInfo$ViewportSize",
            "CanHorizontallyScroll", "System$Windows$Controls$Primitives$IScrollInfo$CanHorizontallyScroll",
            "CanVerticallyScroll", "System$Windows$Controls$Primitives$IScrollInfo$CanVerticallyScroll",
            "Offset", "System$Windows$Controls$Primitives$IScrollInfo$Offset"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                this.ExtentSize = System.Windows.Size.Zero;
                this.ViewportSize = System.Windows.Size.Zero;
                this.Offset = System.Windows.Point.Zero;
            }
        }
    });

    Bridge.define("System.Windows.Controls.SelectionChangedEventArgs", {
        inherits: [System.Windows.RoutedEventArgs],
        props: {
            AddedItems: null,
            RemovedItems: null
        },
        ctors: {
            ctor: function (routedEvent, originalSource, removedItems, addedItems) {
                this.$initialize();
                System.Windows.RoutedEventArgs.ctor.call(this, routedEvent, originalSource);
                this.RemovedItems = removedItems;
                this.AddedItems = addedItems;
            }
        },
        methods: {
            InvokeEventHandler: function (handler, target) {
                if (Bridge.is(handler, Function)) {
                    handler(target, this);
                } else {
                    System.Windows.RoutedEventArgs.prototype.InvokeEventHandler.call(this, handler, target);
                }
            }
        }
    });

    Bridge.define("System.Windows.Controls.SelectionGroup$1", function (T) { return {
        inherits: [System.Windows.Controls.ISelectionGroup$1(T)],
        fields: {
            selection: Bridge.getDefaultValue(T)
        },
        events: {
            SelectionChanged: null
        },
        props: {
            Selection: {
                get: function () {
                    return this.selection;
                },
                set: function (value) {
                    if (Granular.Compatibility.EqualityComparer.Default.equals2(this.selection, value)) {
                        return;
                    }

                    this.selection = value;
                    Granular.Extensions.EventHandlerExtensions.Raise$2(this.SelectionChanged, this);
                }
            }
        },
        alias: [
            "addSelectionChanged", "System$Windows$Controls$ISelectionGroup$1$" + Bridge.getTypeAlias(T) + "$addSelectionChanged",
            "removeSelectionChanged", "System$Windows$Controls$ISelectionGroup$1$" + Bridge.getTypeAlias(T) + "$removeSelectionChanged",
            "Selection", "System$Windows$Controls$ISelectionGroup$1$" + Bridge.getTypeAlias(T) + "$Selection"
        ]
    }; });

    Bridge.define("System.Windows.Controls.SelectionGroupScope$1", function (T) { return {
        inherits: [System.Windows.Controls.ISelectionGroupScope$1(T)],
        fields: {
            groups: null
        },
        alias: ["GetSelectionGroup", "System$Windows$Controls$ISelectionGroupScope$1$" + Bridge.getTypeAlias(T) + "$GetSelectionGroup"],
        ctors: {
            ctor: function () {
                this.$initialize();
                this.groups = new (System.Collections.Generic.Dictionary$2(System.String,System.Windows.Controls.ISelectionGroup$1(T)))();
            }
        },
        methods: {
            GetSelectionGroup: function (groupName) {
                var group = { };

                if (!this.groups.tryGetValue(groupName, group)) {
                    group.v = new (System.Windows.Controls.SelectionGroup$1(T))();
                    this.groups.add(groupName, group.v);
                }

                return group.v;
            }
        }
    }; });

    Bridge.define("System.Windows.Controls.TextChangedEventArgs", {
        inherits: [System.Windows.RoutedEventArgs],
        ctors: {
            ctor: function (routedEvent, originalSource) {
                this.$initialize();
                System.Windows.RoutedEventArgs.ctor.call(this, routedEvent, originalSource);
                //
            }
        },
        methods: {
            InvokeEventHandler: function (handler, target) {
                if (Bridge.is(handler, Function)) {
                    handler(target, this);
                } else {
                    System.Windows.RoutedEventArgs.prototype.InvokeEventHandler.call(this, handler, target);
                }
            }
        }
    });

    Bridge.define("System.Windows.CornerRadiusTypeConverter", {
        inherits: [System.Windows.Markup.ITypeConverter],
        alias: ["ConvertFrom", "System$Windows$Markup$ITypeConverter$ConvertFrom"],
        methods: {
            ConvertFrom: function (namespaces, sourceUri, value) {
                return System.Windows.CornerRadius.Parse(value.toString().trim());
            }
        }
    });

    Bridge.define("System.Windows.Data.Binding", {
        inherits: [System.Windows.Markup.IMarkupExtension,System.Windows.IExpressionProvider],
        statics: {
            methods: {
                GetStringFormatConverter: function (format) {
                    return !Granular.Extensions.StringExtensions.IsNullOrEmpty(format) ? new System.Windows.Data.Binding.StringFormatConverter(format) : null;
                }
            }
        },
        props: {
            Path: null,
            Source: null,
            RelativeSource: null,
            ElementName: null,
            Mode: 0,
            UpdateSourceTrigger: 0,
            StringFormat: null,
            Converter: null,
            ConverterParameter: null,
            FallbackValue: null,
            TargetNullValue: null
        },
        alias: [
            "ProvideValue", "System$Windows$Markup$IMarkupExtension$ProvideValue",
            "CreateExpression", "System$Windows$IExpressionProvider$CreateExpression"
        ],
        methods: {
            ProvideValue: function (context) {
                return this;
            },
            CreateExpression: function (dependencyObject, dependencyProperty) {
                return new System.Windows.Data.BindingExpression(dependencyObject, dependencyProperty, this.Path, this.Source, this.RelativeSource, this.ElementName, this.Mode, this.UpdateSourceTrigger, this.Converter || System.Windows.Data.Binding.GetStringFormatConverter(this.StringFormat), this.ConverterParameter, this.FallbackValue, this.TargetNullValue);
            }
        }
    });

    Bridge.define("System.Windows.Data.Binding.StringFormatConverter", {
        inherits: [System.Windows.Data.IValueConverter],
        fields: {
            format: null
        },
        alias: [
            "Convert", "System$Windows$Data$IValueConverter$Convert",
            "ConvertBack", "System$Windows$Data$IValueConverter$ConvertBack"
        ],
        ctors: {
            ctor: function (format) {
                this.$initialize();
                this.format = format;
            }
        },
        methods: {
            Convert: function (value, targetType, parameter) {
                return System.String.format(this.format, value, parameter);
            },
            ConvertBack: function (value, targetType, parameter) {
                return null;
            }
        }
    });

    Bridge.define("System.Windows.IExpression", {
        inherits: [System.Windows.Data.IObservableValue],
        $kind: "interface"
    });

    Bridge.define("System.Windows.Data.IPropertyObserver", {
        inherits: [System.Windows.Data.IObservableValue],
        $kind: "interface"
    });

    Bridge.define("System.Windows.Data.ContextSourceObserver", {
        inherits: [System.Windows.Data.IObservableValue,System.IDisposable],
        fields: {
            target: null,
            observableValue: null
        },
        events: {
            ValueChanged: null
        },
        props: {
            Value: {
                get: function () {
                    return this.observableValue.Value;
                }
            }
        },
        alias: [
            "addValueChanged", "System$Windows$Data$IObservableValue$addValueChanged",
            "removeValueChanged", "System$Windows$Data$IObservableValue$removeValueChanged",
            "Value", "System$Windows$Data$IObservableValue$Value",
            "dispose", "System$IDisposable$dispose"
        ],
        ctors: {
            ctor: function (target, baseValue) {
                this.$initialize();
                this.target = target;

                this.observableValue = new System.Windows.Data.ObservableValue.$ctor1(baseValue);
                this.observableValue.addValueChanged(Bridge.fn.bind(this, $asm.$.System.Windows.Data.ContextSourceObserver.f1));

                if (Bridge.is(target, System.Windows.IContextElement)) {
                    Bridge.cast(target, System.Windows.IContextElement).System$Windows$IContextElement$addContextParentChanged(Bridge.fn.cacheBind(this, this.OnTargetContextParentChanged));
                }
            }
        },
        methods: {
            dispose: function () {
                if (Bridge.is(this.target, System.Windows.IContextElement)) {
                    Bridge.cast(this.target, System.Windows.IContextElement).System$Windows$IContextElement$removeContextParentChanged(Bridge.fn.cacheBind(this, this.OnTargetContextParentChanged));
                }
            },
            OnTargetContextParentChanged: function (sender, e) {
                this.observableValue.BaseValue = this.GetBaseValue();
            }
        }
    });

    Bridge.ns("System.Windows.Data.ContextSourceObserver", $asm.$);

    Bridge.apply($asm.$.System.Windows.Data.ContextSourceObserver, {
        f1: function (sender, oldValue, newValue) {
            System.Windows.Data.ObservableValueChangedEventHandlerExtensions.Raise(this.ValueChanged, this, oldValue, newValue);
        }
    });

    Bridge.define("System.Windows.Data.DataContextSourceObserver", {
        inherits: [System.Windows.Data.IObservableValue,System.IDisposable],
        statics: {
            methods: {
                GetFrameworkElementAncestor: function (target) {
                    while (!(Bridge.is(target, System.Windows.FrameworkElement)) && Bridge.is(target, System.Windows.IContextElement)) {
                        target = Bridge.cast(target, System.Windows.IContextElement).System$Windows$IContextElement$ContextParent;
                    }

                    return Bridge.as(target, System.Windows.FrameworkElement);
                }
            }
        },
        fields: {
            target: null,
            frameworkElementValue: null,
            dataContextValue: null
        },
        events: {
            ValueChanged: null
        },
        props: {
            Value: {
                get: function () {
                    return this.dataContextValue.Value;
                }
            }
        },
        alias: [
            "addValueChanged", "System$Windows$Data$IObservableValue$addValueChanged",
            "removeValueChanged", "System$Windows$Data$IObservableValue$removeValueChanged",
            "Value", "System$Windows$Data$IObservableValue$Value",
            "dispose", "System$IDisposable$dispose"
        ],
        ctors: {
            ctor: function (target) {
                this.$initialize();
                this.target = target;

                this.frameworkElementValue = new System.Windows.Data.ObservableValue.$ctor1(System.Windows.Data.DataContextSourceObserver.GetFrameworkElementAncestor(target));
                this.frameworkElementValue.addValueChanged(Bridge.fn.bind(this, $asm.$.System.Windows.Data.DataContextSourceObserver.f1));

                this.dataContextValue = new System.Windows.Data.DependencyPropertyObserver(System.Windows.FrameworkElement.DataContextProperty);
                this.dataContextValue.SetBaseValue(this.frameworkElementValue.Value);
                this.dataContextValue.addValueChanged(Bridge.fn.bind(this, $asm.$.System.Windows.Data.DataContextSourceObserver.f2));

                if (Bridge.is(target, System.Windows.IContextElement)) {
                    Bridge.cast(target, System.Windows.IContextElement).System$Windows$IContextElement$addContextParentChanged(Bridge.fn.cacheBind(this, this.OnTargetContextParentChanged));
                }
            }
        },
        methods: {
            dispose: function () {
                if (Bridge.is(this.target, System.Windows.IContextElement)) {
                    Bridge.cast(this.target, System.Windows.IContextElement).System$Windows$IContextElement$removeContextParentChanged(Bridge.fn.cacheBind(this, this.OnTargetContextParentChanged));
                }

                this.dataContextValue.dispose();
            },
            OnTargetContextParentChanged: function (sender, e) {
                this.frameworkElementValue.BaseValue = System.Windows.Data.DataContextSourceObserver.GetFrameworkElementAncestor(this.target);
            }
        }
    });

    Bridge.ns("System.Windows.Data.DataContextSourceObserver", $asm.$);

    Bridge.apply($asm.$.System.Windows.Data.DataContextSourceObserver, {
        f1: function (sender, oldValue, newValue) {
            this.dataContextValue.SetBaseValue(newValue);
        },
        f2: function (sender, oldValue, newValue) {
            System.Windows.Data.ObservableValueChangedEventHandlerExtensions.Raise(this.ValueChanged, this, oldValue, newValue);
        }
    });

    Bridge.define("System.Windows.Data.ObservableExpression", {
        inherits: [System.Windows.Data.IObservableValue,System.IDisposable],
        fields: {
            observableValue: null,
            baseObserverValueType: null,
            baseObserver: null,
            delegateObserver: null,
            propertyPathElement: null
        },
        events: {
            ValueChanged: null
        },
        props: {
            Value: {
                get: function () {
                    return this.observableValue.Value;
                }
            },
            ValueType: null
        },
        alias: [
            "addValueChanged", "System$Windows$Data$IObservableValue$addValueChanged",
            "removeValueChanged", "System$Windows$Data$IObservableValue$removeValueChanged",
            "Value", "System$Windows$Data$IObservableValue$Value",
            "dispose", "System$IDisposable$dispose"
        ],
        ctors: {
            $ctor2: function (propertyPath) {
                System.Windows.Data.ObservableExpression.$ctor1.call(this, null, System.Windows.PropertyPath.Parse(propertyPath));
                //
            },
            ctor: function (baseValue, propertyPath) {
                System.Windows.Data.ObservableExpression.$ctor1.call(this, baseValue, System.Windows.PropertyPath.Parse(propertyPath));
                //
            },
            $ctor3: function (propertyPath) {
                System.Windows.Data.ObservableExpression.$ctor1.call(this, null, propertyPath);
                //
            },
            $ctor1: function (baseValue, propertyPath) {
                this.$initialize();
                this.observableValue = new System.Windows.Data.ObservableValue.ctor();
                this.observableValue.addValueChanged(Bridge.fn.bind(this, $asm.$.System.Windows.Data.ObservableExpression.f1));

                if (propertyPath.IsEmpty) {
                    this.observableValue.BaseValue = baseValue;
                    this.ValueType = baseValue != null ? Bridge.getType(baseValue) : null;
                } else {
                    this.propertyPathElement = System.Linq.Enumerable.from(propertyPath.Elements).last();

                    this.baseObserver = new System.Windows.Data.ObservableExpression.$ctor1(baseValue, System.Windows.PropertyPathExtensions.GetBasePropertyPath(propertyPath));
                    this.baseObserver.addValueChanged(Bridge.fn.bind(this, $asm.$.System.Windows.Data.ObservableExpression.f2));

                    this.SetDelegateObserverBaseValue();
                }
            }
        },
        methods: {
            SetBaseValue: function (baseValue) {
                if (this.baseObserver != null) {
                    this.baseObserver.SetBaseValue(baseValue);
                } else {
                    this.observableValue.BaseValue = baseValue;
                    this.ValueType = baseValue != null ? Bridge.getType(baseValue) : null;
                }
            },
            TrySetValue: function (value) {
                return this.delegateObserver != null && (Granular.Compatibility.EqualityComparer.Default.equals2(this.delegateObserver.System$Windows$Data$IObservableValue$Value, value) || this.delegateObserver.System$Windows$Data$IPropertyObserver$TrySetValue(value));
            },
            SetDelegateObserverBaseValue: function () {
                var baseValue = this.baseObserver.Value;

                if (System.Windows.Data.ObservableValue.IsNullOrUnset(baseValue) || Bridge.referenceEquals(this.baseObserverValueType, Bridge.getType(baseValue))) {
                    if (this.delegateObserver != null) {
                        this.delegateObserver.System$Windows$Data$IPropertyObserver$SetBaseValue(baseValue);
                    }

                    return;
                }

                this.baseObserverValueType = Bridge.getType(baseValue);

                if (Bridge.is(this.delegateObserver, System.IDisposable)) {
                    Bridge.cast(this.delegateObserver, System.IDisposable).System$IDisposable$dispose();
                }

                this.delegateObserver = this.propertyPathElement.System$Windows$IPropertyPathElement$CreatePropertyObserver(this.baseObserverValueType);

                if (this.delegateObserver != null) {
                    this.ValueType = this.delegateObserver.System$Windows$Data$IPropertyObserver$ValueType;
                    this.delegateObserver.System$Windows$Data$IPropertyObserver$SetBaseValue(baseValue);
                    this.delegateObserver.System$Windows$Data$IObservableValue$addValueChanged(Bridge.fn.bind(this, $asm.$.System.Windows.Data.ObservableExpression.f3));
                    this.observableValue.BaseValue = this.delegateObserver.System$Windows$Data$IObservableValue$Value;
                } else {
                    this.ValueType = null;
                    this.observableValue.BaseValue = System.Windows.Data.ObservableValue.UnsetValue;
                }
            },
            dispose: function () {
                if (Bridge.is(this.baseObserver, System.IDisposable)) {
                    Bridge.cast(this.baseObserver, System.IDisposable).System$IDisposable$dispose();
                }

                if (Bridge.is(this.delegateObserver, System.IDisposable)) {
                    Bridge.cast(this.delegateObserver, System.IDisposable).System$IDisposable$dispose();
                }
            }
        }
    });

    Bridge.ns("System.Windows.Data.ObservableExpression", $asm.$);

    Bridge.apply($asm.$.System.Windows.Data.ObservableExpression, {
        f1: function (sender, oldValue, newValue) {
            System.Windows.Data.ObservableValueChangedEventHandlerExtensions.Raise(this.ValueChanged, this, oldValue, newValue);
        },
        f2: function (sender, oldValue, newValue) {
            this.SetDelegateObserverBaseValue();
        },
        f3: function (sender, oldValue, newValue) {
            this.observableValue.BaseValue = this.delegateObserver.System$Windows$Data$IObservableValue$Value;
        }
    });

    Bridge.define("System.Windows.Data.ObservableValue", {
        inherits: [System.Windows.Data.IObservableValue],
        statics: {
            fields: {
                UnsetValue: null
            },
            ctors: {
                init: function () {
                    this.UnsetValue = new System.Windows.Data.NamedObject("ObservableValue.UnsetValue");
                }
            },
            methods: {
                IsNullOrUnset: function (value) {
                    return value == null || Bridge.referenceEquals(value, System.Windows.Data.ObservableValue.UnsetValue);
                }
            }
        },
        fields: {
            baseObservableValue: null,
            baseValue: null,
            baseObservableValueChangedEventHandler: null
        },
        events: {
            ValueChanged: null
        },
        props: {
            Value: null,
            BaseValue: {
                get: function () {
                    return this.baseValue;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.baseValue, value)) {
                        return;
                    }

                    if (this.baseObservableValue != null) {
                        this.baseObservableValue.System$Windows$Data$IObservableValue$removeValueChanged(this.BaseObservableValueChangedEventHandler);
                    }

                    this.baseValue = value;
                    this.baseObservableValue = Bridge.as(value, System.Windows.Data.IObservableValue);

                    if (this.baseObservableValue != null) {
                        this.baseObservableValue.System$Windows$Data$IObservableValue$addValueChanged(this.BaseObservableValueChangedEventHandler);
                    }

                    var oldValue = this.Value;
                    var newValue = this.baseObservableValue != null ? this.baseObservableValue.System$Windows$Data$IObservableValue$Value : this.baseValue;

                    if (Granular.Compatibility.EqualityComparer.Default.equals2(oldValue, newValue)) {
                        return;
                    }

                    this.Value = newValue;
                    System.Windows.Data.ObservableValueChangedEventHandlerExtensions.Raise(this.ValueChanged, this, oldValue, newValue);
                }
            },
            BaseObservableValueChangedEventHandler: {
                get: function () {
                    if (Bridge.staticEquals(this.baseObservableValueChangedEventHandler, null)) {
                        this.baseObservableValueChangedEventHandler = Bridge.fn.cacheBind(this, this.OnBaseObservableValueChanged);
                    }

                    return this.baseObservableValueChangedEventHandler;
                }
            }
        },
        alias: [
            "addValueChanged", "System$Windows$Data$IObservableValue$addValueChanged",
            "removeValueChanged", "System$Windows$Data$IObservableValue$removeValueChanged",
            "Value", "System$Windows$Data$IObservableValue$Value"
        ],
        ctors: {
            ctor: function () {
                System.Windows.Data.ObservableValue.$ctor1.call(this, System.Windows.Data.ObservableValue.UnsetValue);
                //
            },
            $ctor1: function (baseValue) {
                this.$initialize();
                this.BaseValue = baseValue;
            }
        },
        methods: {
            OnBaseObservableValueChanged: function (sender, oldValue, newValue) {
                this.Value = newValue;
                System.Windows.Data.ObservableValueChangedEventHandlerExtensions.Raise(this.ValueChanged, this, oldValue, newValue);
            }
        }
    });

    Bridge.define("System.Windows.Data.RelativeSource", {
        inherits: [System.Windows.Markup.IMarkupExtension],
        props: {
            Mode: 0,
            AncestorLevel: 0,
            AncestorType: null
        },
        alias: ["ProvideValue", "System$Windows$Markup$IMarkupExtension$ProvideValue"],
        methods: {
            ProvideValue: function (context) {
                return this;
            },
            CreateSourceObserver: function (target) {
                switch (this.Mode) {
                    case System.Windows.Data.RelativeSourceMode.TemplatedParent: 
                        return new System.Windows.Data.TemplatedParentSourceObserver(target);
                    case System.Windows.Data.RelativeSourceMode.Self: 
                        return new System.Windows.Data.StaticObservableValue(target);
                    case System.Windows.Data.RelativeSourceMode.FindAncestor: 
                        return new System.Windows.Data.FindAncestorSourceObserver(target, this.AncestorType, this.AncestorLevel);
                }

                throw new Granular.Exception("Unexpected RelativeSourceMode \"{0}\"", [Bridge.box(this.Mode, System.Windows.Data.RelativeSourceMode, System.Enum.toStringFn(System.Windows.Data.RelativeSourceMode))]);
            }
        }
    });

    Bridge.define("System.Windows.Data.StaticObservableValue", {
        inherits: [System.Windows.Data.IObservableValue],
        fields: {
            value: null
        },
        props: {
            Value: {
                get: function () {
                    return this.value;
                }
            }
        },
        alias: [
            "addValueChanged", "System$Windows$Data$IObservableValue$addValueChanged",
            "removeValueChanged", "System$Windows$Data$IObservableValue$removeValueChanged",
            "Value", "System$Windows$Data$IObservableValue$Value"
        ],
        ctors: {
            ctor: function (value) {
                this.$initialize();
                this.value = value;
            }
        },
        methods: {
            addValueChanged: function (value) { },
            removeValueChanged: function (value) { }
        }
    });

    Bridge.define("System.Windows.DataTemplateKeyProvider", {
        inherits: [System.Windows.Markup.IDeferredValueKeyProvider],
        alias: ["GetValueKey", "System$Windows$Markup$IDeferredValueKeyProvider$GetValueKey"],
        methods: {
            GetValueKey: function (element) {
                var keyMember = System.Linq.Enumerable.from(element.Members).singleOrDefault($asm.$.System.Windows.DataTemplateKeyProvider.f1, null);
                if (keyMember != null) {
                    return System.Windows.Markup.ElementFactory.FromValue(System.Linq.Enumerable.from(keyMember.Values).single(), System.Object, element.Namespaces, element.SourceUri).System$Windows$Markup$IElementFactory$CreateElement(new System.Windows.Markup.InitializeContext.ctor());
                }

                var dataTypeMember = System.Linq.Enumerable.from(element.Members).singleOrDefault($asm.$.System.Windows.DataTemplateKeyProvider.f2, null);
                if (dataTypeMember != null) {
                    return new System.Windows.TemplateKey(Bridge.cast(System.Windows.Markup.ElementFactory.FromValue(System.Linq.Enumerable.from(dataTypeMember.Values).single(), Function, element.Namespaces, element.SourceUri).System$Windows$Markup$IElementFactory$CreateElement(new System.Windows.Markup.InitializeContext.ctor()), Function));
                }

                throw new Granular.Exception(System.String.format("Can't create value key from \"{0}\"", element.Name));
            }
        }
    });

    Bridge.ns("System.Windows.DataTemplateKeyProvider", $asm.$);

    Bridge.apply($asm.$.System.Windows.DataTemplateKeyProvider, {
        f1: function (member) {
            return Bridge.referenceEquals(member.Name.LocalName, "Key");
        },
        f2: function (member) {
            return Bridge.referenceEquals(member.Name.LocalName, "DataType");
        }
    });

    Bridge.define("System.Windows.DependencyPropertyPathElement", {
        inherits: [System.Windows.IPropertyPathElement],
        props: {
            DependencyProperty: null
        },
        alias: [
            "TryGetDependencyProperty", "System$Windows$IPropertyPathElement$TryGetDependencyProperty",
            "CreatePropertyObserver", "System$Windows$IPropertyPathElement$CreatePropertyObserver",
            "TryGetValue", "System$Windows$IPropertyPathElement$TryGetValue"
        ],
        ctors: {
            ctor: function (dependencyProperty) {
                this.$initialize();
                this.DependencyProperty = dependencyProperty;
            }
        },
        methods: {
            equals: function (obj) {
                var other = Bridge.as(obj, System.Windows.DependencyPropertyPathElement);

                return Bridge.referenceEquals(this, other) || !Bridge.referenceEquals(other, null) && Bridge.referenceEquals(this.DependencyProperty, other.DependencyProperty);
            },
            getHashCode: function () {
                return this.DependencyProperty.getHashCode();
            },
            toString: function () {
                return System.String.format("({0})", this.DependencyProperty);
            },
            TryGetDependencyProperty: function (containingType, dependencyProperty) {
                dependencyProperty.v = this.DependencyProperty;
                return true;
            },
            CreatePropertyObserver: function (baseValueType) {
                return new System.Windows.Data.DependencyPropertyObserver(this.DependencyProperty);
            },
            TryGetValue: function (target, value) {
                if (Bridge.is(target, System.Windows.DependencyObject)) {
                    value.v = Bridge.cast(target, System.Windows.DependencyObject).GetValue(this.DependencyProperty);
                    return true;
                }

                value.v = null;
                return false;
            }
        }
    });

    Bridge.define("System.Windows.DependencyPropertyTypeConverter", {
        inherits: [System.Windows.Markup.ITypeConverter],
        alias: ["ConvertFrom", "System$Windows$Markup$ITypeConverter$ConvertFrom"],
        methods: {
            ConvertFrom: function (namespaces, sourceUri, value) {
                var text = value.toString().trim();

                var typeSeparatorIndex = System.String.indexOf(text, ".");
                if (typeSeparatorIndex === -1) {
                    throw new Granular.Exception("Dependency property \"{0}\" does not contain owner type name", [text]);
                }

                var ownerType = System.Windows.Markup.TypeParser.ParseType(text.substr(0, typeSeparatorIndex), namespaces);
                var dependencyProperty = System.Windows.DependencyProperty.GetProperty(ownerType, text.substr(((typeSeparatorIndex + 1) | 0)));

                if (dependencyProperty == null) {
                    throw new Granular.Exception("Can't find dependency property named \"{0}\"", [text]);
                }

                return dependencyProperty;
            }
        }
    });

    Bridge.define("System.Windows.DependencyPropertyValueEntry", {
        inherits: [System.Windows.IDependencyPropertyValueEntry],
        statics: {
            fields: {
                BaseValuePriorities: 0,
                ValuePriorities: 0,
                BaseValueHighestPriority: 0,
                CurrentValuePriority: 0,
                AnimationValuePriority: 0
            },
            ctors: {
                init: function () {
                    this.BaseValuePriorities = 12;
                    this.ValuePriorities = 14;
                    this.BaseValueHighestPriority = 11;
                    this.CurrentValuePriority = System.Windows.DependencyPropertyValueEntry.BaseValuePriorities;
                    this.AnimationValuePriority = 13;
                }
            }
        },
        fields: {
            value: null,
            notifyValueChangedEventHandler: null,
            indexedObservableValueChangedEventHandler: null,
            observableValues: null,
            values: null,
            baseValuePriority: 0,
            dependencyObject: null,
            dependencyProperty: null,
            coerceValueCallback: null
        },
        events: {
            ValueChanged: null
        },
        props: {
            Value: {
                get: function () {
                    return this.value;
                },
                set: function (value) {
                    if (Bridge.is(this.value, System.Windows.INotifyChanged)) {
                        Bridge.cast(this.value, System.Windows.INotifyChanged).System$Windows$INotifyChanged$removeChanged(this.NotifyValueChangedEventHandler);
                    }

                    this.value = value;

                    if (Bridge.is(this.value, System.Windows.INotifyChanged)) {
                        Bridge.cast(this.value, System.Windows.INotifyChanged).System$Windows$INotifyChanged$addChanged(this.NotifyValueChangedEventHandler);
                    }
                }
            },
            ValuePriority: 0,
            NotifyValueChangedEventHandler: {
                get: function () {
                    if (Bridge.staticEquals(this.notifyValueChangedEventHandler, null)) {
                        this.notifyValueChangedEventHandler = Bridge.fn.cacheBind(this, this.OnValueNotifyChanged);
                    }

                    return this.notifyValueChangedEventHandler;
                }
            },
            IndexedObservableValueChangedEventHandler: {
                get: function () {
                    if (Bridge.staticEquals(this.indexedObservableValueChangedEventHandler, null)) {
                        this.indexedObservableValueChangedEventHandler = Bridge.fn.cacheBind(this, this.OnIndexedObservableValueChanged);
                    }

                    return this.indexedObservableValueChangedEventHandler;
                }
            }
        },
        alias: [
            "addValueChanged", "System$Windows$IDependencyPropertyValueEntry$addValueChanged",
            "removeValueChanged", "System$Windows$IDependencyPropertyValueEntry$removeValueChanged",
            "Value", "System$Windows$IDependencyPropertyValueEntry$Value",
            "ValuePriority", "System$Windows$IDependencyPropertyValueEntry$ValuePriority",
            "GetValue", "System$Windows$IDependencyPropertyValueEntry$GetValue",
            "SetValue", "System$Windows$IDependencyPropertyValueEntry$SetValue",
            "GetBaseValuePriority", "System$Windows$IDependencyPropertyValueEntry$GetBaseValuePriority",
            "CoerceValue", "System$Windows$IDependencyPropertyValueEntry$CoerceValue"
        ],
        ctors: {
            ctor: function (dependencyObject, dependencyProperty, coerceValueCallback) {
                if (coerceValueCallback === void 0) { coerceValueCallback = null; }

                this.$initialize();
                this.dependencyObject = dependencyObject;
                this.dependencyProperty = dependencyProperty;
                this.coerceValueCallback = coerceValueCallback;

                this.values = System.Array.init(14, null, System.Object);
                for (var i = 0; i < this.values.length; i = (i + 1) | 0) {
                    this.values[System.Array.index(i, this.values)] = System.Windows.Data.ObservableValue.UnsetValue;
                }
            }
        },
        methods: {
            GetValue: function (priority, flattened) {
                if (this.observableValues != null && this.observableValues[System.Array.index(priority, this.observableValues)] != null) {
                    return flattened ? this.observableValues[System.Array.index(priority, this.observableValues)].Value : this.observableValues[System.Array.index(priority, this.observableValues)].BaseValue;
                }

                return this.values[System.Array.index(priority, this.values)];
            },
            SetValue: function (priority, value) {
                if (this.observableValues != null && this.observableValues[System.Array.index(priority, this.observableValues)] != null) {
                    this.observableValues[System.Array.index(priority, this.observableValues)].BaseValue = value;
                    return;
                }

                var oldValue = this.values[System.Array.index(priority, this.values)];

                if (Bridge.is(value, System.Windows.Data.IObservableValue)) {
                    if (this.observableValues == null) {
                        this.observableValues = System.Array.init(14, null, System.Windows.DependencyPropertyValueEntry.IndexedObservableValue);
                    }

                    var indexedObservableValue = new System.Windows.DependencyPropertyValueEntry.IndexedObservableValue(priority, oldValue);
                    indexedObservableValue.addValueChanged(this.IndexedObservableValueChangedEventHandler);

                    this.observableValues[System.Array.index(priority, this.observableValues)] = indexedObservableValue;
                    this.values[System.Array.index(priority, this.values)] = System.Windows.Data.ObservableValue.UnsetValue;

                    indexedObservableValue.BaseValue = value;
                    return;
                }

                if (Granular.Compatibility.EqualityComparer.Default.equals2(oldValue, value)) {
                    return;
                }

                this.values[System.Array.index(priority, this.values)] = value;
                this.OnValueChanged(priority, value);
            },
            GetBaseValuePriority: function () {
                if (this.baseValuePriority > System.Windows.DependencyPropertyValueEntry.BaseValueHighestPriority) {
                    this.baseValuePriority = System.Windows.DependencyPropertyValueEntry.BaseValueHighestPriority;

                    while (this.baseValuePriority > 0 && !this.IsValueValid(this.GetValue(this.baseValuePriority, true))) {
                        this.baseValuePriority = (this.baseValuePriority - 1) | 0;
                    }
                }

                return this.baseValuePriority;
            },
            CoerceValue: function () {
                if (Bridge.staticEquals(this.coerceValueCallback, null)) {
                    return;
                }

                var oldValue = this.Value;
                var newValue = this.coerceValueCallback(this.dependencyObject, this.GetValue(this.ValuePriority, true));

                if (Granular.Compatibility.EqualityComparer.Default.equals2(oldValue, newValue)) {
                    return;
                }

                this.Value = newValue;
                System.Windows.DependencyPropertyChangedEventHandlerExtensions.Raise(this.ValueChanged, this, new System.Windows.DependencyPropertyChangedEventArgs.$ctor1(this.dependencyProperty, oldValue, newValue));
            },
            OnIndexedObservableValueChanged: function (sender, oldValue, newValue) {
                this.OnValueChanged(Bridge.cast(sender, System.Windows.DependencyPropertyValueEntry.IndexedObservableValue).Index, newValue);
            },
            OnValueChanged: function (newValuePriority, newValue) {
                if (this.ValuePriority > newValuePriority) {
                    if (this.baseValuePriority <= newValuePriority && newValuePriority <= System.Windows.DependencyPropertyValueEntry.BaseValueHighestPriority) {
                        this.baseValuePriority = 12; // invalidate baseValuePriority
                    }

                    return;
                }

                var oldValue = this.Value;
                var isNewValueValid = this.IsValueValid(newValue);

                if (this.ValuePriority === newValuePriority && isNewValueValid && Bridge.staticEquals(this.coerceValueCallback, null)) {
                    this.Value = newValue;
                    System.Windows.DependencyPropertyChangedEventHandlerExtensions.Raise(this.ValueChanged, this, new System.Windows.DependencyPropertyChangedEventArgs.$ctor1(this.dependencyProperty, oldValue, newValue)); // since this was already the value priority and there is no coercion, Value must have been changed here
                    return;
                }

                if (this.ValuePriority < newValuePriority && !isNewValueValid) {
                    return;
                }

                while (!isNewValueValid && newValuePriority > 0) {
                    newValuePriority = (newValuePriority - 1) | 0;
                    newValue = this.GetValue(newValuePriority, true);
                    isNewValueValid = this.IsValueValid(newValue);
                }

                if (this.ValuePriority !== newValuePriority) {
                    this.ValuePriority = newValuePriority;
                    this.baseValuePriority = newValuePriority; // possible invalidation of baseValuePriority
                }

                if (!Bridge.staticEquals(this.coerceValueCallback, null)) {
                    newValue = this.coerceValueCallback(this.dependencyObject, newValue);
                }

                if (Granular.Compatibility.EqualityComparer.Default.equals2(oldValue, newValue)) {
                    return;
                }

                this.Value = newValue;
                System.Windows.DependencyPropertyChangedEventHandlerExtensions.Raise(this.ValueChanged, this, new System.Windows.DependencyPropertyChangedEventArgs.$ctor1(this.dependencyProperty, oldValue, newValue));
            },
            OnValueNotifyChanged: function (sender, e) {
                System.Windows.DependencyPropertyChangedEventHandlerExtensions.Raise(this.ValueChanged, this, new System.Windows.DependencyPropertyChangedEventArgs.ctor(this.dependencyProperty, this.Value));
            },
            IsValueValid: function (newValue) {
                return !Bridge.referenceEquals(newValue, System.Windows.Data.ObservableValue.UnsetValue) && this.dependencyProperty.IsValidValue(newValue);
            }
        }
    });

    Bridge.define("System.Windows.Documents.InlineConverter", {
        inherits: [System.Windows.Markup.ITypeConverter],
        alias: ["ConvertFrom", "System$Windows$Markup$ITypeConverter$ConvertFrom"],
        methods: {
            ConvertFrom: function (namespaces, sourceUri, value) {
                return new System.Windows.Documents.Run.$ctor1(Bridge.cast(value, System.String));
            }
        }
    });

    Bridge.define("System.Windows.DurationTypeConverter", {
        inherits: [System.Windows.Markup.ITypeConverter],
        alias: ["ConvertFrom", "System$Windows$Markup$ITypeConverter$ConvertFrom"],
        methods: {
            ConvertFrom: function (namespaces, sourceUri, value) {
                return System.Windows.Duration.Parse(value.toString().trim());
            }
        }
    });

    Bridge.define("System.Windows.DynamicResourceExtension", {
        inherits: [System.Windows.Markup.IMarkupExtension],
        props: {
            ResourceKey: null
        },
        alias: ["ProvideValue", "System$Windows$Markup$IMarkupExtension$ProvideValue"],
        methods: {
            ProvideValue: function (context) {
                return new System.Windows.ResourceReferenceExpressionProvider(this.ResourceKey);
            }
        }
    });

    Bridge.define("System.Windows.EventSetter", {
        inherits: [System.Windows.ITriggerAction],
        props: {
            Event: null,
            Handler: null,
            HandledEventsToo: false
        },
        alias: [
            "Apply", "System$Windows$ITriggerAction$Apply",
            "Clean", "System$Windows$ITriggerAction$Clean",
            "IsActionOverlaps", "System$Windows$ITriggerAction$IsActionOverlaps"
        ],
        methods: {
            Apply: function (target, valueSource) {
                target.AddHandler(this.Event, this.Handler, this.HandledEventsToo);
            },
            Clean: function (target, valueSource) {
                target.RemoveHandler(this.Event, this.Handler);
            },
            IsActionOverlaps: function (action) {
                return Bridge.is(action, System.Windows.EventSetter) && Bridge.referenceEquals(this.Event, Bridge.cast(action, System.Windows.EventSetter).Event);
            }
        }
    });

    Bridge.define("System.Windows.EventTrigger.EventTriggerCondition", {
        inherits: [System.Windows.IEventTriggerCondition,System.IDisposable],
        statics: {
            methods: {
                Register: function (element, routedEvent) {
                    var condition = new System.Windows.EventTrigger.EventTriggerCondition(element, routedEvent);
                    condition.Register();
                    return condition;
                }
            }
        },
        fields: {
            element: null,
            routedEvent: null
        },
        events: {
            EventRaised: null
        },
        alias: [
            "addEventRaised", "System$Windows$IEventTriggerCondition$addEventRaised",
            "removeEventRaised", "System$Windows$IEventTriggerCondition$removeEventRaised",
            "dispose", "System$IDisposable$dispose"
        ],
        ctors: {
            ctor: function (element, routedEvent) {
                this.$initialize();
                this.element = element;
                this.routedEvent = routedEvent;
            }
        },
        methods: {
            Register: function () {
                this.element.AddHandler(this.routedEvent, Bridge.fn.cacheBind(this, this.RoutedEventHandler));
            },
            dispose: function () {
                this.element.RemoveHandler(this.routedEvent, Bridge.fn.cacheBind(this, this.RoutedEventHandler));
            },
            RoutedEventHandler: function (sender, e) {
                Granular.Extensions.EventHandlerExtensions.Raise$2(this.EventRaised, this);
            }
        }
    });

    Bridge.define("System.Windows.FrameworkElementFactory", {
        inherits: [System.Windows.IFrameworkElementFactory],
        fields: {
            elementFactory: null,
            context: null
        },
        alias: ["CreateElement", "System$Windows$IFrameworkElementFactory$CreateElement"],
        ctors: {
            ctor: function (elementFactory, context) {
                this.$initialize();
                this.elementFactory = elementFactory;
                this.context = context;
            }
        },
        methods: {
            CreateElement: function (templatedParent) {
                var elementContext = new System.Windows.Markup.InitializeContext.$ctor1(null, this.context, new System.Windows.NameScope(this.context.NameScope), templatedParent, System.Windows.BaseValueSource.ParentTemplate);

                var element = Bridge.as(this.elementFactory.System$Windows$Markup$IElementFactory$CreateElement(elementContext), System.Windows.FrameworkElement);

                System.Windows.NameScope.SetNameScope(element, elementContext.NameScope);

                return element;
            }
        }
    });

    Bridge.define("System.Windows.FrameworkPropertyMetadata", {
        inherits: [System.Windows.PropertyMetadata],
        props: {
            AffectsArrange: false,
            AffectsMeasure: false,
            AffectsParentArrange: false,
            AffectsParentMeasure: false,
            AffectsRender: false,
            AffectsVisualState: false,
            BindsTwoWayByDefault: false,
            DefaultUpdateSourceTrigger: 0
        },
        ctors: {
            ctor: function () {
                System.Windows.FrameworkPropertyMetadata.$ctor5.call(this, null, System.Windows.FrameworkPropertyMetadataOptions.None, null, null, false, System.Windows.Data.UpdateSourceTrigger.Default);
                //
            },
            $ctor1: function (defaultValue) {
                System.Windows.FrameworkPropertyMetadata.$ctor5.call(this, defaultValue, System.Windows.FrameworkPropertyMetadataOptions.None, null, null, false, System.Windows.Data.UpdateSourceTrigger.Default);
                //
            },
            $ctor8: function (flags) {
                System.Windows.FrameworkPropertyMetadata.$ctor5.call(this, null, flags, null, null, false, System.Windows.Data.UpdateSourceTrigger.Default);
                //
            },
            $ctor9: function (flags, propertyChangedCallback) {
                System.Windows.FrameworkPropertyMetadata.$ctor5.call(this, null, flags, propertyChangedCallback, null, false, System.Windows.Data.UpdateSourceTrigger.Default);
                //
            },
            $ctor10: function (flags, propertyChangedCallback, coerceValueCallback) {
                System.Windows.FrameworkPropertyMetadata.$ctor5.call(this, null, flags, propertyChangedCallback, coerceValueCallback, false, System.Windows.Data.UpdateSourceTrigger.Default);
                //
            },
            $ctor11: function (propertyChangedCallback) {
                System.Windows.FrameworkPropertyMetadata.$ctor5.call(this, null, System.Windows.FrameworkPropertyMetadataOptions.None, propertyChangedCallback, null, false, System.Windows.Data.UpdateSourceTrigger.Default);
                //
            },
            $ctor12: function (propertyChangedCallback, coerceValueCallback) {
                System.Windows.FrameworkPropertyMetadata.$ctor5.call(this, null, System.Windows.FrameworkPropertyMetadataOptions.None, propertyChangedCallback, coerceValueCallback, false, System.Windows.Data.UpdateSourceTrigger.Default);
                //
            },
            $ctor6: function (defaultValue, propertyChangedCallback) {
                System.Windows.FrameworkPropertyMetadata.$ctor5.call(this, defaultValue, System.Windows.FrameworkPropertyMetadataOptions.None, propertyChangedCallback, null, false, System.Windows.Data.UpdateSourceTrigger.Default);
                //
            },
            $ctor2: function (defaultValue, flags) {
                System.Windows.FrameworkPropertyMetadata.$ctor5.call(this, defaultValue, flags, null, null, false, System.Windows.Data.UpdateSourceTrigger.Default);
                //
            },
            $ctor7: function (defaultValue, propertyChangedCallback, coerceValueCallback) {
                System.Windows.FrameworkPropertyMetadata.$ctor5.call(this, defaultValue, System.Windows.FrameworkPropertyMetadataOptions.None, propertyChangedCallback, coerceValueCallback, false, System.Windows.Data.UpdateSourceTrigger.Default);
                //
            },
            $ctor3: function (defaultValue, flags, propertyChangedCallback) {
                System.Windows.FrameworkPropertyMetadata.$ctor5.call(this, defaultValue, flags, propertyChangedCallback, null, false, System.Windows.Data.UpdateSourceTrigger.Default);
                //
            },
            $ctor4: function (defaultValue, flags, propertyChangedCallback, coerceValueCallback) {
                System.Windows.FrameworkPropertyMetadata.$ctor5.call(this, defaultValue, flags, propertyChangedCallback, coerceValueCallback, false, System.Windows.Data.UpdateSourceTrigger.Default);
                //
            },
            $ctor5: function (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited, defaultUpdateSourceTrigger) {
                this.$initialize();
                System.Windows.PropertyMetadata.$ctor3.call(this, defaultValue, propertyChangedCallback, coerceValueCallback);
                this.AffectsArrange = (flags & System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange) !== 0;
                this.AffectsMeasure = (flags & System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure) !== 0;
                this.AffectsParentArrange = (flags & System.Windows.FrameworkPropertyMetadataOptions.AffectsParentArrange) !== 0;
                this.AffectsParentMeasure = (flags & System.Windows.FrameworkPropertyMetadataOptions.AffectsParentMeasure) !== 0;
                this.AffectsRender = (flags & System.Windows.FrameworkPropertyMetadataOptions.AffectsRender) !== 0;
                this.AffectsVisualState = (flags & System.Windows.FrameworkPropertyMetadataOptions.AffectsVisualState) !== 0;
                this.BindsTwoWayByDefault = (flags & System.Windows.FrameworkPropertyMetadataOptions.BindsTwoWayByDefault) !== 0;
                this.Inherits = (flags & System.Windows.FrameworkPropertyMetadataOptions.Inherits) !== 0;
                this.DefaultUpdateSourceTrigger = defaultUpdateSourceTrigger;
            }
        }
    });

    Bridge.define("System.Windows.FrameworkTemplate.EmptyFrameworkTemplate", {
        inherits: [System.Windows.IFrameworkTemplate],
        alias: [
            "Attach", "System$Windows$IFrameworkTemplate$Attach",
            "Detach", "System$Windows$IFrameworkTemplate$Detach"
        ],
        methods: {
            Attach: function (element) {
                element.TemplateChild = null;
            },
            Detach: function (element) {
                //
            }
        }
    });

    Bridge.define("System.Windows.GridLengthTypeConverter", {
        inherits: [System.Windows.Markup.ITypeConverter],
        alias: ["ConvertFrom", "System$Windows$Markup$ITypeConverter$ConvertFrom"],
        methods: {
            ConvertFrom: function (namespaces, sourceUri, value) {
                var text = value.toString().trim();

                if (Bridge.referenceEquals(text.toLowerCase(), "auto")) {
                    return System.Windows.GridLength.Auto;
                }

                if (Bridge.referenceEquals(text, "*")) {
                    return System.Windows.GridLength.Star;
                }

                if (System.String.endsWith(text, "*")) {
                    var stars = { };
                    if (System.Double.tryParse(text.substr(0, ((text.length - 1) | 0)), null, stars)) {
                        return System.Windows.GridLength.FromStars(stars.v);
                    }
                }

                var pixels = { };
                if (System.Double.tryParse(text, null, pixels)) {
                    return System.Windows.GridLength.FromPixles(pixels.v);
                }

                throw new Granular.Exception("Can't parse GridLength value \"{0}\"", [text]);
            }
        }
    });

    Bridge.define("System.Windows.IndexPropertyPathElement", {
        inherits: [System.Windows.IPropertyPathElement],
        fields: {
            namespaces: null,
            sourceUri: null
        },
        props: {
            PropertyName: null,
            IndexRawValues: null
        },
        alias: [
            "TryGetValue", "System$Windows$IPropertyPathElement$TryGetValue",
            "TryGetDependencyProperty", "System$Windows$IPropertyPathElement$TryGetDependencyProperty",
            "CreatePropertyObserver", "System$Windows$IPropertyPathElement$CreatePropertyObserver"
        ],
        ctors: {
            ctor: function (propertyName, indexRawValues, namespaces, sourceUri) {
                this.$initialize();
                this.PropertyName = propertyName;
                this.IndexRawValues = indexRawValues;
                this.namespaces = namespaces;
                this.sourceUri = sourceUri;
            }
        },
        methods: {
            equals: function (obj) {
                var other = Bridge.as(obj, System.Windows.IndexPropertyPathElement);

                return Bridge.referenceEquals(this, other) || !Bridge.referenceEquals(other, null) && System.Windows.Markup.XamlName.op_Equality(this.PropertyName, other.PropertyName) && Granular.Compatibility.Linq.Enumerable.SequenceEqual(System.String, this.IndexRawValues, other.IndexRawValues);
            },
            getHashCode: function () {
                return this.PropertyName.getHashCode();
            },
            toString: function () {
                var propertyName = this.PropertyName.HasContainingTypeName ? System.String.format("({0})", this.PropertyName.LocalName) : this.PropertyName.LocalName;
                var indexRawValues = Granular.Compatibility.Linq.Enumerable.Aggregate(System.String, Granular.Compatibility.Linq.Enumerable.DefaultIfEmpty$1(System.String, this.IndexRawValues, ""), $asm.$.System.Windows.IndexPropertyPathElement.f1);

                return System.String.format("{0}[{1}]", propertyName, indexRawValues);
            },
            TryGetValue: function (target, value) {
                var containingType = System.Windows.Markup.XamlNameExtensions.ResolveContainingType(this.PropertyName, Bridge.getType(target));
                var propertyName = this.PropertyName.MemberName;

                var isDefaultIndexProperty = Granular.Extensions.StringExtensions.IsNullOrEmpty(propertyName);

                var indexPropertyValue = { };

                // an index property that has a name (such as "Values[0]"), might be a regular property with the same name ("Values"), and a default index property ("[0]" or "Item[0]")
                if (!isDefaultIndexProperty && System.Windows.PropertyPathElement.TryGetValue(target, this.PropertyName, indexPropertyValue)) {
                    if (indexPropertyValue.v == null) {
                        value.v = null;
                        return false;
                    }

                    target = indexPropertyValue.v;
                    containingType = Bridge.getType(indexPropertyValue.v);
                    isDefaultIndexProperty = true;
                }

                var indexPropertyInfo = isDefaultIndexProperty ? Granular.Extensions.TypeExtensions.GetDefaultIndexProperty(containingType) : Granular.Extensions.TypeExtensions.GetInstanceProperty(containingType, propertyName);

                if (indexPropertyInfo == null) {
                    value.v = null;
                    return false;
                }

                value.v = Bridge.Reflection.midel(indexPropertyInfo.g, Bridge.unbox(target)).apply(null, Bridge.unbox(Granular.Compatibility.Linq.Enumerable.ToArray(System.Object, this.ParseIndexValues(indexPropertyInfo))));
                return true;
            },
            TryGetDependencyProperty: function (containingType, dependencyProperty) {
                dependencyProperty.v = null;
                return false;
            },
            CreatePropertyObserver: function (baseValueType) {
                return new System.Windows.Data.IndexPropertyObserver(baseValueType, this, this.namespaces);
            },
            ParseIndexValues: function (indexPropertyInfo) {
                if (Granular.Compatibility.Linq.Enumerable.Count(Bridge.global.System.Object, (indexPropertyInfo.ipi || [])) !== Granular.Compatibility.Linq.Enumerable.Count(System.String, this.IndexRawValues)) {
                    throw new Granular.Exception("Invalid number of index parameters for \"{0}.{1}\"", [Bridge.Reflection.getTypeName(indexPropertyInfo.td), indexPropertyInfo.n]);
                }

                return Granular.Compatibility.Linq.Enumerable.ToArray(System.Object, Granular.Compatibility.Linq.Enumerable.Zip(Bridge.global.System.Object, System.String, System.Object, (indexPropertyInfo.ipi || []), this.IndexRawValues, Bridge.fn.bind(this, $asm.$.System.Windows.IndexPropertyPathElement.f2)));
            }
        }
    });

    Bridge.ns("System.Windows.IndexPropertyPathElement", $asm.$);

    Bridge.apply($asm.$.System.Windows.IndexPropertyPathElement, {
        f1: function (s1, s2) {
            return System.String.format("{0}, {1}", s1, s2);
        },
        f2: function (parameter, rawValue) {
            return System.Windows.Markup.TypeConverter.ConvertValue(rawValue, parameter.pt, this.namespaces, this.sourceUri);
        }
    });

    Bridge.define("System.Windows.Input.CursorTypeConverter", {
        inherits: [System.Windows.Markup.ITypeConverter],
        alias: ["ConvertFrom", "System$Windows$Markup$ITypeConverter$ConvertFrom"],
        methods: {
            ConvertFrom: function (namespaces, sourceUri, value) {
                if (Bridge.is(value, System.String)) {
                    var propertyInfo = Bridge.Reflection.getMembers(System.Windows.Input.Cursors, 16, 24 | 256, Bridge.cast(value, System.String));
                    if (propertyInfo != null) {
                        return Bridge.Reflection.midel(propertyInfo.g, null).apply(null, System.Array.init(0, null, System.Object));
                    }
                }

                throw new Granular.Exception("Can't convert \"{0}\" to Cursor", [value]);
            }
        }
    });

    Bridge.define("System.Windows.Input.InputEventArgs", {
        inherits: [System.Windows.RoutedEventArgs],
        props: {
            Device: null,
            Timestamp: 0
        },
        ctors: {
            ctor: function (routedEvent, originalSource, inputDevice, timestamp) {
                this.$initialize();
                System.Windows.RoutedEventArgs.ctor.call(this, routedEvent, originalSource);
                this.Device = inputDevice;
                this.Timestamp = timestamp;
            }
        }
    });

    Bridge.define("System.Windows.Input.KeyboardDevice", {
        inherits: [System.Windows.Input.IInputDevice],
        fields: {
            target: null,
            downKeys: null,
            presentationSource: null
        },
        events: {
            PreProcessKey: null,
            PostProcessKey: null,
            TargetChanged: null
        },
        props: {
            Target: {
                get: function () {
                    return this.target;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.target, value)) {
                        return;
                    }

                    var oldTarget = this.target;
                    this.target = value;

                    this.OnTargetChanged(oldTarget, this.target);
                    Granular.Extensions.EventHandlerExtensions.Raise$2(this.TargetChanged, this);
                }
            },
            Modifiers: {
                get: function () {
                    return ((this.downKeys.contains(System.Windows.Input.Key.LeftAlt) || this.downKeys.contains(System.Windows.Input.Key.RightAlt)) ? System.Windows.Input.ModifierKeys.Alt : System.Windows.Input.ModifierKeys.None) | ((this.downKeys.contains(System.Windows.Input.Key.LeftCtrl) || this.downKeys.contains(System.Windows.Input.Key.RightCtrl)) ? System.Windows.Input.ModifierKeys.Control : System.Windows.Input.ModifierKeys.None) | ((this.downKeys.contains(System.Windows.Input.Key.LeftShift) || this.downKeys.contains(System.Windows.Input.Key.RightShift)) ? System.Windows.Input.ModifierKeys.Shift : System.Windows.Input.ModifierKeys.None) | ((this.downKeys.contains(System.Windows.Input.Key.LWin) || this.downKeys.contains(System.Windows.Input.Key.RWin)) ? System.Windows.Input.ModifierKeys.Windows : System.Windows.Input.ModifierKeys.None);
                }
            }
        },
        alias: [
            "Activate", "System$Windows$Input$IInputDevice$Activate",
            "Deactivate", "System$Windows$Input$IInputDevice$Deactivate"
        ],
        ctors: {
            ctor: function (presentationSource) {
                this.$initialize();
                this.presentationSource = presentationSource;

                this.downKeys = new (System.Collections.Generic.HashSet$1(System.Windows.Input.Key)).ctor();
            }
        },
        methods: {
            Activate: function () {
                //
            },
            Deactivate: function () {
                var $t;
                if (this.Target != null) {
                    var timestamp = this.presentationSource.System$Windows$IPresentationSource$GetTimestamp();

                    $t = Bridge.getEnumerator(this.downKeys);
                    try {
                        while ($t.moveNext()) {
                            var key = $t.Current;
                            System.Windows.IInputElementExtensions.RaiseEvents(this.Target, new System.Windows.Input.KeyEventArgs(System.Windows.Input.Keyboard.PreviewKeyUpEvent, this.Target, this, timestamp, key, System.Windows.Input.KeyStates.None, false), new System.Windows.Input.KeyEventArgs(System.Windows.Input.Keyboard.KeyUpEvent, this.Target, this, timestamp, key, System.Windows.Input.KeyStates.None, false));
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$dispose();
                        }
                    }}

                this.downKeys.clear();
            },
            ProcessRawEvent: function (rawEvent) {
                if (rawEvent.KeyStates === System.Windows.Input.KeyStates.Down) {
                    this.downKeys.add(rawEvent.Key);
                } else {
                    this.downKeys.remove(rawEvent.Key);
                }

                var previewRoutedEvent;
                var routedEvent;

                if (rawEvent.KeyStates === System.Windows.Input.KeyStates.Down) {
                    previewRoutedEvent = System.Windows.Input.Keyboard.PreviewKeyDownEvent;
                    routedEvent = System.Windows.Input.Keyboard.KeyDownEvent;
                } else if (rawEvent.KeyStates === System.Windows.Input.KeyStates.None) {
                    previewRoutedEvent = System.Windows.Input.Keyboard.PreviewKeyUpEvent;
                    routedEvent = System.Windows.Input.Keyboard.KeyUpEvent;
                } else {
                    throw new Granular.Exception("Unexpected KeyStates \"{0}\"", [Bridge.box(rawEvent.KeyStates, System.Windows.Input.KeyStates, System.Enum.toStringFn(System.Windows.Input.KeyStates))]);
                }

                var previewEventArgs = new System.Windows.Input.KeyEventArgs(previewRoutedEvent, this.Target, this, rawEvent.Timestamp, rawEvent.Key, rawEvent.KeyStates, rawEvent.IsRepeat);
                var eventArgs = new System.Windows.Input.KeyEventArgs(routedEvent, this.Target, this, rawEvent.Timestamp, rawEvent.Key, rawEvent.KeyStates, rawEvent.IsRepeat);

                System.Windows.Input.KeyEventHandlerExtensions.Raise(this.PreProcessKey, this, previewEventArgs);

                if (this.Target != null) {
                    System.Windows.IInputElementExtensions.RaiseEvents(this.Target, previewEventArgs, eventArgs);
                }

                System.Windows.Input.KeyEventHandlerExtensions.Raise(this.PostProcessKey, this, eventArgs);

                return (previewEventArgs.Handled || eventArgs.Handled) && !previewEventArgs.ForceHostHandling && !eventArgs.ForceHostHandling;
            },
            GetKeyStates: function (key) {
                return this.downKeys.contains(key) ? System.Windows.Input.KeyStates.Down : System.Windows.Input.KeyStates.None;
            },
            Focus: function (element) {
                this.Target = element;

                return new Granular.Disposable(Bridge.fn.bind(this, function () {
                    if (Bridge.referenceEquals(this.Target, element)) {
                        this.Target = null;
                    }
                }));
            },
            OnTargetChanged: function (oldTarget, newTarget) {
                var $t, $t1;
                var timestamp = this.presentationSource.System$Windows$IPresentationSource$GetTimestamp();

                if (oldTarget != null) {
                    $t = Bridge.getEnumerator(this.downKeys);
                    try {
                        while ($t.moveNext()) {
                            var key = $t.Current;
                            System.Windows.IInputElementExtensions.RaiseEvents(oldTarget, new System.Windows.Input.KeyEventArgs(System.Windows.Input.Keyboard.PreviewKeyUpEvent, oldTarget, this, timestamp, key, System.Windows.Input.KeyStates.None, false), new System.Windows.Input.KeyEventArgs(System.Windows.Input.Keyboard.KeyUpEvent, oldTarget, this, timestamp, key, System.Windows.Input.KeyStates.None, false));
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$dispose();
                        }
                    }
                    System.Windows.IInputElementExtensions.RaiseEvents(oldTarget, new System.Windows.Input.KeyboardFocusChangedEventArgs(System.Windows.Input.Keyboard.PreviewLostKeyboardFocusEvent, oldTarget, this, timestamp, oldTarget, newTarget), new System.Windows.Input.KeyboardFocusChangedEventArgs(System.Windows.Input.Keyboard.LostKeyboardFocusEvent, oldTarget, this, timestamp, oldTarget, newTarget));
                }

                if (newTarget != null) {
                    System.Windows.IInputElementExtensions.RaiseEvents(newTarget, new System.Windows.Input.KeyboardFocusChangedEventArgs(System.Windows.Input.Keyboard.PreviewGotKeyboardFocusEvent, newTarget, this, timestamp, oldTarget, newTarget), new System.Windows.Input.KeyboardFocusChangedEventArgs(System.Windows.Input.Keyboard.GotKeyboardFocusEvent, newTarget, this, timestamp, oldTarget, newTarget));

                    $t1 = Bridge.getEnumerator(this.downKeys);
                    try {
                        while ($t1.moveNext()) {
                            var key1 = $t1.Current;
                            System.Windows.IInputElementExtensions.RaiseEvents(newTarget, new System.Windows.Input.KeyEventArgs(System.Windows.Input.Keyboard.PreviewKeyDownEvent, newTarget, this, timestamp, key1, System.Windows.Input.KeyStates.None, false), new System.Windows.Input.KeyEventArgs(System.Windows.Input.Keyboard.KeyDownEvent, newTarget, this, timestamp, key1, System.Windows.Input.KeyStates.None, false));
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$dispose();
                        }
                    }}
            }
        }
    });

    Bridge.define("System.Windows.Input.KeyboardNavigationTarget.BaseNavigation", {
        inherits: [System.Windows.Input.KeyboardNavigationTarget.INavigation],
        alias: [
            "FindNextTarget", "System$Windows$Input$KeyboardNavigationTarget$INavigation$FindNextTarget",
            "FindPreviousTarget", "System$Windows$Input$KeyboardNavigationTarget$INavigation$FindPreviousTarget",
            "FindFirstTarget", "System$Windows$Input$KeyboardNavigationTarget$INavigation$FindFirstTarget",
            "FindLastTarget", "System$Windows$Input$KeyboardNavigationTarget$INavigation$FindLastTarget",
            "GetGlobalStops", "System$Windows$Input$KeyboardNavigationTarget$INavigation$GetGlobalStops"
        ],
        methods: {
            FindNextTarget: function (scope, currentStop, navigationModeProperty, stopComparerProvider) {
                return scope.VisualParent != null ? System.Windows.Input.KeyboardNavigationTarget.FindNextTarget(scope.VisualParent, currentStop, navigationModeProperty, stopComparerProvider) : System.Windows.Input.KeyboardNavigationTarget.FindNextContainedTarget(scope, currentStop, navigationModeProperty, stopComparerProvider);
            },
            FindPreviousTarget: function (scope, currentStop, navigationModeProperty, stopComparerProvider) {
                return scope.VisualParent != null ? System.Windows.Input.KeyboardNavigationTarget.FindPreviousTarget(scope.VisualParent, currentStop, navigationModeProperty, stopComparerProvider) : System.Windows.Input.KeyboardNavigationTarget.FindPreviousContainedTarget(scope, currentStop, navigationModeProperty, stopComparerProvider);
            },
            FindFirstTarget: function (scope, currentStop, navigationModeProperty, stopComparerProvider) {
                return scope.VisualParent != null ? System.Windows.Input.KeyboardNavigationTarget.FindFirstTarget(scope.VisualParent, currentStop, navigationModeProperty, stopComparerProvider) : System.Windows.Input.KeyboardNavigationTarget.FindFirstContainedTarget(scope, currentStop, navigationModeProperty, stopComparerProvider);
            },
            FindLastTarget: function (scope, currentStop, navigationModeProperty, stopComparerProvider) {
                return scope.VisualParent != null ? System.Windows.Input.KeyboardNavigationTarget.FindLastTarget(scope.VisualParent, currentStop, navigationModeProperty, stopComparerProvider) : System.Windows.Input.KeyboardNavigationTarget.FindLastContainedTarget(scope, currentStop, navigationModeProperty, stopComparerProvider);
            },
            GetGlobalStops: function (scope, currentElement, navigationModeProperty) {
                return System.Windows.Input.KeyboardNavigationTarget.GetContainedStops(scope, currentElement, navigationModeProperty);
            }
        }
    });

    Bridge.define("System.Windows.Input.KeyboardNavigationTarget.BottomBoundStopComparer", {
        inherits: [System.Collections.Generic.IComparer$1(System.Windows.Input.KeyboardNavigationTarget.Stop)],
        fields: {
            currentPosition: null
        },
        alias: ["compare", ["System$Collections$Generic$IComparer$1$System$Windows$Input$KeyboardNavigationTarget$Stop$compare", "System$Collections$Generic$IComparer$1$compare"]],
        ctors: {
            ctor: function (currentStop) {
                this.$initialize();
                this.currentPosition = System.Windows.Input.KeyboardNavigationTarget.GetBottomBoundPosition(System.Windows.Input.KeyboardNavigationTarget.GetAbsoluteBounds(currentStop.Element));
            }
        },
        methods: {
            compare: function (x, y) {
                var relativePosition1 = System.Windows.Point.op_Subtraction(System.Windows.Input.KeyboardNavigationTarget.GetTopBoundPosition(System.Windows.Input.KeyboardNavigationTarget.GetAbsoluteBounds(x.Element)), this.currentPosition);
                var relativePosition2 = System.Windows.Point.op_Subtraction(System.Windows.Input.KeyboardNavigationTarget.GetTopBoundPosition(System.Windows.Input.KeyboardNavigationTarget.GetAbsoluteBounds(y.Element)), this.currentPosition);

                var distance1 = relativePosition1.Y < 0 ? -System.Windows.PointExtensions.GetLengthSqr(relativePosition1) : System.Windows.PointExtensions.GetLengthSqr(relativePosition1);
                var distance2 = relativePosition2.Y < 0 ? -System.Windows.PointExtensions.GetLengthSqr(relativePosition2) : System.Windows.PointExtensions.GetLengthSqr(relativePosition2);

                return Bridge.compare(distance1, distance2);
            }
        }
    });

    Bridge.define("System.Windows.Input.KeyboardNavigationTarget.LeftBoundStopComparer", {
        inherits: [System.Collections.Generic.IComparer$1(System.Windows.Input.KeyboardNavigationTarget.Stop)],
        fields: {
            currentPosition: null
        },
        alias: ["compare", ["System$Collections$Generic$IComparer$1$System$Windows$Input$KeyboardNavigationTarget$Stop$compare", "System$Collections$Generic$IComparer$1$compare"]],
        ctors: {
            ctor: function (currentStop) {
                this.$initialize();
                this.currentPosition = System.Windows.Input.KeyboardNavigationTarget.GetLeftBoundPosition(System.Windows.Input.KeyboardNavigationTarget.GetAbsoluteBounds(currentStop.Element));
            }
        },
        methods: {
            compare: function (x, y) {
                var relativePosition1 = System.Windows.Point.op_Subtraction(System.Windows.Input.KeyboardNavigationTarget.GetRightBoundPosition(System.Windows.Input.KeyboardNavigationTarget.GetAbsoluteBounds(x.Element)), this.currentPosition);
                var relativePosition2 = System.Windows.Point.op_Subtraction(System.Windows.Input.KeyboardNavigationTarget.GetRightBoundPosition(System.Windows.Input.KeyboardNavigationTarget.GetAbsoluteBounds(y.Element)), this.currentPosition);

                var distance1 = relativePosition1.X <= 0 ? -System.Windows.PointExtensions.GetLengthSqr(relativePosition1) : System.Windows.PointExtensions.GetLengthSqr(relativePosition1);
                var distance2 = relativePosition2.X <= 0 ? -System.Windows.PointExtensions.GetLengthSqr(relativePosition2) : System.Windows.PointExtensions.GetLengthSqr(relativePosition2);

                return Bridge.compare(distance1, distance2);
            }
        }
    });

    Bridge.define("System.Windows.Input.KeyboardNavigationTarget.RightBoundStopComparer", {
        inherits: [System.Collections.Generic.IComparer$1(System.Windows.Input.KeyboardNavigationTarget.Stop)],
        fields: {
            currentPosition: null
        },
        alias: ["compare", ["System$Collections$Generic$IComparer$1$System$Windows$Input$KeyboardNavigationTarget$Stop$compare", "System$Collections$Generic$IComparer$1$compare"]],
        ctors: {
            ctor: function (currentStop) {
                this.$initialize();
                this.currentPosition = System.Windows.Input.KeyboardNavigationTarget.GetRightBoundPosition(System.Windows.Input.KeyboardNavigationTarget.GetAbsoluteBounds(currentStop.Element));
            }
        },
        methods: {
            compare: function (x, y) {
                var relativePosition1 = System.Windows.Point.op_Subtraction(System.Windows.Input.KeyboardNavigationTarget.GetLeftBoundPosition(System.Windows.Input.KeyboardNavigationTarget.GetAbsoluteBounds(x.Element)), this.currentPosition);
                var relativePosition2 = System.Windows.Point.op_Subtraction(System.Windows.Input.KeyboardNavigationTarget.GetLeftBoundPosition(System.Windows.Input.KeyboardNavigationTarget.GetAbsoluteBounds(y.Element)), this.currentPosition);

                var distance1 = relativePosition1.X < 0 ? -System.Windows.PointExtensions.GetLengthSqr(relativePosition1) : System.Windows.PointExtensions.GetLengthSqr(relativePosition1);
                var distance2 = relativePosition2.X < 0 ? -System.Windows.PointExtensions.GetLengthSqr(relativePosition2) : System.Windows.PointExtensions.GetLengthSqr(relativePosition2);

                return Bridge.compare(distance1, distance2);
            }
        }
    });

    Bridge.define("System.Windows.Input.KeyboardNavigationTarget.StopComparerProvider", {
        inherits: [System.Windows.Input.KeyboardNavigationTarget.IStopComparerProvider],
        fields: {
            createComparer: null
        },
        alias: ["CreateComparer", "System$Windows$Input$KeyboardNavigationTarget$IStopComparerProvider$CreateComparer"],
        ctors: {
            ctor: function (createComparer) {
                this.$initialize();
                this.createComparer = createComparer;
            }
        },
        methods: {
            CreateComparer: function (currentStop) {
                return this.createComparer(currentStop);
            }
        }
    });

    Bridge.define("System.Windows.Input.KeyboardNavigationTarget.TabStopComparer", {
        inherits: [System.Collections.Generic.IComparer$1(System.Windows.Input.KeyboardNavigationTarget.Stop)],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Input.KeyboardNavigationTarget.TabStopComparer();
                }
            }
        },
        alias: ["compare", ["System$Collections$Generic$IComparer$1$System$Windows$Input$KeyboardNavigationTarget$Stop$compare", "System$Collections$Generic$IComparer$1$compare"]],
        ctors: {
            ctor: function () {
                this.$initialize();
                //
            }
        },
        methods: {
            compare: function (x, y) {
                return Bridge.compare(x.TabIndex, y.TabIndex);
            }
        }
    });

    Bridge.define("System.Windows.Input.KeyboardNavigationTarget.TopBoundStopComparer", {
        inherits: [System.Collections.Generic.IComparer$1(System.Windows.Input.KeyboardNavigationTarget.Stop)],
        fields: {
            currentPosition: null
        },
        alias: ["compare", ["System$Collections$Generic$IComparer$1$System$Windows$Input$KeyboardNavigationTarget$Stop$compare", "System$Collections$Generic$IComparer$1$compare"]],
        ctors: {
            ctor: function (currentStop) {
                this.$initialize();
                this.currentPosition = System.Windows.Input.KeyboardNavigationTarget.GetTopBoundPosition(System.Windows.Input.KeyboardNavigationTarget.GetAbsoluteBounds(currentStop.Element));
            }
        },
        methods: {
            compare: function (x, y) {
                var relativePosition1 = System.Windows.Point.op_Subtraction(System.Windows.Input.KeyboardNavigationTarget.GetBottomBoundPosition(System.Windows.Input.KeyboardNavigationTarget.GetAbsoluteBounds(x.Element)), this.currentPosition);
                var relativePosition2 = System.Windows.Point.op_Subtraction(System.Windows.Input.KeyboardNavigationTarget.GetBottomBoundPosition(System.Windows.Input.KeyboardNavigationTarget.GetAbsoluteBounds(y.Element)), this.currentPosition);

                var distance1 = relativePosition1.Y <= 0 ? -System.Windows.PointExtensions.GetLengthSqr(relativePosition1) : System.Windows.PointExtensions.GetLengthSqr(relativePosition1);
                var distance2 = relativePosition2.Y <= 0 ? -System.Windows.PointExtensions.GetLengthSqr(relativePosition2) : System.Windows.PointExtensions.GetLengthSqr(relativePosition2);

                return Bridge.compare(distance1, distance2);
            }
        }
    });

    Bridge.define("System.Windows.Input.MouseDevice", {
        inherits: [System.Windows.Input.IInputDevice,System.IDisposable],
        fields: {
            hitTarget: null,
            captureTarget: null,
            isActive: false,
            target: null,
            cursor: null,
            presentationSource: null,
            pressedButtons: null
        },
        events: {
            CursorChanged: null
        },
        props: {
            HitTarget: {
                get: function () {
                    return this.hitTarget;
                },
                set: function (value) {
                    this.hitTarget = value;
                    this.SetTarget();
                }
            },
            CaptureTarget: {
                get: function () {
                    return this.captureTarget;
                },
                set: function (value) {
                    this.captureTarget = value;
                    this.SetTarget();
                }
            },
            IsActive: {
                get: function () {
                    return this.isActive;
                },
                set: function (value) {
                    this.isActive = value;
                    this.SetTarget();
                }
            },
            Target: {
                get: function () {
                    return this.target;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.target, value)) {
                        return;
                    }

                    var oldTarget = this.target;
                    this.target = value;

                    this.OnTargetChanged(oldTarget, this.target);
                }
            },
            Position: null,
            Cursor: {
                get: function () {
                    return this.cursor;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.cursor, value)) {
                        return;
                    }

                    this.cursor = value;
                    Granular.Extensions.EventHandlerExtensions.Raise$2(this.CursorChanged, this);
                }
            }
        },
        alias: [
            "dispose", "System$IDisposable$dispose",
            "Activate", "System$Windows$Input$IInputDevice$Activate",
            "Deactivate", "System$Windows$Input$IInputDevice$Deactivate"
        ],
        ctors: {
            ctor: function (presentationSource) {
                this.$initialize();
                this.presentationSource = presentationSource;
                presentationSource.System$Windows$IPresentationSource$addHitTestInvalidated(Bridge.fn.cacheBind(this, this.OnHitTestInvalidated));

                this.pressedButtons = new (System.Collections.Generic.HashSet$1(System.Windows.Input.MouseButton)).ctor();
                this.Position = System.Windows.Point.Zero;

                this.Cursor = System.Windows.Input.Cursors.Arrow;
            }
        },
        methods: {
            dispose: function () {
                this.presentationSource.System$Windows$IPresentationSource$removeHitTestInvalidated(Bridge.fn.cacheBind(this, this.OnHitTestInvalidated));
            },
            SetTarget: function () {
                this.Target = this.IsActive ? this.CaptureTarget || this.HitTarget : null;
            },
            Activate: function () {
                this.IsActive = true;
            },
            Deactivate: function () {
                var $t;
                var lastTarget = this.Target;

                this.IsActive = false;

                if (lastTarget != null) {
                    var timestamp = this.presentationSource.System$Windows$IPresentationSource$GetTimestamp();

                    $t = Bridge.getEnumerator(this.pressedButtons);
                    try {
                        while ($t.moveNext()) {
                            var button = $t.Current;
                            System.Windows.IInputElementExtensions.RaiseEvents(lastTarget, new System.Windows.Input.MouseButtonEventArgs(System.Windows.Input.Mouse.PreviewMouseUpEvent, lastTarget, this, timestamp, this.Position, button, System.Windows.Input.MouseButtonState.Released, 1), new System.Windows.Input.MouseButtonEventArgs(System.Windows.Input.Mouse.MouseUpEvent, lastTarget, this, timestamp, this.Position, button, System.Windows.Input.MouseButtonState.Released, 1));
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$dispose();
                        }
                    }}

                this.pressedButtons.clear();
            },
            ProcessRawEvent: function (rawEventArgs) {
                if (!this.IsActive) {
                    this.Activate();
                }

                this.Position = rawEventArgs.Position;
                this.HitTarget = this.presentationSource.System$Windows$IPresentationSource$HitTest(this.Position);

                if (this.Target == null) {
                    return false;
                }

                if (Bridge.is(rawEventArgs, System.Windows.Input.RawMouseButtonEventArgs)) {
                    return this.ProcessRawMouseButtonEvent(Bridge.cast(rawEventArgs, System.Windows.Input.RawMouseButtonEventArgs));
                }

                if (Bridge.is(rawEventArgs, System.Windows.Input.RawMouseWheelEventArgs)) {
                    return this.ProcessRawMouseWheelEvent(Bridge.cast(rawEventArgs, System.Windows.Input.RawMouseWheelEventArgs));
                }

                return System.Windows.IInputElementExtensions.RaiseEvents(this.Target, new System.Windows.Input.MouseEventArgs(System.Windows.Input.Mouse.PreviewMouseMoveEvent, this.Target, this, rawEventArgs.Timestamp, rawEventArgs.Position), new System.Windows.Input.MouseEventArgs(System.Windows.Input.Mouse.MouseMoveEvent, this.Target, this, rawEventArgs.Timestamp, rawEventArgs.Position));
            },
            ProcessRawMouseButtonEvent: function (rawEventArgs) {
                var isPressed = rawEventArgs.ButtonState === System.Windows.Input.MouseButtonState.Pressed;

                if (isPressed) {
                    this.pressedButtons.add(rawEventArgs.Button);
                } else {
                    this.pressedButtons.remove(rawEventArgs.Button);
                }

                return System.Windows.IInputElementExtensions.RaiseEvents(this.Target, new System.Windows.Input.MouseButtonEventArgs(isPressed ? System.Windows.Input.Mouse.PreviewMouseDownEvent : System.Windows.Input.Mouse.PreviewMouseUpEvent, this.Target, this, rawEventArgs.Timestamp, rawEventArgs.Position, rawEventArgs.Button, rawEventArgs.ButtonState, 1), new System.Windows.Input.MouseButtonEventArgs(isPressed ? System.Windows.Input.Mouse.MouseDownEvent : System.Windows.Input.Mouse.MouseUpEvent, this.Target, this, rawEventArgs.Timestamp, rawEventArgs.Position, rawEventArgs.Button, rawEventArgs.ButtonState, 1));
            },
            ProcessRawMouseWheelEvent: function (rawEventArgs) {
                return System.Windows.IInputElementExtensions.RaiseEvents(this.Target, new System.Windows.Input.MouseWheelEventArgs(System.Windows.Input.Mouse.PreviewMouseWheelEvent, this.Target, this, rawEventArgs.Timestamp, rawEventArgs.Position, rawEventArgs.Delta), new System.Windows.Input.MouseWheelEventArgs(System.Windows.Input.Mouse.MouseWheelEvent, this.Target, this, rawEventArgs.Timestamp, rawEventArgs.Position, rawEventArgs.Delta));
            },
            OnHitTestInvalidated: function (sender, e) {
                this.HitTarget = this.presentationSource.System$Windows$IPresentationSource$HitTest(this.Position);
            },
            GetButtonState: function (button) {
                return this.pressedButtons.contains(button) ? System.Windows.Input.MouseButtonState.Pressed : System.Windows.Input.MouseButtonState.Released;
            },
            Capture: function (element) {
                this.CaptureTarget = element;
            },
            ReleaseCapture: function () {
                this.CaptureTarget = null;
            },
            OnTargetChanged: function (oldTarget, newTarget) {
                var oldTargetPath = oldTarget != null ? System.Linq.Enumerable.from(oldTarget.System$Windows$IInputElement$GetPathFromRoot()).toArray() : System.Array.init(0, null, System.Windows.IInputElement);
                var newTargetPath = newTarget != null ? System.Linq.Enumerable.from(newTarget.System$Windows$IInputElement$GetPathFromRoot()).toArray() : System.Array.init(0, null, System.Windows.IInputElement);

                var splitIndex = 0;
                while (splitIndex < oldTargetPath.length && splitIndex < newTargetPath.length && Bridge.referenceEquals(oldTargetPath[System.Array.index(splitIndex, oldTargetPath)], newTargetPath[System.Array.index(splitIndex, newTargetPath)])) {
                    splitIndex = (splitIndex + 1) | 0;
                }

                var timestamp = this.presentationSource.System$Windows$IPresentationSource$GetTimestamp();

                for (var i = (oldTargetPath.length - 1) | 0; i >= splitIndex; i = (i - 1) | 0) {
                    oldTargetPath[System.Array.index(i, oldTargetPath)].System$Windows$IInputElement$RaiseEvent(new System.Windows.Input.MouseEventArgs(System.Windows.Input.Mouse.MouseLeaveEvent, oldTargetPath[System.Array.index(i, oldTargetPath)], this, timestamp, this.Position));
                }

                for (var i1 = splitIndex; i1 < newTargetPath.length; i1 = (i1 + 1) | 0) {
                    newTargetPath[System.Array.index(i1, newTargetPath)].System$Windows$IInputElement$RaiseEvent(new System.Windows.Input.MouseEventArgs(System.Windows.Input.Mouse.MouseEnterEvent, newTargetPath[System.Array.index(i1, newTargetPath)], this, timestamp, this.Position));
                }

                this.Cursor = this.QueryCursor(timestamp);
            },
            UpdateCursor: function () {
                this.Cursor = this.QueryCursor(this.presentationSource.System$Windows$IPresentationSource$GetTimestamp());
            },
            QueryCursor: function (timestamp) {
                if (this.Target == null) {
                    return System.Windows.Input.Cursors.Arrow;
                }

                var e = new System.Windows.Input.QueryCursorEventArgs(System.Windows.Input.Mouse.QueryCursorEvent, this.Target, this, timestamp, this.Position);
                e.Cursor = System.Windows.Input.Cursors.Arrow;
                this.Target.System$Windows$IInputElement$RaiseEvent(e);

                return e.Handled ? e.Cursor : System.Windows.Input.Cursors.Arrow;
            }
        }
    });

    Bridge.define("System.Windows.Input.RawKeyboardEventArgs", {
        inherits: [System.Windows.Input.RawEventArgs],
        props: {
            Key: 0,
            KeyStates: 0,
            IsRepeat: false
        },
        ctors: {
            ctor: function (key, keyStates, isRepeat, timestamp) {
                this.$initialize();
                System.Windows.Input.RawEventArgs.ctor.call(this, timestamp);
                this.Key = key;
                this.KeyStates = keyStates;
                this.IsRepeat = isRepeat;
            }
        }
    });

    Bridge.define("System.Windows.Input.RawMouseEventArgs", {
        inherits: [System.Windows.Input.RawEventArgs],
        props: {
            Position: null
        },
        ctors: {
            ctor: function (position, timestamp) {
                this.$initialize();
                System.Windows.Input.RawEventArgs.ctor.call(this, timestamp);
                this.Position = position;
            }
        }
    });

    Bridge.define("System.Windows.Markup.BooleanTypeConverter", {
        inherits: [System.Windows.Markup.ITypeConverter],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Markup.BooleanTypeConverter();
                }
            }
        },
        alias: ["ConvertFrom", "System$Windows$Markup$ITypeConverter$ConvertFrom"],
        ctors: {
            ctor: function () {
                this.$initialize();
                //
            }
        },
        methods: {
            ConvertFrom: function (namespaces, sourceUri, value) {
                var text = value.toString().trim().toLowerCase();

                if (!Bridge.referenceEquals(text, "true") && !Bridge.referenceEquals(text, "false")) {
                    throw new Granular.Exception("Can't convert \"{0}\" to boolean", [text]);
                }

                return Bridge.box(Bridge.referenceEquals(text, "true"), System.Boolean, System.Boolean.toString);
            }
        }
    });

    Bridge.define("System.Windows.Markup.ClrEventAdapter", {
        inherits: [System.Windows.Markup.IEventAdapter],
        fields: {
            eventInfo: null
        },
        props: {
            HandlerType: {
                get: function () {
                    return System.Reflection.EventInfoExtensions.GetEventHandlerType(this.eventInfo);
                }
            }
        },
        alias: [
            "HandlerType", "System$Windows$Markup$IEventAdapter$HandlerType",
            "AddHandler", "System$Windows$Markup$IEventAdapter$AddHandler"
        ],
        ctors: {
            ctor: function (eventInfo) {
                this.$initialize();
                this.eventInfo = eventInfo;
            }
        },
        methods: {
            AddHandler: function (target, handler) {
                Bridge.Reflection.midel(this.eventInfo.ad, target)(handler);
            }
        }
    });

    Bridge.define("System.Windows.Markup.ClrPropertyAdapter", {
        inherits: [System.Windows.Markup.IPropertyAdapter],
        fields: {
            property: null,
            index: null
        },
        props: {
            PropertyType: {
                get: function () {
                    return this.property.rt;
                }
            },
            HasGetter: {
                get: function () {
                    return System.Reflection.PropertyInfoExtensions.GetGetMethod(this.property) != null;
                }
            },
            HasSetter: {
                get: function () {
                    return System.Reflection.PropertyInfoExtensions.GetSetMethod(this.property) != null;
                }
            }
        },
        alias: [
            "PropertyType", "System$Windows$Markup$IPropertyAdapter$PropertyType",
            "HasGetter", "System$Windows$Markup$IPropertyAdapter$HasGetter",
            "HasSetter", "System$Windows$Markup$IPropertyAdapter$HasSetter",
            "GetValue", "System$Windows$Markup$IPropertyAdapter$GetValue",
            "SetValue", "System$Windows$Markup$IPropertyAdapter$SetValue"
        ],
        ctors: {
            ctor: function (property, index) {
                if (index === void 0) { index = null; }

                this.$initialize();
                this.property = property;
                this.index = index || System.Array.init(0, null, System.Object);
            }
        },
        methods: {
            GetValue: function (target) {
                return Bridge.Reflection.midel(this.property.g, Bridge.unbox(target)).apply(null, Bridge.unbox(this.index));
            },
            SetValue: function (target, value, valueSource) {
                Bridge.Reflection.midel(this.property.s, Bridge.unbox(target)).apply(null, (Bridge.unbox(this.index) || []).concat(Bridge.unbox(value)));
            }
        }
    });

    Bridge.define("System.Windows.Markup.ConstantElementFactory", {
        inherits: [System.Windows.Markup.IElementFactory],
        fields: {
            value: null
        },
        props: {
            ElementType: null
        },
        alias: [
            "ElementType", "System$Windows$Markup$IElementFactory$ElementType",
            "CreateElement", "System$Windows$Markup$IElementFactory$CreateElement"
        ],
        ctors: {
            ctor: function (value) {
                this.$initialize();
                this.value = value;
                this.ElementType = Bridge.getType(value);
            }
        },
        methods: {
            CreateElement: function (context) {
                return this.value;
            }
        }
    });

    Bridge.define("System.Windows.Markup.ContentPropertyAttribute", {
        inherits: [System.Windows.Markup.PropertyAttribute],
        statics: {
            fields: {
                propertyNameCache: null
            },
            ctors: {
                init: function () {
                    this.propertyNameCache = Granular.Collections.CacheDictionary$2(Function,System.String).CreateUsingStringKeys($asm.$.System.Windows.Markup.ContentPropertyAttribute.f1, $asm.$.System.Windows.Markup.ContentPropertyAttribute.f2);
                }
            },
            methods: {
                GetPropertyName: function (type) {
                    return System.Windows.Markup.ContentPropertyAttribute.propertyNameCache.GetValue(type);
                }
            }
        },
        ctors: {
            ctor: function (name) {
                this.$initialize();
                System.Windows.Markup.PropertyAttribute.ctor.call(this, name);
                //
            }
        }
    });

    Bridge.ns("System.Windows.Markup.ContentPropertyAttribute", $asm.$);

    Bridge.apply($asm.$.System.Windows.Markup.ContentPropertyAttribute, {
        f1: function (type) {
            return System.Windows.Markup.PropertyAttribute.ResolvePropertyName(System.Windows.Markup.ContentPropertyAttribute, type);
        },
        f2: function (type) {
            return Bridge.Reflection.getTypeFullName(type);
        }
    });

    Bridge.define("System.Windows.Markup.ConvertedElementFactory", {
        inherits: [System.Windows.Markup.IElementFactory],
        fields: {
            valueFactory: null,
            namespaces: null,
            sourceUri: null,
            typeConverter: null
        },
        props: {
            ElementType: null
        },
        alias: [
            "ElementType", "System$Windows$Markup$IElementFactory$ElementType",
            "CreateElement", "System$Windows$Markup$IElementFactory$CreateElement"
        ],
        ctors: {
            ctor: function (elementFactory, elementTargetType, namespaces, sourceUri) {
                this.$initialize();
                this.valueFactory = elementFactory;
                this.ElementType = elementTargetType;
                this.namespaces = namespaces;
                this.sourceUri = sourceUri;
                this.typeConverter = System.Windows.Markup.TypeConverter.GetTypeConverter(elementFactory.System$Windows$Markup$IElementFactory$ElementType, elementTargetType);
            }
        },
        methods: {
            CreateElement: function (context) {
                return this.typeConverter.System$Windows$Markup$ITypeConverter$ConvertFrom(this.namespaces, this.sourceUri, this.valueFactory.System$Windows$Markup$IElementFactory$CreateElement(context));
            }
        }
    });

    Bridge.define("System.Windows.Markup.DependencyPropertyAdapter", {
        inherits: [System.Windows.Markup.IPropertyAdapter],
        fields: {
            property: null
        },
        props: {
            PropertyType: {
                get: function () {
                    return this.property.PropertyType;
                }
            },
            HasGetter: {
                get: function () {
                    return true;
                }
            },
            HasSetter: {
                get: function () {
                    return !this.property.IsReadOnly;
                }
            }
        },
        alias: [
            "PropertyType", "System$Windows$Markup$IPropertyAdapter$PropertyType",
            "HasGetter", "System$Windows$Markup$IPropertyAdapter$HasGetter",
            "HasSetter", "System$Windows$Markup$IPropertyAdapter$HasSetter",
            "GetValue", "System$Windows$Markup$IPropertyAdapter$GetValue",
            "SetValue", "System$Windows$Markup$IPropertyAdapter$SetValue"
        ],
        ctors: {
            ctor: function (property) {
                this.$initialize();
                this.property = property;
            }
        },
        methods: {
            GetValue: function (target) {
                return Bridge.cast(target, System.Windows.DependencyObject).GetValue(this.property);
            },
            SetValue: function (target, value, valueSource) {
                Bridge.cast(target, System.Windows.DependencyObject).SetValue(this.property, value, valueSource);
            }
        }
    });

    Bridge.define("System.Windows.Markup.DictionaryKeyPropertyAttribute", {
        inherits: [System.Windows.Markup.PropertyAttribute],
        statics: {
            fields: {
                propertyNameCache: null
            },
            ctors: {
                init: function () {
                    this.propertyNameCache = Granular.Collections.CacheDictionary$2(Function,System.String).CreateUsingStringKeys($asm.$.System.Windows.Markup.DictionaryKeyPropertyAttribute.f1, $asm.$.System.Windows.Markup.DictionaryKeyPropertyAttribute.f2);
                }
            },
            methods: {
                GetPropertyName: function (type) {
                    return System.Windows.Markup.DictionaryKeyPropertyAttribute.propertyNameCache.GetValue(type);
                }
            }
        },
        ctors: {
            ctor: function (name) {
                this.$initialize();
                System.Windows.Markup.PropertyAttribute.ctor.call(this, name);
                //
            }
        }
    });

    Bridge.ns("System.Windows.Markup.DictionaryKeyPropertyAttribute", $asm.$);

    Bridge.apply($asm.$.System.Windows.Markup.DictionaryKeyPropertyAttribute, {
        f1: function (type) {
            return System.Windows.Markup.PropertyAttribute.ResolvePropertyName(System.Windows.Markup.DictionaryKeyPropertyAttribute, type);
        },
        f2: function (type) {
            return Bridge.Reflection.getTypeFullName(type);
        }
    });

    Bridge.define("System.Windows.Markup.DoubleTypeConverter", {
        inherits: [System.Windows.Markup.ITypeConverter],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Markup.DoubleTypeConverter();
                }
            }
        },
        alias: ["ConvertFrom", "System$Windows$Markup$ITypeConverter$ConvertFrom"],
        ctors: {
            ctor: function () {
                this.$initialize();
                //
            }
        },
        methods: {
            ConvertFrom: function (namespaces, sourceUri, value) {
                var text = value.toString().trim().toLowerCase();

                if (Bridge.referenceEquals(text, "auto")) {
                    return Bridge.box(Number.NaN, System.Double, System.Double.format, System.Double.getHashCode);
                }

                return Bridge.box(System.Double.parse(text), System.Double, System.Double.format, System.Double.getHashCode);
            }
        }
    });

    Bridge.define("System.Windows.Markup.ElementCollectionContentInitializer", {
        inherits: [System.Windows.Markup.IElementInitializer],
        fields: {
            elementsFactory: null
        },
        alias: ["InitializeElement", "System$Windows$Markup$IElementInitializer$InitializeElement"],
        ctors: {
            ctor: function (valueTargetType, values) {
                this.$initialize();
                this.elementsFactory = Granular.Compatibility.Linq.Enumerable.ToArray(Bridge.global.System.Windows.Markup.IElementFactory, Granular.Compatibility.Linq.Enumerable.Select(System.Object, Bridge.global.System.Windows.Markup.IElementFactory, values, function (value) {
                    return System.Windows.Markup.ElementFactory.FromValue(value, valueTargetType, System.Windows.Markup.XamlNamespaces.Empty, null);
                }));
            }
        },
        methods: {
            InitializeElement: function (element, context) {
                var $t;
                $t = Bridge.getEnumerator(this.elementsFactory, System.Windows.Markup.IElementFactory);
                try {
                    while ($t.moveNext()) {
                        var elementFactory = $t.Current;
                        element.add(elementFactory.System$Windows$Markup$IElementFactory$CreateElement(context));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }}
        }
    });

    Bridge.define("System.Windows.Markup.ElementDictionaryContentInitializer", {
        inherits: [System.Windows.Markup.IElementInitializer],
        statics: {
            methods: {
                CreateElementsFactories: function (dictionaryType, keyType, valueType, values) {
                    var $t;
                    if (Granular.Compatibility.Linq.Enumerable.Any$1(System.Object, values, $asm.$.System.Windows.Markup.ElementDictionaryContentInitializer.f1)) {
                        throw new Granular.Exception("Can't add a value of type \"{0}\" to a dictionary, as it cannot have a key", [Bridge.Reflection.getTypeName(Bridge.getType(Granular.Compatibility.Linq.Enumerable.First$1(System.Object, values, $asm.$.System.Windows.Markup.ElementDictionaryContentInitializer.f1)))]);
                    }

                    var valuesElements = System.Linq.Enumerable.from(values).select(function(x) { return Bridge.cast(x, System.Windows.Markup.XamlElement); });

                    var isValueProviderSupported = Granular.Compatibility.Linq.Enumerable.Any(Bridge.global.System.Windows.Markup.SupportsValueProviderAttribute, Granular.Compatibility.Linq.Enumerable.OfType(System.Windows.Markup.SupportsValueProviderAttribute, Bridge.Reflection.getAttributes(dictionaryType, null, true)));

                    var list = new (System.Collections.Generic.List$1(System.Windows.Markup.ElementDictionaryContentInitializer.KeyValueElementFactory)).ctor();

                    $t = Bridge.getEnumerator(valuesElements, System.Windows.Markup.XamlElement);
                    try {
                        while ($t.moveNext()) {
                            var contentChild = $t.Current;
                            var isShared = Granular.Compatibility.Linq.Enumerable.All(Bridge.global.System.Windows.Markup.XamlMember, contentChild.Directives, $asm.$.System.Windows.Markup.ElementDictionaryContentInitializer.f2);

                            if (!isShared && !isValueProviderSupported) {
                                throw new Granular.Exception(System.String.format("Can't add a non shared value to \"{0}\" as it does not declare a \"SupportsValueProvider\" attribute", Bridge.Reflection.getTypeFullName(dictionaryType)));
                            }

                            var contentChildFactory = isValueProviderSupported ? new System.Windows.Markup.ElementDictionaryContentInitializer.DeferredValueFactory(contentChild, valueType, isShared) : System.Windows.Markup.ElementFactory.FromXamlElement(contentChild, valueType);

                            list.add(new System.Windows.Markup.ElementDictionaryContentInitializer.KeyValueElementFactory(keyType, contentChildFactory, contentChild, isValueProviderSupported));
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$dispose();
                        }
                    }
                    return list;
                }
            }
        },
        fields: {
            keyElementFactories: null
        },
        alias: ["InitializeElement", "System$Windows$Markup$IElementInitializer$InitializeElement"],
        ctors: {
            ctor: function (dictionaryType, keyType, valueType, values) {
                this.$initialize();
                this.keyElementFactories = System.Windows.Markup.ElementDictionaryContentInitializer.CreateElementsFactories(dictionaryType, keyType, valueType, values);
            }
        },
        methods: {
            InitializeElement: function (element, context) {
                var $t;
                $t = Bridge.getEnumerator(this.keyElementFactories, System.Windows.Markup.ElementDictionaryContentInitializer.KeyValueElementFactory);
                try {
                    while ($t.moveNext()) {
                        var keyElementFactory = $t.Current;
                        var pair = keyElementFactory.CreateElement(context);

                        element.add(pair.key, pair.value);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }}
        }
    });

    Bridge.ns("System.Windows.Markup.ElementDictionaryContentInitializer", $asm.$);

    Bridge.apply($asm.$.System.Windows.Markup.ElementDictionaryContentInitializer, {
        f1: function (value) {
            return !(Bridge.is(value, System.Windows.Markup.XamlElement));
        },
        f2: function (directive) {
            return System.Windows.Markup.XamlName.op_Inequality(directive.Name, System.Windows.Markup.XamlLanguage.SharedDirective) || System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Windows.Markup.TypeConverter.ConvertValue(System.Windows.Markup.XamlMemberExtensions.GetSingleValue(directive), System.Boolean, System.Windows.Markup.XamlNamespaces.Empty, null)), System.Boolean));
        }
    });

    Bridge.define("System.Windows.Markup.ElementDictionaryContentInitializer.DeferredKeyFactory", {
        inherits: [System.Windows.Markup.IElementFactory],
        fields: {
            provider: null,
            element: null
        },
        props: {
            ElementType: {
                get: function () {
                    return System.Object;
                }
            }
        },
        alias: [
            "ElementType", "System$Windows$Markup$IElementFactory$ElementType",
            "CreateElement", "System$Windows$Markup$IElementFactory$CreateElement"
        ],
        ctors: {
            ctor: function (provider, element) {
                this.$initialize();
                this.provider = provider;
                this.element = element;
            }
        },
        methods: {
            CreateElement: function (context) {
                return this.provider.System$Windows$Markup$IDeferredValueKeyProvider$GetValueKey(this.element);
            }
        }
    });

    Bridge.define("System.Windows.Markup.ElementDictionaryContentInitializer.DeferredValueFactory", {
        inherits: [System.Windows.Markup.IElementFactory],
        fields: {
            element: null,
            targetType: null,
            isShared: false,
            elementFactory: null
        },
        props: {
            ElementType: {
                get: function () {
                    return System.Windows.Markup.ValueProvider;
                }
            }
        },
        alias: [
            "ElementType", "System$Windows$Markup$IElementFactory$ElementType",
            "CreateElement", "System$Windows$Markup$IElementFactory$CreateElement"
        ],
        ctors: {
            ctor: function (element, targetType, isShared) {
                this.$initialize();
                this.element = element;
                this.targetType = targetType;
                this.isShared = isShared;
            }
        },
        methods: {
            CreateElement: function (context) {
                var value = null;

                return new System.Windows.Markup.ValueProvider(Bridge.fn.bind(this, function () {
                    if (this.elementFactory == null) {
                        this.elementFactory = System.Windows.Markup.ElementFactory.FromXamlElement(this.element, this.targetType);
                    }

                    if (value == null || !this.isShared) {
                        value = this.elementFactory.System$Windows$Markup$IElementFactory$CreateElement(context);
                    }

                    return value;
                }));
            }
        }
    });

    Bridge.define("System.Windows.Markup.ElementEventMemberInitializer", {
        inherits: [System.Windows.Markup.IElementInitializer],
        statics: {
            methods: {
                CreateEventHandler: function (eventHandlerType, source, eventHandlerName) {
                    var methodInfo = Bridge.Reflection.getMembers(Bridge.getType(source), 8, 116 | 256, eventHandlerName);

                    if (methodInfo == null) {
                        throw new Granular.Exception("Type \"{0}\" does not contain an event handler named \"{1}\"", [Bridge.Reflection.getTypeName(Bridge.getType(source)), eventHandlerName]);
                    }

                    return Bridge.Reflection.createDelegate(methodInfo, source);
                }
            }
        },
        fields: {
            eventAdapter: null,
            eventHandlerName: null
        },
        alias: ["InitializeElement", "System$Windows$Markup$IElementInitializer$InitializeElement"],
        ctors: {
            ctor: function (eventAdapter, eventHandlerName) {
                this.$initialize();
                this.eventAdapter = eventAdapter;
                this.eventHandlerName = eventHandlerName;
            }
        },
        methods: {
            InitializeElement: function (element, context) {
                this.eventAdapter.System$Windows$Markup$IEventAdapter$AddHandler(element, System.Windows.Markup.ElementEventMemberInitializer.CreateEventHandler(this.eventAdapter.System$Windows$Markup$IEventAdapter$HandlerType, context.Root, this.eventHandlerName));
            }
        }
    });

    Bridge.define("System.Windows.Markup.ElementFactory", {
        inherits: [System.Windows.Markup.IElementFactory],
        statics: {
            methods: {
                FromValue: function (value, targetType, namespaces, sourceUri) {
                    if (Bridge.is(value, System.Windows.Markup.XamlElement)) {
                        return System.Windows.Markup.ElementFactory.FromXamlElement(Bridge.cast(value, System.Windows.Markup.XamlElement), targetType);
                    }

                    return System.Windows.Markup.ElementFactory.FromElementFactory(new System.Windows.Markup.ConstantElementFactory(value), targetType, namespaces, sourceUri);
                },
                FromXamlElement: function (element, targetType) {
                    var elementType = System.Windows.Markup.XamlElementExtensions.GetElementType(element);

                    if (Granular.Compatibility.Linq.Enumerable.Any(System.Object, element.Values) && Granular.Extensions.StringExtensions.IsNullOrEmpty(System.Windows.Markup.ContentPropertyAttribute.GetPropertyName(elementType)) && !System.Windows.Markup.ElementCollectionContentInitailizer.IsCollectionType(elementType)) {
                        return System.Windows.Markup.ElementFactory.FromElementFactory(System.Windows.Markup.ElementFactory.FromXamlElementContent(element), targetType, element.Namespaces, element.SourceUri);
                    }

                    var elementInitializer = new System.Windows.Markup.ElementInitializer(element);
                    var elementFactory = new System.Windows.Markup.ElementFactory(elementType, elementInitializer);

                    return System.Windows.Markup.ElementFactory.FromElementFactory(elementFactory, targetType, element.Namespaces, element.SourceUri);
                },
                FromXamlElementContent: function (element) {
                    if (Granular.Compatibility.Linq.Enumerable.Any(Bridge.global.System.Windows.Markup.XamlMember, element.Members)) {
                        throw new Granular.Exception("Element \"{0}\" can't have members, as it's not a collection type and does not declare ContentProperty and can only be converted from its content", [element.Name]);
                    }

                    if (Granular.Compatibility.Linq.Enumerable.Count(System.Object, element.Values) > 1) {
                        throw new Granular.Exception("Element \"{0}\" can't have multiple children, as it's not a collection type and does not declare ContentProperty and can only be converted from its content", [element.Name]);
                    }

                    return System.Windows.Markup.ElementFactory.FromValue(Granular.Compatibility.Linq.Enumerable.First(System.Object, element.Values), System.Windows.Markup.XamlElementExtensions.GetElementType(element), element.Namespaces, element.SourceUri);
                },
                FromElementFactory: function (elementFactory, targetType, namespaces, sourceUri) {
                    if (Bridge.Reflection.isAssignableFrom(System.Windows.Markup.IMarkupExtension, elementFactory.System$Windows$Markup$IElementFactory$ElementType)) {
                        return new System.Windows.Markup.MarkupExtensionElementFactory(elementFactory);
                    }

                    if (targetType != null && !Bridge.Reflection.isAssignableFrom(targetType, elementFactory.System$Windows$Markup$IElementFactory$ElementType)) {
                        return new System.Windows.Markup.ConvertedElementFactory(elementFactory, targetType, namespaces, sourceUri);
                    }

                    return elementFactory;
                }
            }
        },
        fields: {
            elementInitializer: null
        },
        props: {
            ElementType: null
        },
        alias: [
            "ElementType", "System$Windows$Markup$IElementFactory$ElementType",
            "CreateElement", "System$Windows$Markup$IElementFactory$CreateElement"
        ],
        ctors: {
            ctor: function (elementType, elementInitializer) {
                this.$initialize();
                this.ElementType = elementType;
                this.elementInitializer = elementInitializer;
            }
        },
        methods: {
            CreateElement: function (context) {
                var target = Bridge.createInstance(this.ElementType);
                this.elementInitializer.System$Windows$Markup$IElementInitializer$InitializeElement(target, context);
                return target;
            }
        }
    });

    Bridge.define("System.Windows.Markup.ElementInitializer", {
        inherits: [System.Windows.Markup.IElementInitializer],
        statics: {
            fields: {
                Empty: null
            },
            ctors: {
                init: function () {
                    this.Empty = new System.Windows.Markup.ElementInitializer.EmptyElementInitializer();
                }
            },
            methods: {
                CreateContentInitializer: function (element, elementType) {
                    if (!Granular.Compatibility.Linq.Enumerable.Any(System.Object, element.Values)) {
                        return null;
                    }

                    var contentPropertyName = System.Windows.Markup.ContentPropertyAttribute.GetPropertyName(elementType);
                    if (!Granular.Extensions.StringExtensions.IsNullOrEmpty(contentPropertyName)) {
                        return System.Windows.Markup.ElementMemberInitializer.Create(elementType, contentPropertyName, element.Values, element.Namespaces, element.SourceUri);
                    }

                    if (System.Windows.Markup.ElementCollectionContentInitailizer.IsCollectionType(elementType)) {
                        return System.Windows.Markup.ElementCollectionContentInitailizer.Create(element.Values, elementType);
                    }

                    throw new Granular.Exception("Cannot add content to element of type \"{0}\" as it's not a collection type and does not declare ContentProperty", [Bridge.Reflection.getTypeName(elementType)]);
                },
                CreateMemberInitializers: function (element, elementType) {
                    var $t;
                    var list = new (System.Collections.Generic.List$1(System.Windows.Markup.IElementInitializer)).ctor();

                    var index = 0;
                    $t = Bridge.getEnumerator(element.Members, System.Windows.Markup.XamlMember);
                    try {
                        while ($t.moveNext()) {
                            var member = $t.Current;
                            // markup extensions may contain members with an empty name, the name should be resolved from the member index
                            var memberName = member.Name.IsEmpty ? System.Windows.Markup.ElementInitializer.GetParameterName(elementType, index) : member.Name;

                            list.add(System.Windows.Markup.ElementMemberInitializer.Create(System.Windows.Markup.XamlNameExtensions.ResolveContainingType(memberName, elementType), memberName.MemberName, member.Values, member.Namespaces, member.SourceUri));
                            index = (index + 1) | 0;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$dispose();
                        }
                    }
                    return list;
                },
                GetParameterName: function (type, index) {
                    var parameterAttribute = Granular.Compatibility.Linq.Enumerable.FirstOrDefault$1(Bridge.global.System.Windows.Markup.MarkupExtensionParameterAttribute, Granular.Compatibility.Linq.Enumerable.OfType(System.Windows.Markup.MarkupExtensionParameterAttribute, Bridge.Reflection.getAttributes(type, null, true)), function (attribute) {
                        return attribute.Index === index;
                    });

                    if (parameterAttribute == null) {
                        throw new Granular.Exception("Type \"{0}\" does not declare MarkupExtensionParameter for index {1}", [Bridge.Reflection.getTypeName(type), Bridge.box(index, System.Int32)]);
                    }

                    return new System.Windows.Markup.XamlName(parameterAttribute.Name);
                },
                GetNameDirectiveValue: function (element) {
                    var nameDirective = Granular.Compatibility.Linq.Enumerable.FirstOrDefault$1(Bridge.global.System.Windows.Markup.XamlMember, element.Directives, $asm.$.System.Windows.Markup.ElementInitializer.f1);
                    return nameDirective != null ? Bridge.cast(System.Windows.Markup.XamlMemberExtensions.GetSingleValue(nameDirective), System.String) : null;
                },
                GetNameProperty: function (type) {
                    var propertyName = System.Windows.Markup.RuntimeNamePropertyAttribute.GetPropertyName(type);
                    return !Granular.Extensions.StringExtensions.IsNullOrWhiteSpace(propertyName) ? System.Windows.Markup.PropertyAdapter.CreateAdapter(type, propertyName) : null;
                },
                SetFieldValue: function (target, fieldName, fieldValue) {
                    var fieldInfo = Bridge.Reflection.getMembers(Bridge.getType(target), 4, 36 | 256, fieldName);

                    if (fieldInfo == null) {
                        return;
                    }

                    if (!Bridge.referenceEquals(fieldInfo.rt, Bridge.getType(fieldValue))) {
                        throw new Granular.Exception("Cannot assign \"{0}\" of type \"{1}\" to field \"{2}.{3}\" of type \"{4}\"", [fieldName, Bridge.Reflection.getTypeName(Bridge.getType(fieldValue)), Bridge.Reflection.getTypeName(Bridge.getType(target)), fieldName, fieldInfo.rt]);
                    }

                    Bridge.Reflection.fieldAccess(fieldInfo, Bridge.unbox(target), Bridge.unbox(fieldValue));
                }
            }
        },
        fields: {
            elementType: null,
            namespaces: null,
            sourceUri: null,
            memberInitializers: null,
            contentInitializer: null,
            nameProperty: null,
            nameDirectiveValue: null
        },
        alias: ["InitializeElement", "System$Windows$Markup$IElementInitializer$InitializeElement"],
        ctors: {
            ctor: function (element) {
                this.$initialize();
                this.elementType = System.Windows.Markup.XamlElementExtensions.GetElementType(element);
                this.namespaces = element.Namespaces;
                this.sourceUri = element.SourceUri;

                this.memberInitializers = System.Windows.Markup.ElementInitializer.CreateMemberInitializers(element, this.elementType);
                this.contentInitializer = System.Windows.Markup.ElementInitializer.CreateContentInitializer(element, this.elementType);

                this.nameDirectiveValue = System.Windows.Markup.ElementInitializer.GetNameDirectiveValue(element);
                this.nameProperty = System.Windows.Markup.ElementInitializer.GetNameProperty(System.Windows.Markup.XamlElementExtensions.GetElementType(element));
            }
        },
        methods: {
            InitializeElement: function (element, context) {
                var $t, $t1;
                context = System.Windows.Markup.InitializeContextExtensions.CreateChildContext(context, element);

                if (!Bridge.Reflection.isAssignableFrom(this.elementType, Bridge.getType(element))) {
                    throw new Granular.Exception("Can't initialize element of type \"{0}\" as it's not a subclass of \"{1}\"", [Bridge.Reflection.getTypeName(Bridge.getType(element)), Bridge.Reflection.getTypeName(this.elementType)]);
                }

                if (Bridge.is(element, System.Windows.Markup.ISupportInitialize)) {
                    Bridge.cast(element, System.Windows.Markup.ISupportInitialize).System$Windows$Markup$ISupportInitialize$BeginInit();
                }

                if (Bridge.is(element, System.Windows.Markup.IUriContext)) {
                    Bridge.cast(element, System.Windows.Markup.IUriContext).System$Windows$Markup$IUriContext$BaseUri = this.sourceUri;
                }

                if (Bridge.referenceEquals(element, context.Root) && Bridge.is(element, System.Windows.DependencyObject)) {
                    System.Windows.NameScope.SetNameScope(Bridge.cast(element, System.Windows.DependencyObject), context.NameScope);
                }

                if (Bridge.is(element, System.Windows.FrameworkElement)) {
                    Bridge.cast(element, System.Windows.FrameworkElement).TemplatedParent = context.TemplatedParent;
                }

                $t = Bridge.getEnumerator(this.memberInitializers, System.Windows.Markup.IElementInitializer);
                try {
                    while ($t.moveNext()) {
                        var memberInitializer = $t.Current;
                        memberInitializer.System$Windows$Markup$IElementInitializer$InitializeElement(element, context);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                var name = Granular.Extensions.StringExtensions.DefaultIfNullOrEmpty(this.nameDirectiveValue, this.nameProperty != null ? Bridge.cast(this.nameProperty.System$Windows$Markup$IPropertyAdapter$GetValue(element), System.String) : "");

                if (!Granular.Extensions.StringExtensions.IsNullOrEmpty(this.nameDirectiveValue) && this.nameProperty != null) {
                    // name property exists, but the name directive was used, so update the property
                    this.nameProperty.System$Windows$Markup$IPropertyAdapter$SetValue(element, name, context.ValueSource);
                }

                if (!Granular.Extensions.StringExtensions.IsNullOrEmpty(name)) {
                    context.NameScope.System$Windows$INameScope$registerName(name, element);
                }

                if (this.contentInitializer != null) {
                    this.contentInitializer.System$Windows$Markup$IElementInitializer$InitializeElement(element, context);
                }

                if (Bridge.referenceEquals(element, context.Root)) {
                    $t1 = Bridge.getEnumerator(context.NameScope, System.Collections.Generic.KeyValuePair$2(System.String,System.Object));
                    try {
                        while ($t1.moveNext()) {
                            var pair = $t1.Current;
                            System.Windows.Markup.ElementInitializer.SetFieldValue(element, pair.key, pair.value);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$dispose();
                        }
                    }}

                if (Bridge.is(element, System.Windows.Markup.ISupportInitialize)) {
                    Bridge.cast(element, System.Windows.Markup.ISupportInitialize).System$Windows$Markup$ISupportInitialize$EndInit();
                }
            }
        }
    });

    Bridge.ns("System.Windows.Markup.ElementInitializer", $asm.$);

    Bridge.apply($asm.$.System.Windows.Markup.ElementInitializer, {
        f1: function (directive) {
            return System.Windows.Markup.XamlName.op_Equality(directive.Name, System.Windows.Markup.XamlLanguage.NameDirective);
        }
    });

    Bridge.define("System.Windows.Markup.ElementInitializer.EmptyElementInitializer", {
        inherits: [System.Windows.Markup.IElementInitializer],
        alias: ["InitializeElement", "System$Windows$Markup$IElementInitializer$InitializeElement"],
        methods: {
            InitializeElement: function (element, context) {
                //
            }
        }
    });

    Bridge.define("System.Windows.Markup.ElementPropertyMemberInitializer", {
        inherits: [System.Windows.Markup.IElementInitializer],
        statics: {
            methods: {
                Create: function (propertyAdapter, values, namespaces, sourceUri) {
                    if (!Granular.Compatibility.Linq.Enumerable.Any(System.Object, values)) {
                        return System.Windows.Markup.ElementInitializer.Empty;
                    }

                    if (Granular.Compatibility.Linq.Enumerable.Count(System.Object, values) === 1) {
                        var value = Granular.Compatibility.Linq.Enumerable.First(System.Object, values);

                        if (Bridge.referenceEquals(propertyAdapter.System$Windows$Markup$IPropertyAdapter$PropertyType, System.Windows.IFrameworkElementFactory)) {
                            return new System.Windows.Markup.FrameworkElementFactoryInitializer(propertyAdapter, System.Windows.Markup.ElementFactory.FromValue(value, null, namespaces, sourceUri));
                        }

                        var valueType = Bridge.is(value, System.Windows.Markup.XamlElement) ? System.Windows.Markup.XamlElementExtensions.GetElementType(Bridge.cast(value, System.Windows.Markup.XamlElement)) : Bridge.getType(value);

                        var typeConverter = { };
                        if (Bridge.Reflection.isAssignableFrom(propertyAdapter.System$Windows$Markup$IPropertyAdapter$PropertyType, valueType) || Bridge.Reflection.isAssignableFrom(System.Windows.Markup.IMarkupExtension, valueType) || System.Windows.Markup.TypeConverter.TryGetTypeConverter(valueType, propertyAdapter.System$Windows$Markup$IPropertyAdapter$PropertyType, typeConverter)) {
                            var contentFactory = System.Windows.Markup.ElementFactory.FromValue(value, propertyAdapter.System$Windows$Markup$IPropertyAdapter$PropertyType, namespaces, sourceUri);
                            return new System.Windows.Markup.ElementPropertyMemberInitializer(propertyAdapter, contentFactory);
                        }
                    }

                    if (System.Windows.Markup.ElementCollectionContentInitailizer.IsCollectionType(propertyAdapter.System$Windows$Markup$IPropertyAdapter$PropertyType)) {
                        var propertyContentInitializer = System.Windows.Markup.ElementCollectionContentInitailizer.Create(values, propertyAdapter.System$Windows$Markup$IPropertyAdapter$PropertyType);

                        // wrap with a factory that creates the collection (when it's null) before adding its values
                        return new System.Windows.Markup.ElementPropertyMemberInitializer.ElementPropertyMemberFactoryInitializer(propertyAdapter, propertyContentInitializer);
                    }

                    if (Granular.Compatibility.Linq.Enumerable.Count(System.Object, values) === 1) {
                        var value1 = Granular.Compatibility.Linq.Enumerable.First(System.Object, values);
                        throw new Granular.Exception("Cannot assign value of type \"{0}\" to member of type \"{1}\"", [Bridge.is(value1, System.Windows.Markup.XamlElement) ? System.Windows.Markup.XamlElementExtensions.GetElementType(Bridge.cast(value1, System.Windows.Markup.XamlElement)) : Bridge.getType(value1), Bridge.Reflection.getTypeName(propertyAdapter.System$Windows$Markup$IPropertyAdapter$PropertyType)]);
                    }

                    throw new Granular.Exception("Member of type \"{0}\" cannot have more than one child", [Bridge.Reflection.getTypeName(propertyAdapter.System$Windows$Markup$IPropertyAdapter$PropertyType)]);
                }
            }
        },
        fields: {
            propertyAdapter: null,
            propertyValueFactory: null
        },
        alias: ["InitializeElement", "System$Windows$Markup$IElementInitializer$InitializeElement"],
        ctors: {
            ctor: function (propertyAdapter, propertyValueFactory) {
                this.$initialize();
                this.propertyAdapter = propertyAdapter;
                this.propertyValueFactory = propertyValueFactory;
            }
        },
        methods: {
            InitializeElement: function (element, context) {
                this.propertyAdapter.System$Windows$Markup$IPropertyAdapter$SetValue(element, this.propertyValueFactory.System$Windows$Markup$IElementFactory$CreateElement(context), context.ValueSource);
            }
        }
    });

    Bridge.define("System.Windows.Markup.ElementPropertyMemberInitializer.ElementPropertyMemberFactoryInitializer", {
        inherits: [System.Windows.Markup.IElementInitializer],
        fields: {
            propertyAdapter: null,
            propertyValueInitializer: null
        },
        alias: ["InitializeElement", "System$Windows$Markup$IElementInitializer$InitializeElement"],
        ctors: {
            ctor: function (propertyAdapter, propertyContentInitializer) {
                this.$initialize();
                this.propertyAdapter = propertyAdapter;
                this.propertyValueInitializer = propertyContentInitializer;
            }
        },
        methods: {
            InitializeElement: function (element, context) {
                var contentTarget = this.propertyAdapter.System$Windows$Markup$IPropertyAdapter$GetValue(element);

                if (contentTarget == null) {
                    contentTarget = Bridge.createInstance(this.propertyAdapter.System$Windows$Markup$IPropertyAdapter$PropertyType);
                    this.propertyAdapter.System$Windows$Markup$IPropertyAdapter$SetValue(element, contentTarget, context.ValueSource);
                }

                this.propertyValueInitializer.System$Windows$Markup$IElementInitializer$InitializeElement(contentTarget, context);
            }
        }
    });

    Bridge.define("System.Windows.Markup.EnumTypeConverter", {
        inherits: [System.Windows.Markup.ITypeConverter],
        fields: {
            type: null
        },
        alias: ["ConvertFrom", "System$Windows$Markup$ITypeConverter$ConvertFrom"],
        ctors: {
            ctor: function (type) {
                this.$initialize();
                this.type = type;
            }
        },
        methods: {
            ConvertFrom: function (namespaces, sourceUri, value) {
                return System.Enum.parse(this.type, value.toString().trim());
            }
        }
    });

    Bridge.define("System.Windows.Markup.EventPropertyAdapter", {
        inherits: [System.Windows.Markup.IEventAdapter],
        fields: {
            eventProperty: null
        },
        props: {
            HandlerType: {
                get: function () {
                    return this.eventProperty.rt;
                }
            }
        },
        alias: [
            "HandlerType", "System$Windows$Markup$IEventAdapter$HandlerType",
            "AddHandler", "System$Windows$Markup$IEventAdapter$AddHandler"
        ],
        ctors: {
            ctor: function (eventProperty) {
                this.$initialize();
                this.eventProperty = eventProperty;
            }
        },
        methods: {
            AddHandler: function (target, handler) {
                Bridge.Reflection.midel(this.eventProperty.s, Bridge.unbox(target)).apply(null, (System.Array.init(0, null, System.Object) || []).concat(handler));
            }
        }
    });

    Bridge.define("System.Windows.Markup.FrameworkElementFactoryInitializer", {
        inherits: [System.Windows.Markup.IElementInitializer],
        fields: {
            propertyAdapter: null,
            elementFactory: null
        },
        alias: ["InitializeElement", "System$Windows$Markup$IElementInitializer$InitializeElement"],
        ctors: {
            ctor: function (propertyAdapter, elementFactory) {
                this.$initialize();
                this.propertyAdapter = propertyAdapter;
                this.elementFactory = elementFactory;
            }
        },
        methods: {
            InitializeElement: function (element, context) {
                this.propertyAdapter.System$Windows$Markup$IPropertyAdapter$SetValue(element, new System.Windows.FrameworkElementFactory(this.elementFactory, context), context.ValueSource);
            }
        }
    });

    Bridge.define("System.Windows.Markup.Int32TypeConverter", {
        inherits: [System.Windows.Markup.ITypeConverter],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Markup.Int32TypeConverter();
                }
            }
        },
        alias: ["ConvertFrom", "System$Windows$Markup$ITypeConverter$ConvertFrom"],
        ctors: {
            ctor: function () {
                this.$initialize();
                //
            }
        },
        methods: {
            ConvertFrom: function (namespaces, sourceUri, value) {
                return Bridge.box(System.Int32.parse(value.toString()), System.Int32);
            }
        }
    });

    Bridge.define("System.Windows.Markup.MarkupExtensionElementFactory", {
        inherits: [System.Windows.Markup.IElementFactory],
        fields: {
            valueFactory: null
        },
        props: {
            ElementType: {
                get: function () {
                    return System.Object;
                }
            }
        },
        alias: [
            "ElementType", "System$Windows$Markup$IElementFactory$ElementType",
            "CreateElement", "System$Windows$Markup$IElementFactory$CreateElement"
        ],
        ctors: {
            ctor: function (valueFactory) {
                this.$initialize();
                this.valueFactory = valueFactory;
            }
        },
        methods: {
            CreateElement: function (context) {
                return Bridge.cast(this.valueFactory.System$Windows$Markup$IElementFactory$CreateElement(context), System.Windows.Markup.IMarkupExtension).System$Windows$Markup$IMarkupExtension$ProvideValue(context);
            }
        }
    });

    Bridge.define("System.Windows.Markup.MarkupExtensionParameterAttribute", {
        inherits: [System.Windows.Markup.PropertyAttribute],
        props: {
            Index: 0
        },
        ctors: {
            ctor: function (name, index) {
                if (index === void 0) { index = 0; }

                this.$initialize();
                System.Windows.Markup.PropertyAttribute.ctor.call(this, name);
                this.Index = index;
            }
        }
    });

    Bridge.define("System.Windows.Markup.ObjectTypeConverter", {
        inherits: [System.Windows.Markup.ITypeConverter],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Markup.ObjectTypeConverter();
                }
            }
        },
        alias: ["ConvertFrom", "System$Windows$Markup$ITypeConverter$ConvertFrom"],
        ctors: {
            ctor: function () {
                this.$initialize();
                //
            }
        },
        methods: {
            ConvertFrom: function (namespaces, sourceUri, value) {
                return value;
            }
        }
    });

    Bridge.define("System.Windows.Markup.RoutedEventAdapter", {
        inherits: [System.Windows.Markup.IEventAdapter],
        fields: {
            routedEvent: null
        },
        props: {
            HandlerType: {
                get: function () {
                    return this.routedEvent.HandlerType;
                }
            }
        },
        alias: [
            "HandlerType", "System$Windows$Markup$IEventAdapter$HandlerType",
            "AddHandler", "System$Windows$Markup$IEventAdapter$AddHandler"
        ],
        ctors: {
            ctor: function (routedEvent) {
                this.$initialize();
                this.routedEvent = routedEvent;
            }
        },
        methods: {
            AddHandler: function (target, handler) {
                Bridge.cast(target, System.Windows.UIElement).AddHandler(this.routedEvent, handler);
            }
        }
    });

    Bridge.define("System.Windows.Markup.RuntimeNamePropertyAttribute", {
        inherits: [System.Windows.Markup.PropertyAttribute],
        statics: {
            fields: {
                propertyNameCache: null
            },
            ctors: {
                init: function () {
                    this.propertyNameCache = Granular.Collections.CacheDictionary$2(Function,System.String).CreateUsingStringKeys($asm.$.System.Windows.Markup.RuntimeNamePropertyAttribute.f1, $asm.$.System.Windows.Markup.RuntimeNamePropertyAttribute.f2);
                }
            },
            methods: {
                GetPropertyName: function (type) {
                    return System.Windows.Markup.RuntimeNamePropertyAttribute.propertyNameCache.GetValue(type);
                }
            }
        },
        ctors: {
            ctor: function (name) {
                this.$initialize();
                System.Windows.Markup.PropertyAttribute.ctor.call(this, name);
                //
            }
        }
    });

    Bridge.ns("System.Windows.Markup.RuntimeNamePropertyAttribute", $asm.$);

    Bridge.apply($asm.$.System.Windows.Markup.RuntimeNamePropertyAttribute, {
        f1: function (type) {
            return System.Windows.Markup.PropertyAttribute.ResolvePropertyName(System.Windows.Markup.RuntimeNamePropertyAttribute, type);
        },
        f2: function (type) {
            return Bridge.Reflection.getTypeFullName(type);
        }
    });

    Bridge.define("System.Windows.Markup.StringTypeConverter", {
        inherits: [System.Windows.Markup.ITypeConverter],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Markup.StringTypeConverter();
                }
            }
        },
        alias: ["ConvertFrom", "System$Windows$Markup$ITypeConverter$ConvertFrom"],
        ctors: {
            ctor: function () {
                this.$initialize();
                //
            }
        },
        methods: {
            ConvertFrom: function (namespaces, sourceUri, value) {
                return value.toString();
            }
        }
    });

    Bridge.define("System.Windows.Markup.TimeSpanTypeConverter", {
        inherits: [System.Windows.Markup.ITypeConverter],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Markup.TimeSpanTypeConverter();
                }
            }
        },
        alias: ["ConvertFrom", "System$Windows$Markup$ITypeConverter$ConvertFrom"],
        ctors: {
            ctor: function () {
                this.$initialize();
                //
            }
        },
        methods: {
            ConvertFrom: function (namespaces, sourceUri, value) {
                var timeSpan = { };
                if (Granular.Compatibility.TimeSpan.TryParse(value.toString(), timeSpan)) {
                    return timeSpan.v;
                }

                throw new Granular.Exception("Can't parse TimeSpan value \"{0}\"", [value]);
            }
        }
    });

    Bridge.define("System.Windows.Markup.TypeConverter.EmptyTypeConverter", {
        inherits: [System.Windows.Markup.ITypeConverter],
        alias: ["ConvertFrom", "System$Windows$Markup$ITypeConverter$ConvertFrom"],
        methods: {
            ConvertFrom: function (namespaces, sourceUri, value) {
                return value;
            }
        }
    });

    Bridge.define("System.Windows.Markup.TypeTypeConverter", {
        inherits: [System.Windows.Markup.ITypeConverter],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Markup.TypeTypeConverter();
                }
            }
        },
        alias: ["ConvertFrom", "System$Windows$Markup$ITypeConverter$ConvertFrom"],
        ctors: {
            ctor: function () {
                this.$initialize();
                //
            }
        },
        methods: {
            ConvertFrom: function (namespaces, sourceUri, value) {
                return System.Windows.Markup.TypeParser.ParseType(value.toString().trim(), namespaces);
            }
        }
    });

    Bridge.define("System.Windows.Markup.UriTypeConverter", {
        inherits: [System.Windows.Markup.ITypeConverter],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Markup.UriTypeConverter();
                }
            }
        },
        alias: ["ConvertFrom", "System$Windows$Markup$ITypeConverter$ConvertFrom"],
        ctors: {
            ctor: function () {
                this.$initialize();
                //
            }
        },
        methods: {
            ConvertFrom: function (namespaces, sourceUri, value) {
                return Granular.Compatibility.Uri.CreateRelativeOrAbsoluteUri(value.toString().trim());
            }
        }
    });

    Bridge.define("System.Windows.Markup.ValueProvider", {
        inherits: [System.Windows.Markup.IValueProvider],
        fields: {
            provideValue: null
        },
        alias: ["ProvideValue", "System$Windows$Markup$IValueProvider$ProvideValue"],
        ctors: {
            ctor: function (provideValue) {
                this.$initialize();
                this.provideValue = provideValue;
            }
        },
        methods: {
            ProvideValue: function () {
                return this.provideValue();
            }
        }
    });

    Bridge.define("System.Windows.Markup.XamlTypes.NullProvider", {
        inherits: [System.Windows.Markup.IMarkupExtension],
        alias: ["ProvideValue", "System$Windows$Markup$IMarkupExtension$ProvideValue"],
        methods: {
            ProvideValue: function (context) {
                return null;
            }
        }
    });

    Bridge.define("System.Windows.Markup.XamlTypes.TypeProvider", {
        inherits: [System.Windows.Markup.IMarkupExtension],
        props: {
            Type: null
        },
        alias: ["ProvideValue", "System$Windows$Markup$IMarkupExtension$ProvideValue"],
        methods: {
            ProvideValue: function (context) {
                return this.Type;
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.AnimatableRootClock", {
        inherits: [System.Windows.Media.Animation.IRootClock],
        fields: {
            rootClock: null,
            clocks: null,
            isConnected: false
        },
        props: {
            Time: {
                get: function () {
                    return this.rootClock.System$Windows$Media$Animation$IRootClock$Time;
                }
            },
            IsConnected: {
                get: function () {
                    return this.isConnected;
                },
                set: function (value) {
                    var $t, $t1;
                    if (this.isConnected === value) {
                        return;
                    }

                    this.isConnected = value;

                    if (this.isConnected) {
                        $t = Bridge.getEnumerator(this.clocks);
                        try {
                            while ($t.moveNext()) {
                                var clock = $t.Current;
                                this.rootClock.System$Windows$Media$Animation$IRootClock$AddClock(clock);
                            }
                        } finally {
                            if (Bridge.is($t, System.IDisposable)) {
                                $t.System$IDisposable$dispose();
                            }
                        }} else {
                        $t1 = Bridge.getEnumerator(this.clocks);
                        try {
                            while ($t1.moveNext()) {
                                var clock1 = $t1.Current;
                                this.rootClock.System$Windows$Media$Animation$IRootClock$RemoveClock(clock1);
                            }
                        } finally {
                            if (Bridge.is($t1, System.IDisposable)) {
                                $t1.System$IDisposable$dispose();
                            }
                        }
                        this.CleanClocks();
                    }
                }
            }
        },
        alias: [
            "Time", "System$Windows$Media$Animation$IRootClock$Time",
            "AddClock", "System$Windows$Media$Animation$IRootClock$AddClock",
            "RemoveClock", "System$Windows$Media$Animation$IRootClock$RemoveClock"
        ],
        ctors: {
            ctor: function (rootClock, isConnected) {
                this.$initialize();
                this.rootClock = rootClock;
                this.isConnected = isConnected;

                this.clocks = new (System.Collections.Generic.List$1(System.Windows.Media.Animation.IClock)).ctor();
            }
        },
        methods: {
            AddClock: function (clock) {
                if (this.clocks.contains(clock)) {
                    return;
                }

                this.clocks.add(clock);

                if (this.IsConnected) {
                    this.rootClock.System$Windows$Media$Animation$IRootClock$AddClock(clock);
                }
            },
            RemoveClock: function (clock) {
                this.clocks.remove(clock);

                if (this.IsConnected) {
                    this.rootClock.System$Windows$Media$Animation$IRootClock$RemoveClock(clock);
                }
            },
            CleanClocks: function () {
                var time = this.Time;

                var i = 0;
                while (i < this.clocks.Count) {
                    if (System.TimeSpan.lt(this.clocks.getItem(i).System$Windows$Media$Animation$IClock$LastTick, time)) {
                        this.clocks.removeAt(i);
                    } else {
                        i = (i + 1) | 0;
                    }
                }
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.AnimationClock", {
        inherits: [System.Windows.Media.Animation.IClock],
        props: {
            FirstTick: {
                get: function () {
                    return System.TimeSpan.zero;
                }
            },
            LastTick: {
                get: function () {
                    return this.Duration;
                }
            },
            Duration: null
        },
        alias: [
            "FirstTick", "System$Windows$Media$Animation$IClock$FirstTick",
            "LastTick", "System$Windows$Media$Animation$IClock$LastTick",
            "Duration", "System$Windows$Media$Animation$IClock$Duration",
            "Tick", "System$Windows$Media$Animation$IClock$Tick"
        ],
        ctors: {
            init: function () {
                this.Duration = new System.TimeSpan();
            },
            ctor: function (duration) {
                this.$initialize();
                this.Duration = duration;
            }
        },
        methods: {
            Tick: function (time) {
                var previousTick;
                var nextTick;
                var progressState = new System.Windows.Media.Animation.ClockProgressState();
                var progress;

                if (System.TimeSpan.lt(time, System.TimeSpan.zero)) {
                    previousTick = Granular.Compatibility.TimeSpan.MinValue;
                    nextTick = System.TimeSpan.zero;

                    progress = 0;
                    progressState = System.Windows.Media.Animation.ClockProgressState.BeforeStarted;
                } else if (System.TimeSpan.lt(time, this.Duration)) {
                    previousTick = time;
                    nextTick = time;

                    progress = Granular.Extensions.TimeSpanExtensions.Divide(time, this.Duration);
                    progressState = System.Windows.Media.Animation.ClockProgressState.Active;
                } else {
                    previousTick = this.Duration;
                    nextTick = Granular.Compatibility.TimeSpan.MaxValue;

                    progress = 1;
                    progressState = System.Windows.Media.Animation.ClockProgressState.AfterEnded;
                }

                return new System.Windows.Media.Animation.ClockState(progressState, progress, 0, previousTick, nextTick);
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.TimelineClock", {
        inherits: [System.Windows.Media.Animation.IClock],
        statics: {
            methods: {
                CreateClock: function (baseClock, timeline) {
                    if (timeline.Duration.HasTimeSpan) {
                        baseClock = new System.Windows.Media.Animation.DurationClock(baseClock, timeline.Duration.TimeSpan);
                    }

                    if (timeline.AutoReverse) {
                        baseClock = new System.Windows.Media.Animation.ReverseClock(baseClock);
                    }

                    if (!Bridge.referenceEquals(timeline.RepeatBehavior, System.Windows.Media.Animation.RepeatBehavior.OneTime)) {
                        var iterationsCount = Granular.Extensions.DoubleExtensions.DefaultIfNaN(timeline.RepeatBehavior.Count, timeline.RepeatBehavior.Duration.getTicks() / System.Int64.toNumber(baseClock.System$Windows$Media$Animation$IClock$Duration.getTicks()));
                        baseClock = new System.Windows.Media.Animation.RepeatClock(baseClock, iterationsCount);
                    }

                    if (System.TimeSpan.neq(timeline.BeginTime, System.TimeSpan.zero)) {
                        baseClock = new System.Windows.Media.Animation.OffsetClock(baseClock, timeline.BeginTime);
                    }

                    return baseClock;
                }
            }
        },
        fields: {
            clock: null,
            beginTime: null,
            pauseOffset: null,
            rootClock: null,
            currentFillBehavior: 0
        },
        events: {
            Invalidated: null
        },
        props: {
            Timeline: null,
            FirstTick: {
                get: function () {
                    return System.TimeSpan.add(this.beginTime, this.clock.System$Windows$Media$Animation$IClock$FirstTick);
                }
            },
            LastTick: {
                get: function () {
                    return System.TimeSpan.eq(this.clock.System$Windows$Media$Animation$IClock$LastTick, Granular.Compatibility.TimeSpan.MaxValue) ? Granular.Compatibility.TimeSpan.MaxValue : System.TimeSpan.add(this.beginTime, this.clock.System$Windows$Media$Animation$IClock$LastTick);
                }
            },
            Duration: {
                get: function () {
                    return this.clock.System$Windows$Media$Animation$IClock$Duration;
                }
            },
            CurrentState: null,
            IsFilling: {
                get: function () {
                    return this.CurrentState.ProgressState === System.Windows.Media.Animation.ClockProgressState.AfterEnded && this.currentFillBehavior === System.Windows.Media.Animation.FillBehavior.HoldEnd;
                }
            }
        },
        alias: [
            "FirstTick", "System$Windows$Media$Animation$IClock$FirstTick",
            "LastTick", "System$Windows$Media$Animation$IClock$LastTick",
            "Duration", "System$Windows$Media$Animation$IClock$Duration",
            "Tick", "System$Windows$Media$Animation$IClock$Tick"
        ],
        ctors: {
            init: function () {
                this.beginTime = new System.TimeSpan();
                this.pauseOffset = new System.TimeSpan();
            },
            ctor: function (baseClock, timeline) {
                this.$initialize();
                this.clock = System.Windows.Media.Animation.TimelineClock.CreateClock(baseClock, timeline);
                this.Timeline = timeline;
                this.CurrentState = System.Windows.Media.Animation.ClockState.Empty;
            }
        },
        methods: {
            Tick: function (time) {
                var state = this.clock.System$Windows$Media$Animation$IClock$Tick(System.TimeSpan.sub(time, this.beginTime));

                var previousTick = System.TimeSpan.eq(state.PreviousTick, Granular.Compatibility.TimeSpan.MinValue) ? Granular.Compatibility.TimeSpan.MinValue : System.TimeSpan.add(this.beginTime, state.PreviousTick);
                var nextTick = System.TimeSpan.eq(state.NextTick, Granular.Compatibility.TimeSpan.MaxValue) ? Granular.Compatibility.TimeSpan.MaxValue : System.TimeSpan.add(this.beginTime, state.NextTick);

                this.CurrentState = new System.Windows.Media.Animation.ClockState(state.ProgressState, state.Progress, state.Iteration, previousTick, nextTick);

                Granular.Extensions.EventHandlerExtensions.Raise$2(this.Invalidated, this);

                return this.CurrentState;
            },
            Begin: function (rootClock) {
                this.rootClock = rootClock;
                this.VerifyRootClock();
                this.beginTime = rootClock.System$Windows$Media$Animation$IRootClock$Time;
                this.currentFillBehavior = this.Timeline.FillBehavior;
                rootClock.System$Windows$Media$Animation$IRootClock$AddClock(this);
                this.Tick(rootClock.System$Windows$Media$Animation$IRootClock$Time);
            },
            Pause: function () {
                this.VerifyRootClock();
                this.pauseOffset = System.TimeSpan.sub(this.rootClock.System$Windows$Media$Animation$IRootClock$Time, this.beginTime);
                this.rootClock.System$Windows$Media$Animation$IRootClock$RemoveClock(this);
                this.Tick(this.rootClock.System$Windows$Media$Animation$IRootClock$Time);
            },
            Remove: function () {
                this.VerifyRootClock();
                this.rootClock.System$Windows$Media$Animation$IRootClock$RemoveClock(this);
            },
            Resume: function () {
                this.VerifyRootClock();
                this.beginTime = System.TimeSpan.sub(this.rootClock.System$Windows$Media$Animation$IRootClock$Time, this.pauseOffset);
                this.rootClock.System$Windows$Media$Animation$IRootClock$AddClock(this);
                this.Tick(this.rootClock.System$Windows$Media$Animation$IRootClock$Time);
            },
            Seek: function (time) {
                this.VerifyRootClock();
                this.beginTime = System.TimeSpan.sub(this.rootClock.System$Windows$Media$Animation$IRootClock$Time, time);
                this.Tick(this.rootClock.System$Windows$Media$Animation$IRootClock$Time);
            },
            SeekOffset: function (offset) {
                this.VerifyRootClock();
                this.beginTime = System.TimeSpan.add(this.beginTime, offset);
                this.Tick(this.rootClock.System$Windows$Media$Animation$IRootClock$Time);
            },
            SkipToFill: function () {
                this.VerifyRootClock();
                this.beginTime = System.TimeSpan.sub(this.rootClock.System$Windows$Media$Animation$IRootClock$Time, this.clock.System$Windows$Media$Animation$IClock$Duration);
                this.currentFillBehavior = System.Windows.Media.Animation.FillBehavior.HoldEnd;
                this.Tick(this.rootClock.System$Windows$Media$Animation$IRootClock$Time);
            },
            Stop: function () {
                this.VerifyRootClock();
                this.beginTime = System.TimeSpan.eq(this.clock.System$Windows$Media$Animation$IClock$Duration, Granular.Compatibility.TimeSpan.MaxValue) ? System.TimeSpan.zero : System.TimeSpan.sub(this.rootClock.System$Windows$Media$Animation$IRootClock$Time, this.clock.System$Windows$Media$Animation$IClock$Duration);
                this.currentFillBehavior = System.Windows.Media.Animation.FillBehavior.Stop;
                this.rootClock.System$Windows$Media$Animation$IRootClock$RemoveClock(this);
                this.Tick(this.rootClock.System$Windows$Media$Animation$IRootClock$Time);
            },
            VerifyRootClock: function () {
                if (this.rootClock == null) {
                    throw new Granular.Exception("RootClock was not provided");
                }
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.DurationClock", {
        inherits: [System.Windows.Media.Animation.IClock],
        fields: {
            clock: null
        },
        props: {
            FirstTick: null,
            LastTick: null,
            Duration: null
        },
        alias: [
            "FirstTick", "System$Windows$Media$Animation$IClock$FirstTick",
            "LastTick", "System$Windows$Media$Animation$IClock$LastTick",
            "Duration", "System$Windows$Media$Animation$IClock$Duration",
            "Tick", "System$Windows$Media$Animation$IClock$Tick"
        ],
        ctors: {
            init: function () {
                this.FirstTick = new System.TimeSpan();
                this.LastTick = new System.TimeSpan();
                this.Duration = new System.TimeSpan();
            },
            ctor: function (clock, duration) {
                this.$initialize();
                this.clock = clock;
                this.Duration = duration;

                this.SetTickBounds();
            }
        },
        methods: {
            SetTickBounds: function () {
                if (System.TimeSpan.lt(this.Duration, this.clock.System$Windows$Media$Animation$IClock$FirstTick)) {
                    this.FirstTick = System.TimeSpan.zero;
                    this.LastTick = this.Duration;
                } else {
                    this.FirstTick = this.clock.System$Windows$Media$Animation$IClock$FirstTick;
                    this.LastTick = Granular.Extensions.TimeSpanExtensions.Min(this.Duration, this.clock.System$Windows$Media$Animation$IClock$LastTick);
                }
            },
            Tick: function (time) {
                if (System.TimeSpan.lt(time, System.TimeSpan.zero)) {
                    var state = this.clock.System$Windows$Media$Animation$IClock$Tick(System.TimeSpan.zero);

                    var previousTick = Granular.Compatibility.TimeSpan.MinValue;
                    var nextTick = System.TimeSpan.zero;

                    return new System.Windows.Media.Animation.ClockState(System.Windows.Media.Animation.ClockProgressState.BeforeStarted, state.Progress, state.Iteration, previousTick, nextTick);
                }

                if (System.TimeSpan.gte(time, this.Duration)) {
                    var state1 = this.clock.System$Windows$Media$Animation$IClock$Tick(this.Duration);

                    var previousTick1 = this.Duration;
                    var nextTick1 = Granular.Compatibility.TimeSpan.MaxValue;

                    return new System.Windows.Media.Animation.ClockState(System.Windows.Media.Animation.ClockProgressState.AfterEnded, state1.Progress, state1.Iteration, previousTick1, nextTick1);
                }

                return this.clock.System$Windows$Media$Animation$IClock$Tick(time);
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.KeyTimeTypeConverter", {
        inherits: [System.Windows.Markup.ITypeConverter],
        alias: ["ConvertFrom", "System$Windows$Markup$ITypeConverter$ConvertFrom"],
        methods: {
            ConvertFrom: function (namespaces, sourceUri, value) {
                return System.Windows.Media.Animation.KeyTime.Parse(value.toString().trim());
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.OffsetClock", {
        inherits: [System.Windows.Media.Animation.IClock],
        fields: {
            clock: null,
            offset: null
        },
        props: {
            FirstTick: {
                get: function () {
                    return System.TimeSpan.add(this.offset, this.clock.System$Windows$Media$Animation$IClock$FirstTick);
                }
            },
            LastTick: {
                get: function () {
                    return System.TimeSpan.eq(this.clock.System$Windows$Media$Animation$IClock$LastTick, Granular.Compatibility.TimeSpan.MaxValue) ? Granular.Compatibility.TimeSpan.MaxValue : System.TimeSpan.add(this.offset, this.clock.System$Windows$Media$Animation$IClock$LastTick);
                }
            },
            Duration: {
                get: function () {
                    return System.TimeSpan.eq(this.clock.System$Windows$Media$Animation$IClock$Duration, Granular.Compatibility.TimeSpan.MaxValue) ? Granular.Compatibility.TimeSpan.MaxValue : System.TimeSpan.add(this.offset, this.clock.System$Windows$Media$Animation$IClock$Duration);
                }
            }
        },
        alias: [
            "FirstTick", "System$Windows$Media$Animation$IClock$FirstTick",
            "LastTick", "System$Windows$Media$Animation$IClock$LastTick",
            "Duration", "System$Windows$Media$Animation$IClock$Duration",
            "Tick", "System$Windows$Media$Animation$IClock$Tick"
        ],
        ctors: {
            init: function () {
                this.offset = new System.TimeSpan();
            },
            ctor: function (clock, offset) {
                this.$initialize();
                this.clock = clock;
                this.offset = offset;
            }
        },
        methods: {
            Tick: function (time) {
                var state = this.clock.System$Windows$Media$Animation$IClock$Tick(System.TimeSpan.sub(time, this.offset));

                var previousTick = System.TimeSpan.eq(state.PreviousTick, Granular.Compatibility.TimeSpan.MinValue) ? Granular.Compatibility.TimeSpan.MinValue : System.TimeSpan.add(this.offset, state.PreviousTick);
                var nextTick = System.TimeSpan.eq(state.NextTick, Granular.Compatibility.TimeSpan.MaxValue) ? Granular.Compatibility.TimeSpan.MaxValue : System.TimeSpan.add(this.offset, state.NextTick);

                return new System.Windows.Media.Animation.ClockState(state.ProgressState, state.Progress, state.Iteration, previousTick, nextTick);
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.ParallelClock", {
        inherits: [System.Windows.Media.Animation.IClock],
        fields: {
            clocks: null
        },
        props: {
            FirstTick: null,
            LastTick: null,
            Duration: null
        },
        alias: [
            "FirstTick", "System$Windows$Media$Animation$IClock$FirstTick",
            "LastTick", "System$Windows$Media$Animation$IClock$LastTick",
            "Duration", "System$Windows$Media$Animation$IClock$Duration",
            "Tick", "System$Windows$Media$Animation$IClock$Tick"
        ],
        ctors: {
            init: function () {
                this.FirstTick = new System.TimeSpan();
                this.LastTick = new System.TimeSpan();
                this.Duration = new System.TimeSpan();
            },
            ctor: function (clocks) {
                this.$initialize();
                this.clocks = clocks;

                this.FirstTick = System.Linq.Enumerable.from(System.Linq.Enumerable.from(clocks).select($asm.$.System.Windows.Media.Animation.ParallelClock.f1).defaultIfEmpty(System.TimeSpan.zero)).min();
                this.LastTick = System.Linq.Enumerable.from(System.Linq.Enumerable.from(clocks).select($asm.$.System.Windows.Media.Animation.ParallelClock.f2).defaultIfEmpty(System.TimeSpan.zero)).max();
                this.Duration = System.Linq.Enumerable.from(System.Linq.Enumerable.from(clocks).select($asm.$.System.Windows.Media.Animation.ParallelClock.f3).defaultIfEmpty(System.TimeSpan.zero)).max();
            }
        },
        methods: {
            Tick: function (time) {
                var states = System.Linq.Enumerable.from(this.clocks).select(function (clock) {
                        return clock.System$Windows$Media$Animation$IClock$Tick(time);
                    }).toArray(System.Windows.Media.Animation.ClockState);

                var nextTick;
                var previousTick;
                var progressState = new System.Windows.Media.Animation.ClockProgressState();

                nextTick = System.Linq.Enumerable.from(System.Linq.Enumerable.from(states).select($asm.$.System.Windows.Media.Animation.ParallelClock.f4).defaultIfEmpty(System.TimeSpan.zero)).min();
                previousTick = System.Linq.Enumerable.from(System.Linq.Enumerable.from(states).select($asm.$.System.Windows.Media.Animation.ParallelClock.f5).defaultIfEmpty(System.TimeSpan.zero)).max();

                if (System.Linq.Enumerable.from(states).all($asm.$.System.Windows.Media.Animation.ParallelClock.f6)) {
                    progressState = System.Windows.Media.Animation.ClockProgressState.BeforeStarted;
                } else if (System.Linq.Enumerable.from(states).all($asm.$.System.Windows.Media.Animation.ParallelClock.f7)) {
                    progressState = System.Windows.Media.Animation.ClockProgressState.AfterEnded;
                } else {
                    progressState = System.Windows.Media.Animation.ClockProgressState.Active;
                }

                return new System.Windows.Media.Animation.ClockState(progressState, 0, 0, previousTick, nextTick);
            }
        }
    });

    Bridge.ns("System.Windows.Media.Animation.ParallelClock", $asm.$);

    Bridge.apply($asm.$.System.Windows.Media.Animation.ParallelClock, {
        f1: function (clock) {
            return clock.System$Windows$Media$Animation$IClock$FirstTick;
        },
        f2: function (clock) {
            return clock.System$Windows$Media$Animation$IClock$LastTick;
        },
        f3: function (clock) {
            return clock.System$Windows$Media$Animation$IClock$Duration;
        },
        f4: function (state) {
            return state.NextTick;
        },
        f5: function (state) {
            return state.PreviousTick;
        },
        f6: function (state) {
            return state.ProgressState === System.Windows.Media.Animation.ClockProgressState.BeforeStarted;
        },
        f7: function (state) {
            return state.ProgressState === System.Windows.Media.Animation.ClockProgressState.AfterEnded;
        }
    });

    Bridge.define("System.Windows.Media.Animation.RepeatBehaviorTypeConverter", {
        inherits: [System.Windows.Markup.ITypeConverter],
        alias: ["ConvertFrom", "System$Windows$Markup$ITypeConverter$ConvertFrom"],
        methods: {
            ConvertFrom: function (namespaces, sourceUri, value) {
                return System.Windows.Media.Animation.RepeatBehavior.Parse(value.toString().trim());
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.RepeatClock", {
        inherits: [System.Windows.Media.Animation.IClock],
        fields: {
            clock: null,
            iterationDuration: null,
            iterationsCount: 0
        },
        props: {
            FirstTick: null,
            LastTick: null,
            Duration: null
        },
        alias: [
            "FirstTick", "System$Windows$Media$Animation$IClock$FirstTick",
            "LastTick", "System$Windows$Media$Animation$IClock$LastTick",
            "Duration", "System$Windows$Media$Animation$IClock$Duration",
            "Tick", "System$Windows$Media$Animation$IClock$Tick"
        ],
        ctors: {
            init: function () {
                this.iterationDuration = new System.TimeSpan();
                this.FirstTick = new System.TimeSpan();
                this.LastTick = new System.TimeSpan();
                this.Duration = new System.TimeSpan();
            },
            ctor: function (clock, iterationsCount) {
                this.$initialize();
                this.clock = clock;
                this.iterationDuration = clock.System$Windows$Media$Animation$IClock$Duration;
                this.iterationsCount = iterationsCount;
                this.Duration = (Math.abs(iterationsCount) === Number.POSITIVE_INFINITY) ? Granular.Compatibility.TimeSpan.MaxValue : Granular.Extensions.TimeSpanExtensions.Scale(this.iterationDuration, iterationsCount);

                if (iterationsCount <= 0) {
                    throw new Granular.Exception("Invalid iterations count \"{0}\"", [Bridge.box(iterationsCount, System.Double, System.Double.format, System.Double.getHashCode)]);
                }

                if (System.TimeSpan.lte(this.iterationDuration, System.TimeSpan.zero)) {
                    throw new Granular.Exception("Invalid iteration duration \"{0}\"", [this.iterationDuration]);
                }

                this.SetTickBounds();
            }
        },
        methods: {
            SetTickBounds: function () {
                if ((Math.abs(this.iterationsCount) === Number.POSITIVE_INFINITY)) {
                    this.FirstTick = System.TimeSpan.zero;
                    this.LastTick = Granular.Compatibility.TimeSpan.MaxValue;
                    return;
                }

                var totalIterationsTime = Granular.Extensions.TimeSpanExtensions.Scale(this.iterationDuration, this.iterationsCount);

                if (System.TimeSpan.lt(totalIterationsTime, this.clock.System$Windows$Media$Animation$IClock$FirstTick)) {
                    this.FirstTick = System.TimeSpan.zero;
                    this.LastTick = totalIterationsTime;
                } else {
                    this.FirstTick = this.clock.System$Windows$Media$Animation$IClock$FirstTick;

                    if (System.TimeSpan.lt(totalIterationsTime, this.clock.System$Windows$Media$Animation$IClock$LastTick)) {
                        this.LastTick = totalIterationsTime;
                    } else if (System.TimeSpan.lt(totalIterationsTime, this.iterationDuration)) {
                        this.LastTick = this.clock.System$Windows$Media$Animation$IClock$LastTick;
                    } else {
                        var lastIterationRemainder = this.iterationsCount - Math.floor(this.iterationsCount);
                        var lastIterationDuration = Granular.Extensions.TimeSpanExtensions.Scale(this.iterationDuration, lastIterationRemainder);

                        if (System.TimeSpan.lt(lastIterationDuration, this.clock.System$Windows$Media$Animation$IClock$FirstTick)) {
                            this.LastTick = System.TimeSpan.add(this.clock.System$Windows$Media$Animation$IClock$LastTick, Granular.Extensions.TimeSpanExtensions.Scale(this.iterationDuration, Math.floor(this.iterationsCount - 1)));
                        } else if (System.TimeSpan.lt(lastIterationDuration, this.clock.System$Windows$Media$Animation$IClock$LastTick)) {
                            this.LastTick = totalIterationsTime;
                        } else {
                            this.LastTick = System.TimeSpan.add(this.clock.System$Windows$Media$Animation$IClock$LastTick, Granular.Extensions.TimeSpanExtensions.Scale(this.iterationDuration, Math.floor(this.iterationsCount)));
                        }
                    }
                }
            },
            Tick: function (time) {
                var iteration = Granular.Extensions.TimeSpanExtensions.Divide(time, this.iterationDuration);

                var progressState = System.TimeSpan.lt(time, this.FirstTick) ? System.Windows.Media.Animation.ClockProgressState.BeforeStarted : (System.TimeSpan.gte(time, this.LastTick) ? System.Windows.Media.Animation.ClockProgressState.AfterEnded : System.Windows.Media.Animation.ClockProgressState.Active);

                iteration = Math.min(Math.max(iteration, 0), this.iterationsCount);

                var iterationRemainder = iteration - Math.floor(iteration);

                var currentIterationStart;
                var currentIterationTime;

                if (progressState === System.Windows.Media.Animation.ClockProgressState.AfterEnded && iterationRemainder === 0) {
                    currentIterationStart = Granular.Extensions.TimeSpanExtensions.Scale(this.iterationDuration, iteration - 1);
                    currentIterationTime = this.iterationDuration;
                } else {
                    currentIterationStart = Granular.Extensions.TimeSpanExtensions.Scale(this.iterationDuration, iteration - iterationRemainder);
                    currentIterationTime = Granular.Extensions.TimeSpanExtensions.Scale(this.iterationDuration, iterationRemainder);
                }

                var state = this.clock.System$Windows$Media$Animation$IClock$Tick(currentIterationTime);

                var previousTick;
                var nextTick;

                if (System.TimeSpan.lt(time, this.FirstTick)) {
                    previousTick = Granular.Compatibility.TimeSpan.MinValue;
                    nextTick = this.FirstTick;
                } else if (System.TimeSpan.gte(time, this.LastTick)) {
                    previousTick = this.LastTick;
                    nextTick = Granular.Compatibility.TimeSpan.MaxValue;
                } else {
                    if (System.TimeSpan.gt(currentIterationTime, this.clock.System$Windows$Media$Animation$IClock$FirstTick) || Math.floor(iteration) === 0) {
                        previousTick = Granular.Extensions.TimeSpanExtensions.Max((System.TimeSpan.add(currentIterationStart, state.PreviousTick)), this.FirstTick);
                    } else {
                        previousTick = Granular.Extensions.TimeSpanExtensions.Max((System.TimeSpan.add(System.TimeSpan.sub(currentIterationStart, this.iterationDuration), this.clock.System$Windows$Media$Animation$IClock$LastTick)), this.FirstTick);
                    }

                    if (System.TimeSpan.lt(currentIterationTime, this.clock.System$Windows$Media$Animation$IClock$LastTick) || Math.floor(iteration) === Math.floor(this.iterationsCount)) {
                        nextTick = Granular.Extensions.TimeSpanExtensions.Min((System.TimeSpan.add(currentIterationStart, state.NextTick)), this.LastTick);
                    } else {
                        nextTick = Granular.Extensions.TimeSpanExtensions.Min((System.TimeSpan.add(System.TimeSpan.add(currentIterationStart, this.iterationDuration), this.clock.System$Windows$Media$Animation$IClock$FirstTick)), this.LastTick);
                    }
                }

                if (progressState === System.Windows.Media.Animation.ClockProgressState.Active) {
                    progressState = state.ProgressState;
                }

                return new System.Windows.Media.Animation.ClockState(progressState, state.Progress, iteration, previousTick, nextTick);
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.ReverseClock", {
        inherits: [System.Windows.Media.Animation.IClock],
        fields: {
            clock: null
        },
        props: {
            FirstTick: {
                get: function () {
                    return this.clock.System$Windows$Media$Animation$IClock$FirstTick;
                }
            },
            LastTick: null,
            Duration: null
        },
        alias: [
            "FirstTick", "System$Windows$Media$Animation$IClock$FirstTick",
            "LastTick", "System$Windows$Media$Animation$IClock$LastTick",
            "Duration", "System$Windows$Media$Animation$IClock$Duration",
            "Tick", "System$Windows$Media$Animation$IClock$Tick"
        ],
        ctors: {
            init: function () {
                this.LastTick = new System.TimeSpan();
                this.Duration = new System.TimeSpan();
            },
            ctor: function (clock) {
                this.$initialize();
                this.clock = clock;

                this.Duration = Granular.Extensions.TimeSpanExtensions.Scale(clock.System$Windows$Media$Animation$IClock$Duration, 2);
                this.LastTick = System.TimeSpan.sub(this.Duration, clock.System$Windows$Media$Animation$IClock$FirstTick);
            }
        },
        methods: {
            Tick: function (time) {
                var isReversed = System.TimeSpan.gt(time, this.clock.System$Windows$Media$Animation$IClock$Duration);

                var reversedTime = System.TimeSpan.sub(this.Duration, time);

                var previousTick;
                var nextTick;

                var state;

                if (!isReversed) {
                    state = this.clock.System$Windows$Media$Animation$IClock$Tick(time);

                    previousTick = state.PreviousTick;
                    nextTick = System.TimeSpan.gte(time, this.clock.System$Windows$Media$Animation$IClock$LastTick) ? System.TimeSpan.sub(this.Duration, this.clock.System$Windows$Media$Animation$IClock$LastTick) : state.NextTick;
                } else {
                    state = this.clock.System$Windows$Media$Animation$IClock$Tick(reversedTime);

                    previousTick = System.TimeSpan.gte(reversedTime, this.clock.System$Windows$Media$Animation$IClock$LastTick) ? this.clock.System$Windows$Media$Animation$IClock$LastTick : System.TimeSpan.sub(this.Duration, state.NextTick);
                    nextTick = System.TimeSpan.eq(state.PreviousTick, Granular.Compatibility.TimeSpan.MinValue) ? Granular.Compatibility.TimeSpan.MaxValue : System.TimeSpan.sub(this.Duration, state.PreviousTick);
                }

                return new System.Windows.Media.Animation.ClockState(state.ProgressState, state.Progress, state.Iteration, previousTick, nextTick);
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.RootClock", {
        inherits: [System.Windows.Media.Animation.IRootClock],
        statics: {
            fields: {
                TickFrequency: null,
                Default: null
            },
            ctors: {
                init: function () {
                    this.TickFrequency = new System.TimeSpan();
                    this.TickFrequency = System.TimeSpan.fromMilliseconds(20);
                    this.Default = new System.Windows.Media.Animation.RootClock();
                }
            }
        },
        fields: {
            startTime: null,
            scheduledTick: null,
            scheduledTickTime: null,
            lastTickTime: null,
            clocksSchedule: null
        },
        props: {
            Time: {
                get: function () {
                    return Granular.Compatibility.TimeSpan.Subtract(System.DateTime.getNow(), this.startTime);
                }
            }
        },
        alias: [
            "Time", "System$Windows$Media$Animation$IRootClock$Time",
            "AddClock", "System$Windows$Media$Animation$IRootClock$AddClock",
            "RemoveClock", "System$Windows$Media$Animation$IRootClock$RemoveClock"
        ],
        ctors: {
            init: function () {
                this.startTime = System.DateTime.getDefaultValue();
                this.scheduledTickTime = new System.TimeSpan();
                this.lastTickTime = new System.TimeSpan();
            },
            ctor: function () {
                this.$initialize();
                this.clocksSchedule = new (System.Collections.Generic.List$1(System.Windows.Media.Animation.RootClock.ClockSchedule)).ctor();

                this.startTime = System.DateTime.getNow();
                this.lastTickTime = Granular.Compatibility.TimeSpan.MinValue;
            }
        },
        methods: {
            AddClock: function (clock) {
                if (System.Linq.Enumerable.from(this.clocksSchedule).any(function (clockSchedule) {
                        return Bridge.referenceEquals(clockSchedule.Clock, clock);
                    }) || System.TimeSpan.eq(clock.System$Windows$Media$Animation$IClock$FirstTick, Granular.Compatibility.TimeSpan.MaxValue)) {
                    return;
                }

                this.clocksSchedule.add(new System.Windows.Media.Animation.RootClock.ClockSchedule(clock));

                this.ScheduleTick(clock.System$Windows$Media$Animation$IClock$FirstTick);
            },
            ScheduleTick: function (tickTime) {
                // keep TickFrequency interval between ticks
                tickTime = Granular.Extensions.TimeSpanExtensions.Max(tickTime, System.TimeSpan.add(this.lastTickTime, System.Windows.Media.Animation.RootClock.TickFrequency));

                if (this.scheduledTick != null) {
                    if (System.TimeSpan.lte(this.scheduledTickTime, tickTime)) {
                        // earlier tick is already scheduled
                        return;
                    }

                    this.scheduledTick.System$IDisposable$dispose();
                }

                this.scheduledTick = System.Windows.ApplicationHost.Current.System$Windows$IApplicationHost$TaskScheduler.System$Windows$Threading$ITaskScheduler$ScheduleTask(Granular.Extensions.TimeSpanExtensions.Max((System.TimeSpan.sub(tickTime, this.Time)), System.TimeSpan.zero), Bridge.fn.bind(this, $asm.$.System.Windows.Media.Animation.RootClock.f1));
                this.scheduledTickTime = tickTime;
            },
            RemoveClock: function (clock) {
                this.clocksSchedule.remove(System.Linq.Enumerable.from(this.clocksSchedule).firstOrDefault(function (clockSchedule) {
                        return Bridge.referenceEquals(clockSchedule.Clock, clock);
                    }, null));
            },
            Tick: function () {
                var $t;
                var tickTime = this.Time;

                this.lastTickTime = tickTime;
                this.scheduledTick = null;

                var nextTick = Granular.Compatibility.TimeSpan.MaxValue;

                $t = Bridge.getEnumerator(this.clocksSchedule);
                try {
                    while ($t.moveNext()) {
                        var clockSchedule = $t.Current;
                        if (System.TimeSpan.lte(clockSchedule.NextTick, tickTime)) {
                            clockSchedule.Tick(tickTime);
                            nextTick = Granular.Extensions.TimeSpanExtensions.Min(nextTick, clockSchedule.NextTick);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                this.CleanClocks();

                if (System.TimeSpan.lt(nextTick, Granular.Compatibility.TimeSpan.MaxValue)) {
                    this.ScheduleTick(nextTick);
                }
            },
            CleanClocks: function () {
                var i = 0;
                while (i < this.clocksSchedule.Count) {
                    if (System.TimeSpan.eq(this.clocksSchedule.getItem(i).NextTick, Granular.Compatibility.TimeSpan.MaxValue)) {
                        this.clocksSchedule.removeAt(i);
                    } else {
                        i = (i + 1) | 0;
                    }
                }
            }
        }
    });

    Bridge.ns("System.Windows.Media.Animation.RootClock", $asm.$);

    Bridge.apply($asm.$.System.Windows.Media.Animation.RootClock, {
        f1: function () {
            System.Windows.Threading.Dispatcher.CurrentDispatcher.InvokeAsync(Bridge.fn.cacheBind(this, this.Tick), System.Windows.Threading.DispatcherPriority.Background);
        }
    });

    Bridge.define("System.Windows.Media.Animation.SequentialClock", {
        inherits: [System.Windows.Media.Animation.IClock],
        fields: {
            clocks: null
        },
        props: {
            FirstTick: null,
            LastTick: null,
            Duration: null
        },
        alias: [
            "FirstTick", "System$Windows$Media$Animation$IClock$FirstTick",
            "LastTick", "System$Windows$Media$Animation$IClock$LastTick",
            "Duration", "System$Windows$Media$Animation$IClock$Duration",
            "Tick", "System$Windows$Media$Animation$IClock$Tick"
        ],
        ctors: {
            init: function () {
                this.FirstTick = new System.TimeSpan();
                this.LastTick = new System.TimeSpan();
                this.Duration = new System.TimeSpan();
            },
            ctor: function (clocks) {
                this.$initialize();
                this.clocks = clocks;

                if (!System.Linq.Enumerable.from(clocks).any()) {
                    this.FirstTick = System.TimeSpan.zero;
                    this.LastTick = System.TimeSpan.zero;
                    this.Duration = System.TimeSpan.zero;
                } else {
                    this.FirstTick = System.Linq.Enumerable.from(clocks).first().System$Windows$Media$Animation$IClock$FirstTick;
                    this.LastTick = System.TimeSpan.add(System.Linq.Enumerable.from(clocks).take(((System.Linq.Enumerable.from(clocks).count() - 1) | 0)).select($asm.$.System.Windows.Media.Animation.SequentialClock.f1).aggregate($asm.$.System.Windows.Media.Animation.SequentialClock.f2), System.Linq.Enumerable.from(clocks).last().System$Windows$Media$Animation$IClock$LastTick);
                    this.Duration = System.Linq.Enumerable.from(clocks).select($asm.$.System.Windows.Media.Animation.SequentialClock.f1).aggregate($asm.$.System.Windows.Media.Animation.SequentialClock.f2);
                }
            }
        },
        methods: {
            Tick: function (time) {
                var $t;
                var progressState = new System.Windows.Media.Animation.ClockProgressState();

                if (System.TimeSpan.lt(time, this.FirstTick)) {
                    progressState = System.Windows.Media.Animation.ClockProgressState.BeforeStarted;
                } else if (System.TimeSpan.lt(time, this.LastTick)) {
                    progressState = System.Windows.Media.Animation.ClockProgressState.Active;
                } else {
                    progressState = System.Windows.Media.Animation.ClockProgressState.AfterEnded;
                }

                var previousTick = Granular.Compatibility.TimeSpan.MinValue;
                var nextTick = Granular.Compatibility.TimeSpan.MaxValue;
                var totalDuration = System.TimeSpan.zero;

                $t = Bridge.getEnumerator(this.clocks, System.Windows.Media.Animation.IClock);
                try {
                    while ($t.moveNext()) {
                        var clock = $t.Current;
                        var state = clock.System$Windows$Media$Animation$IClock$Tick(System.TimeSpan.sub(time, totalDuration));

                        if (System.TimeSpan.neq(state.PreviousTick, Granular.Compatibility.TimeSpan.MinValue)) {
                            previousTick = Granular.Extensions.TimeSpanExtensions.Max(previousTick, System.TimeSpan.add(state.PreviousTick, totalDuration));
                        }

                        if (System.TimeSpan.neq(state.NextTick, Granular.Compatibility.TimeSpan.MaxValue)) {
                            nextTick = Granular.Extensions.TimeSpanExtensions.Min(nextTick, System.TimeSpan.add(state.NextTick, totalDuration));
                        }

                        totalDuration = System.TimeSpan.add(totalDuration, clock.System$Windows$Media$Animation$IClock$Duration);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                return new System.Windows.Media.Animation.ClockState(progressState, 0, 0, previousTick, nextTick);
            }
        }
    });

    Bridge.ns("System.Windows.Media.Animation.SequentialClock", $asm.$);

    Bridge.apply($asm.$.System.Windows.Media.Animation.SequentialClock, {
        f1: function (clock) {
            return clock.System$Windows$Media$Animation$IClock$Duration;
        },
        f2: function (t1, t2) {
            return System.TimeSpan.add(t1, t2);
        }
    });

    Bridge.define("System.Windows.Media.BrushTypeConverter", {
        inherits: [System.Windows.Markup.ITypeConverter],
        fields: {
            colorTypeConverter: null
        },
        alias: ["ConvertFrom", "System$Windows$Markup$ITypeConverter$ConvertFrom"],
        ctors: {
            ctor: function () {
                this.$initialize();
                this.colorTypeConverter = new System.Windows.Media.ColorTypeConverter();
            }
        },
        methods: {
            ConvertFrom: function (namespaces, sourceUri, value) {
                if (Bridge.is(value, System.String)) {
                    return new System.Windows.Media.SolidColorBrush.$ctor1(Bridge.cast(this.colorTypeConverter.ConvertFrom(namespaces, sourceUri, value), System.Windows.Media.Color));
                }

                throw new Granular.Exception("Can't convert \"{0}\" to Color", [value]);
            }
        }
    });

    Bridge.define("System.Windows.Media.ColorTypeConverter", {
        inherits: [System.Windows.Markup.ITypeConverter],
        alias: ["ConvertFrom", "System$Windows$Markup$ITypeConverter$ConvertFrom"],
        methods: {
            ConvertFrom: function (namespaces, sourceUri, value) {
                if (Bridge.is(value, System.String)) {
                    var stringValue = Bridge.cast(value, System.String).trim();

                    if (stringValue.length === 9 && stringValue.charCodeAt(0) === 35) {
                        return System.Windows.Media.Color.FromUInt32(System.Convert.toNumberInBase(stringValue.substr(1), 16, 10));
                    }

                    if (stringValue.length === 7 && stringValue.charCodeAt(0) === 35) {
                        return System.Windows.Media.Color.FromUInt32(((4278190080 | System.Convert.toNumberInBase(stringValue.substr(1), 16, 10)) >>> 0));
                    }

                    if (stringValue.length === 4 && stringValue.charCodeAt(0) === 35) {
                        return System.Windows.Media.Color.FromUInt32(((4278190080 | System.Convert.toNumberInBase(System.String.format("{0}{0}{1}{1}{2}{2}", String.fromCharCode(stringValue.charCodeAt(1)), String.fromCharCode(stringValue.charCodeAt(2)), String.fromCharCode(stringValue.charCodeAt(3))), 16, 10)) >>> 0));
                    }

                    var propertyInfo = Bridge.Reflection.getMembers(System.Windows.Media.Colors, 16, 24 | 256, stringValue);
                    if (propertyInfo != null) {
                        return Bridge.Reflection.midel(propertyInfo.g, null).apply(null, System.Array.init(0, null, System.Object));
                    }
                }

                throw new Granular.Exception("Can't convert \"{0}\" to Color", [value]);
            }
        }
    });

    Bridge.define("System.Windows.Media.FontFamilyTypeConverter", {
        inherits: [System.Windows.Markup.ITypeConverter],
        alias: ["ConvertFrom", "System$Windows$Markup$ITypeConverter$ConvertFrom"],
        methods: {
            ConvertFrom: function (namespaces, sourceUri, value) {
                return System.Windows.Media.FontFamily.Parse(value.toString().trim());
            }
        }
    });

    Bridge.define("System.Windows.Media.GeometryTypeConverter", {
        inherits: [System.Windows.Markup.ITypeConverter],
        fields: {
            colorTypeConverter: null
        },
        alias: ["ConvertFrom", "System$Windows$Markup$ITypeConverter$ConvertFrom"],
        ctors: {
            ctor: function () {
                this.$initialize();
                this.colorTypeConverter = new System.Windows.Media.ColorTypeConverter();
            }
        },
        methods: {
            ConvertFrom: function (namespaces, sourceUri, value) {
                if (Bridge.is(value, System.String)) {
                    return new System.Windows.Media.StreamGeometry(Bridge.cast(value, System.String));
                }

                throw new Granular.Exception("Can't convert \"{0}\" to Geometry", [value]);
            }
        }
    });

    Bridge.define("System.Windows.Media.IDrawingContainerRenderElement", {
        inherits: [System.Windows.Media.IContainerRenderElement],
        $kind: "interface"
    });

    Bridge.define("System.Windows.Media.IDrawingGeometryRenderElement", {
        inherits: [System.Windows.Media.IDrawingShapeRenderElement],
        $kind: "interface"
    });

    Bridge.define("System.Windows.Media.IGradientBrushRenderResource", {
        inherits: [System.Windows.Media.IBrushRenderResource],
        $kind: "interface"
    });

    Bridge.define("System.Windows.Media.ITileBrushRenderResource", {
        inherits: [System.Windows.Media.IBrushRenderResource],
        $kind: "interface"
    });

    Bridge.define("System.Windows.Media.ImageSourceTypeConverter", {
        inherits: [System.Windows.Markup.ITypeConverter],
        alias: ["ConvertFrom", "System$Windows$Markup$ITypeConverter$ConvertFrom"],
        methods: {
            ConvertFrom: function (namespaces, sourceUri, value) {
                var $t;
                return ($t = new System.Windows.Media.Imaging.BitmapImage(), $t.BaseUri = sourceUri, $t.UriSource = Granular.Compatibility.Uri.CreateRelativeOrAbsoluteUri(Bridge.cast(value, System.String)), $t);
            }
        }
    });

    Bridge.define("System.Windows.Media.ISolidColorBrushRenderResource", {
        inherits: [System.Windows.Media.IBrushRenderResource],
        $kind: "interface"
    });

    Bridge.define("System.Windows.Media.IVisualRenderElement", {
        inherits: [System.Windows.Media.IContainerRenderElement],
        $kind: "interface"
    });

    Bridge.define("System.Windows.Media.MatrixTypeConverter", {
        inherits: [System.Windows.Markup.ITypeConverter],
        alias: ["ConvertFrom", "System$Windows$Markup$ITypeConverter$ConvertFrom"],
        methods: {
            ConvertFrom: function (namespaces, sourceUri, value) {
                return System.Windows.Media.Matrix.Parse(value.toString().trim());
            }
        }
    });

    Bridge.define("System.Windows.Media.RenderElementDrawingContext", {
        inherits: [System.Windows.Media.DrawingContext],
        fields: {
            children: null,
            container: null,
            factory: null,
            availableChildren: null,
            innerContext: null,
            isClosed: false
        },
        events: {
            Closed: null
        },
        props: {
            Children: {
                get: function () {
                    return this.children;
                }
            },
            IsEmpty: {
                get: function () {
                    return this.children.Count === 0;
                }
            }
        },
        ctors: {
            ctor: function (container, factory) {
                var $t;
                this.$initialize();
                System.Windows.Media.DrawingContext.ctor.call(this);
                this.container = container;
                this.factory = factory;
                this.availableChildren = ($t = container.System$Windows$Media$IContainerRenderElement$Children) != null ? System.Linq.Enumerable.from($t).toList(System.Object) : null;
                this.children = new (System.Collections.Generic.List$1(System.Object)).ctor();
            }
        },
        methods: {
            SetInnerContext: function (innerContainer) {
                if (this.innerContext != null) {
                    throw new Granular.Exception("Inner context is already set");
                }

                this.innerContext = new System.Windows.Media.RenderElementDrawingContext(innerContainer, this.factory);
                this.innerContext.addClosed(Bridge.fn.bind(this, $asm.$.System.Windows.Media.RenderElementDrawingContext.f1));
            },
            Close: function () {
                var $t;
                this.VerifyNotClosed();

                if (this.innerContext != null) {
                    this.innerContext.Close();
                }

                System.Windows.Media.ContainerRenderElementExtensions.SetChildren(this.container, this.children);

                $t = Bridge.getEnumerator(System.Linq.Enumerable.from(this.availableChildren).ofType(System.IDisposable));
                try {
                    while ($t.moveNext()) {
                        var child = $t.Current;
                        child.System$IDisposable$dispose();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                this.isClosed = true;

                Granular.Extensions.EventHandlerExtensions.Raise$2(this.Closed, this);
            },
            DrawGeometry: function (brush, pen, geometry) {
                var $t;
                this.VerifyNotClosed();

                if (this.innerContext != null) {
                    this.innerContext.DrawGeometry(brush, pen, geometry);
                    return;
                }

                var child = this.GetChild(Bridge.global.System.Windows.Media.IDrawingGeometryRenderElement, Bridge.fn.cacheBind(this.factory, this.factory.System$Windows$Media$IRenderElementFactory$CreateDrawingGeometryRenderElement));

                child.System$Windows$Media$IDrawingShapeRenderElement$Fill = brush;
                child.System$Windows$Media$IDrawingShapeRenderElement$Stroke = pen != null ? pen.Brush : null;
                child.System$Windows$Media$IDrawingShapeRenderElement$StrokeThickness = ($t = (pen != null ? pen.Thickness : null), $t != null ? $t : 0);
                child.System$Windows$Media$IDrawingGeometryRenderElement$Geometry = geometry;
            },
            Pop: function () {
                this.VerifyNotClosed();

                if (this.innerContext != null) {
                    this.innerContext.Pop();
                    return;
                }

                this.Close();
            },
            DrawImage: function (imageSource, rectangle) {
                this.VerifyNotClosed();

                if (this.innerContext != null) {
                    this.innerContext.DrawImage(imageSource, rectangle);
                    return;
                }

                var child = this.GetChild(Bridge.global.System.Windows.Media.IDrawingImageRenderElement, Bridge.fn.cacheBind(this.factory, this.factory.System$Windows$Media$IRenderElementFactory$CreateDrawingImageRenderElement));

                child.System$Windows$Media$IDrawingImageRenderElement$ImageSource = imageSource;
                child.System$Windows$Media$IDrawingImageRenderElement$Rectangle = rectangle;
            },
            DrawEllipse: function (brush, pen, center, radiusX, radiusY) {
                var $t;
                this.VerifyNotClosed();

                if (this.innerContext != null) {
                    this.innerContext.DrawEllipse(brush, pen, center, radiusX, radiusY);
                    return;
                }

                var child = this.GetChild(Bridge.global.System.Windows.Media.IDrawingGeometryRenderElement, Bridge.fn.cacheBind(this.factory, this.factory.System$Windows$Media$IRenderElementFactory$CreateDrawingGeometryRenderElement));

                var geometry = Bridge.as(child.System$Windows$Media$IDrawingGeometryRenderElement$Geometry, System.Windows.Media.EllipseGeometry);
                if (geometry == null) {
                    geometry = new System.Windows.Media.EllipseGeometry.ctor();
                }

                geometry.Center = center;
                geometry.RadiusX = radiusX;
                geometry.RadiusY = radiusY;

                child.System$Windows$Media$IDrawingShapeRenderElement$Fill = brush;
                child.System$Windows$Media$IDrawingShapeRenderElement$Stroke = pen != null ? pen.Brush : null;
                child.System$Windows$Media$IDrawingShapeRenderElement$StrokeThickness = ($t = (pen != null ? pen.Thickness : null), $t != null ? $t : 0);
                child.System$Windows$Media$IDrawingGeometryRenderElement$Geometry = geometry;
            },
            DrawLine: function (pen, point0, point1) {
                var $t;
                this.VerifyNotClosed();

                if (this.innerContext != null) {
                    this.innerContext.DrawLine(pen, point0, point1);
                    return;
                }

                var child = this.GetChild(Bridge.global.System.Windows.Media.IDrawingGeometryRenderElement, Bridge.fn.cacheBind(this.factory, this.factory.System$Windows$Media$IRenderElementFactory$CreateDrawingGeometryRenderElement));

                var geometry = Bridge.as(child.System$Windows$Media$IDrawingGeometryRenderElement$Geometry, System.Windows.Media.LineGeometry);
                if (geometry == null) {
                    geometry = new System.Windows.Media.LineGeometry.ctor();
                }

                geometry.StartPoint = point0;
                geometry.EndPoint = point1;

                child.System$Windows$Media$IDrawingShapeRenderElement$Stroke = pen != null ? pen.Brush : null;
                child.System$Windows$Media$IDrawingShapeRenderElement$StrokeThickness = ($t = (pen != null ? pen.Thickness : null), $t != null ? $t : 0);
                child.System$Windows$Media$IDrawingGeometryRenderElement$Geometry = geometry;
            },
            DrawRectangle: function (brush, pen, rectangle) {
                this.DrawRoundedRectangle(brush, pen, rectangle, 0, 0);
            },
            DrawRoundedRectangle: function (brush, pen, rectangle, radiusX, radiusY) {
                var $t;
                this.VerifyNotClosed();

                if (this.innerContext != null) {
                    this.innerContext.DrawRoundedRectangle(brush, pen, rectangle, radiusX, radiusY);
                    return;
                }

                var child = this.GetChild(Bridge.global.System.Windows.Media.IDrawingGeometryRenderElement, Bridge.fn.cacheBind(this.factory, this.factory.System$Windows$Media$IRenderElementFactory$CreateDrawingGeometryRenderElement));

                var geometry = Bridge.as(child.System$Windows$Media$IDrawingGeometryRenderElement$Geometry, System.Windows.Media.RectangleGeometry);
                if (geometry == null) {
                    geometry = new System.Windows.Media.RectangleGeometry.ctor();
                }

                geometry.Rect = rectangle;
                geometry.RadiusX = radiusX;
                geometry.RadiusY = radiusY;

                child.System$Windows$Media$IDrawingShapeRenderElement$Fill = brush;
                child.System$Windows$Media$IDrawingShapeRenderElement$Stroke = pen != null ? pen.Brush : null;
                child.System$Windows$Media$IDrawingShapeRenderElement$StrokeThickness = ($t = (pen != null ? pen.Thickness : null), $t != null ? $t : 0);
                child.System$Windows$Media$IDrawingGeometryRenderElement$Geometry = geometry;
            },
            DrawText: function (formattedText, origin) {
                this.VerifyNotClosed();

                if (this.innerContext != null) {
                    this.innerContext.DrawText(formattedText, origin);
                    return;
                }

                var child = this.GetChild(Bridge.global.System.Windows.Media.IDrawingTextRenderElement, Bridge.fn.cacheBind(this.factory, this.factory.System$Windows$Media$IRenderElementFactory$CreateDrawingTextRenderElement));

                child.System$Windows$Media$IDrawingTextRenderElement$FormattedText = formattedText;
                child.System$Windows$Media$IDrawingTextRenderElement$Origin = origin;
            },
            PushClip: function (clipGeometry) {
                this.VerifyNotClosed();

                if (this.innerContext != null) {
                    this.innerContext.PushClip(clipGeometry);
                    return;
                }

                var child = this.GetChild(Bridge.global.System.Windows.Media.IDrawingContainerRenderElement, Bridge.fn.cacheBind(this.factory, this.factory.System$Windows$Media$IRenderElementFactory$CreateDrawingContainerRenderElement));

                this.SetInnerContext(child);

                child.System$Windows$Media$IDrawingContainerRenderElement$Clip = clipGeometry;
            },
            PushOpacity: function (opacity) {
                this.VerifyNotClosed();

                if (this.innerContext != null) {
                    this.innerContext.PushOpacity(opacity);
                    return;
                }

                var child = this.GetChild(Bridge.global.System.Windows.Media.IDrawingContainerRenderElement, Bridge.fn.cacheBind(this.factory, this.factory.System$Windows$Media$IRenderElementFactory$CreateDrawingContainerRenderElement));

                this.SetInnerContext(child);

                child.System$Windows$Media$IDrawingContainerRenderElement$Opacity = opacity;
            },
            PushTransform: function (transform) {
                this.VerifyNotClosed();

                if (this.innerContext != null) {
                    this.innerContext.PushTransform(transform);
                    return;
                }

                var child = this.GetChild(Bridge.global.System.Windows.Media.IDrawingContainerRenderElement, Bridge.fn.cacheBind(this.factory, this.factory.System$Windows$Media$IRenderElementFactory$CreateDrawingContainerRenderElement));

                this.SetInnerContext(child);

                child.System$Windows$Media$IDrawingContainerRenderElement$Transform = transform;
            },
            GetChild: function (T, factory) {
                var child = System.Linq.Enumerable.from(this.availableChildren).ofType(T).firstOrDefault(null, null);

                if (child != null) {
                    this.availableChildren.remove(child);
                } else {
                    child = factory();
                }

                this.children.add(child);

                return child;
            },
            VerifyNotClosed: function () {
                if (this.isClosed) {
                    throw new Granular.Exception("DrawingContext is closed");
                }
            }
        }
    });

    Bridge.ns("System.Windows.Media.RenderElementDrawingContext", $asm.$);

    Bridge.apply($asm.$.System.Windows.Media.RenderElementDrawingContext, {
        f1: function (sender, e) {
            this.innerContext = null;
        }
    });

    Bridge.define("System.Windows.Media.TransformTypeConverter", {
        inherits: [System.Windows.Markup.ITypeConverter],
        alias: ["ConvertFrom", "System$Windows$Markup$ITypeConverter$ConvertFrom"],
        methods: {
            ConvertFrom: function (namespaces, sourceUri, value) {
                var $t;
                return ($t = new System.Windows.Media.MatrixTransform.ctor(), $t.Matrix = System.Windows.Media.Matrix.Parse(value.toString()), $t);
            }
        }
    });

    Bridge.define("System.Windows.MultiDataTrigger.MultiDataTriggerConditionProvider", {
        inherits: [System.Windows.IDataTriggerConditionProvider],
        fields: {
            condition: null
        },
        alias: ["CreateDataTriggerCondition", "System$Windows$IDataTriggerConditionProvider$CreateDataTriggerCondition"],
        ctors: {
            ctor: function (condition) {
                this.$initialize();
                this.condition = condition;
            }
        },
        methods: {
            CreateDataTriggerCondition: function (element) {
                return this.condition.CreateDataTriggerCondition(element);
            }
        }
    });

    Bridge.define("System.Windows.MultiDataTriggerCondition", {
        inherits: [System.Windows.IDataTriggerCondition,System.IDisposable],
        statics: {
            methods: {
                Register: function (element, conditionProviders) {
                    var condition = new System.Windows.MultiDataTriggerCondition(element, conditionProviders);
                    condition.Register();
                    return condition;
                }
            }
        },
        fields: {
            isMatched: false,
            element: null,
            conditionProviders: null,
            conditions: null
        },
        events: {
            IsMatchedChanged: null
        },
        props: {
            IsMatched: {
                get: function () {
                    return this.isMatched;
                },
                set: function (value) {
                    if (this.isMatched === value) {
                        return;
                    }

                    this.isMatched = value;
                    Granular.Extensions.EventHandlerExtensions.Raise$2(this.IsMatchedChanged, this);
                }
            }
        },
        alias: [
            "addIsMatchedChanged", "System$Windows$IDataTriggerCondition$addIsMatchedChanged",
            "removeIsMatchedChanged", "System$Windows$IDataTriggerCondition$removeIsMatchedChanged",
            "IsMatched", "System$Windows$IDataTriggerCondition$IsMatched",
            "dispose", "System$IDisposable$dispose"
        ],
        ctors: {
            ctor: function (element, conditionProviders) {
                this.$initialize();
                this.element = element;
                this.conditionProviders = conditionProviders;
            }
        },
        methods: {
            Register: function () {
                var $t;
                this.conditions = System.Linq.Enumerable.from(this.conditionProviders).select(Bridge.fn.bind(this, $asm.$.System.Windows.MultiDataTriggerCondition.f1)).toArray(System.Windows.IDataTriggerCondition);

                $t = Bridge.getEnumerator(this.conditions, System.Windows.IDataTriggerCondition);
                try {
                    while ($t.moveNext()) {
                        var condition = $t.Current;
                        condition.System$Windows$IDataTriggerCondition$addIsMatchedChanged(Bridge.fn.cacheBind(this, this.OnConditionIsMatchedChanged));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                this.IsMatched = System.Linq.Enumerable.from(this.conditions).all($asm.$.System.Windows.MultiDataTriggerCondition.f2);
            },
            dispose: function () {
                var $t;
                $t = Bridge.getEnumerator(this.conditions, System.Windows.IDataTriggerCondition);
                try {
                    while ($t.moveNext()) {
                        var condition = $t.Current;
                        condition.System$Windows$IDataTriggerCondition$removeIsMatchedChanged(Bridge.fn.cacheBind(this, this.OnConditionIsMatchedChanged));

                        if (Bridge.is(condition, System.IDisposable)) {
                            Bridge.cast(condition, System.IDisposable).System$IDisposable$dispose();
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }},
            OnConditionIsMatchedChanged: function (sender, e) {
                this.IsMatched = System.Linq.Enumerable.from(this.conditions).all($asm.$.System.Windows.MultiDataTriggerCondition.f3);
            }
        }
    });

    Bridge.ns("System.Windows.MultiDataTriggerCondition", $asm.$);

    Bridge.apply($asm.$.System.Windows.MultiDataTriggerCondition, {
        f1: function (conditionProvider) {
            return conditionProvider.System$Windows$IDataTriggerConditionProvider$CreateDataTriggerCondition(this.element);
        },
        f2: function (condition1) {
            return condition1.System$Windows$IDataTriggerCondition$IsMatched;
        },
        f3: function (condition) {
            return condition.System$Windows$IDataTriggerCondition$IsMatched;
        }
    });

    Bridge.define("System.Windows.MultiTrigger.TriggerConditionProvider", {
        inherits: [System.Windows.IDataTriggerConditionProvider],
        fields: {
            condition: null
        },
        alias: ["CreateDataTriggerCondition", "System$Windows$IDataTriggerConditionProvider$CreateDataTriggerCondition"],
        ctors: {
            ctor: function (condition) {
                this.$initialize();
                this.condition = condition;
            }
        },
        methods: {
            CreateDataTriggerCondition: function (element) {
                return this.condition.CreateTriggerCondition(element);
            }
        }
    });

    Bridge.define("System.Windows.NameScope", {
        inherits: [System.Windows.INameScope],
        statics: {
            fields: {
                NameScopeProperty: null
            },
            ctors: {
                init: function () {
                    this.NameScopeProperty = System.Windows.DependencyProperty.RegisterAttached("NameScope", System.Windows.INameScope, System.Windows.NameScope, new System.Windows.FrameworkPropertyMetadata.ctor());
                }
            },
            methods: {
                GetNameScope: function (obj) {
                    return Bridge.cast(obj.GetValue(System.Windows.NameScope.NameScopeProperty), System.Windows.INameScope);
                },
                SetNameScope: function (obj, value) {
                    obj.SetValue(System.Windows.NameScope.NameScopeProperty, value);
                },
                GetTemplateNameScope: function (templatedParent) {
                    var templateRoot = System.Linq.Enumerable.from(templatedParent.VisualChildren).firstOrDefault(null, null);
                    return templateRoot != null ? System.Windows.NameScope.GetNameScope(templateRoot) : null;
                },
                GetContainingNameScope: function (element) {
                    while (element != null) {
                        var nameScope = System.Windows.NameScope.GetNameScope(element);
                        if (nameScope != null) {
                            return nameScope;
                        }

                        if (Bridge.is(element, System.Windows.UIElement)) {
                            element = Bridge.cast(element, System.Windows.UIElement).LogicalParent;
                        } else if (Bridge.is(element, System.Windows.IContextElement)) {
                            element = Bridge.as(Bridge.cast(element, System.Windows.IContextElement).System$Windows$IContextElement$ContextParent, System.Windows.DependencyObject);
                        } else {
                            return null;
                        }
                    }

                    return null;
                }
            }
        },
        fields: {
            items: null,
            parent: null
        },
        alias: [
            "registerName", "System$Windows$INameScope$registerName",
            "unregisterName", "System$Windows$INameScope$unregisterName",
            "findName", "System$Windows$INameScope$findName",
            "getEnumerator", ["System$Collections$Generic$IEnumerable$1$System$Collections$Generic$KeyValuePair$2$System$String$System$Object$getEnumerator", "System$Collections$Generic$IEnumerable$1$getEnumerator"]
        ],
        ctors: {
            ctor: function (parent) {
                if (parent === void 0) { parent = null; }

                this.$initialize();
                this.parent = parent;
                this.items = new (System.Collections.Generic.Dictionary$2(System.String,System.Object))();
            }
        },
        methods: {
            registerName: function (name, value) {
                if (this.items.containsKey(name)) {
                    throw new Granular.Exception("Scope already contains an item named \"{0}\"", [name]);
                }

                this.items.add(name, value);
            },
            unregisterName: function (name) {
                if (!this.items.containsKey(name)) {
                    throw new Granular.Exception("Scope doesn't contain an item named \"{0}\"", [name]);
                }

                this.items.remove(name);
            },
            findName: function (name) {
                return this.items.containsKey(name) ? this.items.get(name) : (this.parent != null ? this.parent.System$Windows$INameScope$findName(name) : null);
            },
            getEnumerator: function () {
                return this.parent != null ? System.Linq.Enumerable.from(this.parent).concat(this.items).getEnumerator() : this.items.getEnumerator();
            },
            System$Collections$IEnumerable$getEnumerator: function () {
                return this.getEnumerator();
            }
        }
    });

    Bridge.define("System.Windows.PointTypeConverter", {
        inherits: [System.Windows.Markup.ITypeConverter],
        alias: ["ConvertFrom", "System$Windows$Markup$ITypeConverter$ConvertFrom"],
        methods: {
            ConvertFrom: function (namespaces, sourceUri, value) {
                return System.Windows.Point.Parse(value.toString().trim());
            }
        }
    });

    Bridge.define("System.Windows.PropertyPathElement", {
        inherits: [System.Windows.IPropertyPathElement],
        statics: {
            methods: {
                TryGetValue: function (target, propertyName, value) {
                    var containingType = System.Windows.Markup.XamlNameExtensions.ResolveContainingType(propertyName, Bridge.getType(target));

                    var dependencyProperty = System.Windows.DependencyProperty.GetProperty(containingType, propertyName.MemberName);
                    if (dependencyProperty != null && Bridge.is(target, System.Windows.DependencyObject)) {
                        value.v = Bridge.cast(target, System.Windows.DependencyObject).GetValue(dependencyProperty);
                        return true;
                    }

                    var propertyInfo = Granular.Extensions.TypeExtensions.GetInstanceProperty(containingType, propertyName.MemberName);
                    if (propertyInfo != null && !Granular.Compatibility.Linq.Enumerable.Any(Bridge.global.System.Object, (propertyInfo.ipi || []))) {
                        value.v = Bridge.Reflection.midel(propertyInfo.g, Bridge.unbox(target)).apply(null, System.Array.init(0, null, System.Object));
                        return true;
                    }

                    value.v = null;
                    return false;
                }
            }
        },
        props: {
            PropertyName: null
        },
        alias: [
            "TryGetValue", "System$Windows$IPropertyPathElement$TryGetValue",
            "TryGetDependencyProperty", "System$Windows$IPropertyPathElement$TryGetDependencyProperty",
            "CreatePropertyObserver", "System$Windows$IPropertyPathElement$CreatePropertyObserver"
        ],
        ctors: {
            ctor: function (propertyName) {
                this.$initialize();
                this.PropertyName = propertyName;
            }
        },
        methods: {
            equals: function (obj) {
                var other = Bridge.as(obj, System.Windows.PropertyPathElement);

                return Bridge.referenceEquals(this, other) || !Bridge.referenceEquals(other, null) && System.Windows.Markup.XamlName.op_Equality(this.PropertyName, other.PropertyName);
            },
            getHashCode: function () {
                return this.PropertyName.getHashCode();
            },
            toString: function () {
                return this.PropertyName.HasContainingTypeName ? System.String.format("({0})", this.PropertyName.LocalName) : this.PropertyName.LocalName;
            },
            TryGetValue: function (target, value) {
                return System.Windows.PropertyPathElement.TryGetValue(target, this.PropertyName, value);
            },
            TryGetDependencyProperty: function (containingType, dependencyProperty) {
                dependencyProperty.v = System.Windows.DependencyProperty.GetProperty(System.Windows.Markup.XamlNameExtensions.ResolveContainingType(this.PropertyName, containingType), this.PropertyName.MemberName);
                return dependencyProperty.v != null;
            },
            CreatePropertyObserver: function (baseValueType) {
                var containingType = System.Windows.Markup.XamlNameExtensions.ResolveContainingType(this.PropertyName, baseValueType);

                var dependencyProperty = System.Windows.DependencyProperty.GetProperty(containingType, this.PropertyName.MemberName);
                if (dependencyProperty != null) {
                    return new System.Windows.Data.DependencyPropertyObserver(dependencyProperty);
                }

                var propertyInfo = Granular.Extensions.TypeExtensions.GetInstanceProperty(containingType, this.PropertyName.MemberName);
                if (propertyInfo != null) {
                    return new System.Windows.Data.ClrPropertyObserver(propertyInfo, System.Array.init(0, null, System.Object));
                }

                return null;
            }
        }
    });

    Bridge.define("System.Windows.PropertyPathElementTypeConverter", {
        inherits: [System.Windows.Markup.ITypeConverter],
        alias: ["ConvertFrom", "System$Windows$Markup$ITypeConverter$ConvertFrom"],
        methods: {
            ConvertFrom: function (namespaces, sourceUri, value) {
                return new System.Windows.PropertyPathElement(System.Windows.Markup.XamlName.FromPrefixedName(Bridge.cast(value, System.String), namespaces));
            }
        }
    });

    Bridge.define("System.Windows.PropertyPathTypeConverter", {
        inherits: [System.Windows.Markup.ITypeConverter],
        alias: ["ConvertFrom", "System$Windows$Markup$ITypeConverter$ConvertFrom"],
        methods: {
            ConvertFrom: function (namespaces, sourceUri, value) {
                return System.Windows.PropertyPath.Parse(Bridge.cast(value, System.String), namespaces);
            }
        }
    });

    Bridge.define("System.Windows.ReadOnlyDependencyPropertyValueEntry", {
        inherits: [System.Windows.IDependencyPropertyValueEntry],
        fields: {
            source: null
        },
        events: {
            ValueChanged: null
        },
        props: {
            Value: {
                get: function () {
                    return this.source.System$Windows$IDependencyPropertyValueEntry$Value;
                }
            },
            ValuePriority: {
                get: function () {
                    return this.source.System$Windows$IDependencyPropertyValueEntry$ValuePriority;
                }
            }
        },
        alias: [
            "addValueChanged", "System$Windows$IDependencyPropertyValueEntry$addValueChanged",
            "removeValueChanged", "System$Windows$IDependencyPropertyValueEntry$removeValueChanged",
            "Value", "System$Windows$IDependencyPropertyValueEntry$Value",
            "ValuePriority", "System$Windows$IDependencyPropertyValueEntry$ValuePriority",
            "GetValue", "System$Windows$IDependencyPropertyValueEntry$GetValue",
            "SetValue", "System$Windows$IDependencyPropertyValueEntry$SetValue",
            "GetBaseValuePriority", "System$Windows$IDependencyPropertyValueEntry$GetBaseValuePriority",
            "CoerceValue", "System$Windows$IDependencyPropertyValueEntry$CoerceValue"
        ],
        ctors: {
            ctor: function (source) {
                this.$initialize();
                this.source = source;

                source.System$Windows$IDependencyPropertyValueEntry$addValueChanged(Bridge.fn.bind(this, $asm.$.System.Windows.ReadOnlyDependencyPropertyValueEntry.f1));
            }
        },
        methods: {
            GetValue$1: function (flattened) {
                return this.source.System$Windows$IDependencyPropertyValueEntry$GetValue(this.source.System$Windows$IDependencyPropertyValueEntry$ValuePriority, flattened);
            },
            GetValue: function (priority, flattened) {
                return this.source.System$Windows$IDependencyPropertyValueEntry$GetValue(priority, flattened);
            },
            SetValue: function (priority, value) {
                throw new Granular.Exception("Can't modify a readonly dependency property value");
            },
            GetBaseValuePriority: function () {
                return this.source.System$Windows$IDependencyPropertyValueEntry$GetBaseValuePriority();
            },
            CoerceValue: function () {
                this.source.System$Windows$IDependencyPropertyValueEntry$CoerceValue();
            }
        }
    });

    Bridge.ns("System.Windows.ReadOnlyDependencyPropertyValueEntry", $asm.$);

    Bridge.apply($asm.$.System.Windows.ReadOnlyDependencyPropertyValueEntry, {
        f1: function (sender, e) {
            System.Windows.DependencyPropertyChangedEventHandlerExtensions.Raise(this.ValueChanged, this, e);
        }
    });

    Bridge.define("System.Windows.RectTypeConverter", {
        inherits: [System.Windows.Markup.ITypeConverter],
        alias: ["ConvertFrom", "System$Windows$Markup$ITypeConverter$ConvertFrom"],
        methods: {
            ConvertFrom: function (namespaces, sourceUri, value) {
                return System.Windows.Rect.Parse(value.toString().trim());
            }
        }
    });

    Bridge.define("System.Windows.ResourceDictionary", {
        inherits: [System.Collections.Generic.IDictionary$2(System.Object,System.Object),System.Windows.IResourceContainer,System.Windows.Markup.IUriContext],
        statics: {
            methods: {
                GetMergedDictionariesKeys: function (dictionary) {
                    return System.Linq.Enumerable.from(Bridge.cast(dictionary, System.Collections.Generic.IDictionary$2(System.Object,System.Object)).System$Collections$Generic$IDictionary$2$System$Object$System$Object$Keys).concat(System.Linq.Enumerable.from(dictionary.MergedDictionaries).selectMany(System.Windows.ResourceDictionary.GetMergedDictionariesKeys));
                },
                LoadResourceDictionary: function (source) {
                    return Bridge.as(System.Windows.Application.LoadComponent(source), System.Windows.ResourceDictionary);
                }
            }
        },
        fields: {
            sourceDictionary: null,
            source: null,
            dictionary: null
        },
        events: {
            ResourcesChanged: null
        },
        props: {
            MergedDictionaries: null,
            BaseUri: null,
            Source: {
                get: function () {
                    return this.source;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.source, value)) {
                        return;
                    }

                    if (this.sourceDictionary != null) {
                        this.MergedDictionaries.remove(this.sourceDictionary);
                    }

                    this.source = value;
                    this.sourceDictionary = System.Windows.ResourceDictionary.LoadResourceDictionary(System.UriExtensions.ResolveAbsoluteUri(this.source, this.BaseUri));

                    if (this.sourceDictionary != null) {
                        this.MergedDictionaries.add(this.sourceDictionary);
                    }
                }
            },
            Count: {
                get: function () {
                    return this.dictionary.count;
                }
            },
            IsEmpty: {
                get: function () {
                    return this.Count === 0 && System.Linq.Enumerable.from(this.MergedDictionaries).all($asm.$.System.Windows.ResourceDictionary.f1);
                }
            },
            Keys: {
                get: function () {
                    return this.dictionary.getKeys();
                }
            },
            Values: {
                get: function () {
                    return this.dictionary.getValues();
                }
            },
            IsReadOnly: {
                get: function () {
                    return false;
                }
            }
        },
        alias: [
            "addResourcesChanged", "System$Windows$IResourceContainer$addResourcesChanged",
            "removeResourcesChanged", "System$Windows$IResourceContainer$removeResourcesChanged",
            "BaseUri", "System$Windows$Markup$IUriContext$BaseUri",
            "Count", "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$System$Object$System$Object$Count",
            "IsEmpty", "System$Windows$IResourceContainer$IsEmpty",
            "Keys", "System$Collections$Generic$IDictionary$2$System$Object$System$Object$Keys",
            "Values", "System$Collections$Generic$IDictionary$2$System$Object$System$Object$Values",
            "getItem", "System$Collections$Generic$IDictionary$2$System$Object$System$Object$getItem",
            "setItem", "System$Collections$Generic$IDictionary$2$System$Object$System$Object$setItem",
            "IsReadOnly", "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$System$Object$System$Object$IsReadOnly",
            "tryGetValue", "System$Collections$Generic$IDictionary$2$System$Object$System$Object$tryGetValue",
            "add", "System$Collections$Generic$IDictionary$2$System$Object$System$Object$add",
            "clear", "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$System$Object$System$Object$clear",
            "System$Collections$Generic$IEnumerable$1$System$Collections$Generic$KeyValuePair$2$System$Object$System$Object$getEnumerator", "System$Collections$Generic$IEnumerable$1$getEnumerator"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                this.MergedDictionaries = new (Granular.Collections.ObservableCollection$1(System.Windows.ResourceDictionary)).ctor();
                this.MergedDictionaries.addCollectionChanged(Bridge.fn.cacheBind(this, this.OnMergedDictionariesCollectionChanged));

                this.dictionary = new (System.Collections.Generic.Dictionary$2(System.Object,System.Object))();
            }
        },
        methods: {
            getItem: function (key) {
                return this.GetValue(key);
            },
            setItem: function (key, value) {
                this.add(key, value);
            },
            GetValue: function (key) {
                var value = { };

                if (!this.tryGetValue(key, value)) {
                    throw new Granular.Exception("Cannot find resource named \"{0}\"", [key]);
                }

                return value.v;
            },
            tryGetValue: function (key, value) {
                var $t;
                if (this.dictionary.tryGetValue(key, value)) {
                    if (Bridge.is(value.v, System.Windows.Markup.IValueProvider)) {
                        value.v = Bridge.cast(value.v, System.Windows.Markup.IValueProvider).System$Windows$Markup$IValueProvider$ProvideValue();
                    }

                    return true;
                }

                $t = Bridge.getEnumerator(this.MergedDictionaries);
                try {
                    while ($t.moveNext()) {
                        var mergedDictionary = $t.Current;
                        if (mergedDictionary.tryGetValue(key, value)) {
                            return true;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                value.v = null;
                return false;
            },
            add: function (key, value) {
                this.dictionary.set(key, value);
                Granular.Extensions.EventHandlerExtensions.Raise$4(Bridge.global.System.Windows.ResourcesChangedEventArgs, this.ResourcesChanged, this, System.Windows.ResourcesChangedEventArgs.FromKey(key));
            },
            System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$System$Object$System$Object$add: function (item) {
                this.add(item.key, item.value);
            },
            clear: function () {
                var e = System.Windows.ResourcesChangedEventArgs.FromKeyCollection(System.Linq.Enumerable.from(this.dictionary.getKeys()).toArray());
                this.dictionary.clear();
                Granular.Extensions.EventHandlerExtensions.Raise$4(Bridge.global.System.Windows.ResourcesChangedEventArgs, this.ResourcesChanged, this, e);
            },
            Contains: function (key) {
                return System.Array.contains(this.dictionary.getKeys(), key, System.Object) || System.Linq.Enumerable.from(this.MergedDictionaries).any(function (d) {
                        return System.Array.contains(Bridge.cast(d, System.Collections.Generic.IDictionary$2(System.Object,System.Object)).System$Collections$Generic$IDictionary$2$System$Object$System$Object$Keys, key, System.Object);
                    });
            },
            System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$System$Object$System$Object$contains: function (item) {
                var value = { };
                return this.tryGetValue(item.key, value) && Bridge.referenceEquals(item.value, value.v);
            },
            Remove: function (key) {
                if (this.dictionary.remove(key)) {
                    Granular.Extensions.EventHandlerExtensions.Raise$4(Bridge.global.System.Windows.ResourcesChangedEventArgs, this.ResourcesChanged, this, System.Windows.ResourcesChangedEventArgs.FromKey(key));
                    return true;
                }

                return false;
            },
            System$Collections$Generic$IDictionary$2$System$Object$System$Object$remove: function (key) {
                return this.Remove(key);
            },
            System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$System$Object$System$Object$remove: function (item) {
                return System.Array.contains(Bridge.cast(this, System.Collections.Generic.ICollection$1(System.Collections.Generic.KeyValuePair$2(System.Object,System.Object))), item, System.Collections.Generic.KeyValuePair$2(System.Object,System.Object)) && this.Remove(item.key);
            },
            System$Collections$IEnumerable$getEnumerator: function () {
                return this.dictionary.getEnumerator();
            },
            System$Collections$Generic$IEnumerable$1$System$Collections$Generic$KeyValuePair$2$System$Object$System$Object$getEnumerator: function () {
                return this.dictionary.getEnumerator();
            },
            OnMergedDictionariesCollectionChanged: function (sender, e) {
                var $t, $t1;
                $t = Bridge.getEnumerator(e.OldItems, System.Object);
                try {
                    while ($t.moveNext()) {
                        var dictionary = Bridge.cast($t.Current, System.Windows.ResourceDictionary);
                        dictionary.removeResourcesChanged(Bridge.fn.cacheBind(this, this.OnMergeDictionaryResourcesChanged));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                $t1 = Bridge.getEnumerator(e.NewItems, System.Object);
                try {
                    while ($t1.moveNext()) {
                        var dictionary1 = Bridge.cast($t1.Current, System.Windows.ResourceDictionary);
                        dictionary1.addResourcesChanged(Bridge.fn.cacheBind(this, this.OnMergeDictionaryResourcesChanged));
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$dispose();
                    }
                }
                if (e.Action !== Granular.Collections.NotifyCollectionChangedAction.Move) {
                    var keys = System.Linq.Enumerable.from(e.OldItems).concat(e.NewItems).select(function(x) {{ return Bridge.cast(x, System.Windows.ResourceDictionary); }}).selectMany(System.Windows.ResourceDictionary.GetMergedDictionariesKeys);
                    Granular.Extensions.EventHandlerExtensions.Raise$4(Bridge.global.System.Windows.ResourcesChangedEventArgs, this.ResourcesChanged, this, System.Windows.ResourcesChangedEventArgs.FromKeyCollection(keys));
                }
            },
            OnMergeDictionaryResourcesChanged: function (sender, e) {
                Granular.Extensions.EventHandlerExtensions.Raise$4(Bridge.global.System.Windows.ResourcesChangedEventArgs, this.ResourcesChanged, this, e);
            },
            System$Windows$IResourceContainer$TryGetResource: function (resourceKey, value) {
                return this.tryGetValue(resourceKey, value);
            },
            System$Collections$Generic$IDictionary$2$System$Object$System$Object$containsKey: function (key) {
                return this.Contains(key);
            },
            System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$System$Object$System$Object$copyTo: function (array, arrayIndex) {
                var $t;
                ($t = System.Linq.Enumerable.from(this.dictionary).toArray(), System.Array.copy($t, 0, array, arrayIndex, $t.length));
            }
        }
    });

    Bridge.ns("System.Windows.ResourceDictionary", $asm.$);

    Bridge.apply($asm.$.System.Windows.ResourceDictionary, {
        f1: function (dictionary) {
            return dictionary.IsEmpty;
        }
    });

    Bridge.define("System.Windows.ResourceReferenceExpressionProvider", {
        inherits: [System.Windows.IExpressionProvider],
        fields: {
            resourceKey: null
        },
        alias: ["CreateExpression", "System$Windows$IExpressionProvider$CreateExpression"],
        ctors: {
            ctor: function (resourceKey) {
                this.$initialize();
                this.resourceKey = resourceKey;
            }
        },
        methods: {
            CreateExpression: function (dependencyObject, dependencyProperty) {
                var resourceContainer = Bridge.as(dependencyObject, System.Windows.IResourceContainer);

                if (resourceContainer == null) {
                    throw new Granular.Exception("ResourceReferenceExpression cannot be attached to \"{0}\" as it does not implement \"{1}\"", [Bridge.Reflection.getTypeName(Bridge.getType(dependencyObject)), Bridge.Reflection.getTypeName(System.Windows.IResourceContainer)]);
                }

                return new System.Windows.ResourceReferenceExpression(resourceContainer, this.resourceKey);
            }
        }
    });

    Bridge.define("System.Windows.RoutedEventTypeConverter", {
        inherits: [System.Windows.Markup.ITypeConverter],
        alias: ["ConvertFrom", "System$Windows$Markup$ITypeConverter$ConvertFrom"],
        methods: {
            ConvertFrom: function (namespaces, sourceUri, value) {
                var text = value.toString().trim();

                var eventName = System.Windows.Markup.XamlName.FromPrefixedName(text, namespaces);
                var containingType = System.Windows.Markup.XamlNameExtensions.ResolveContainingType(eventName, null);

                if (containingType == null) {
                    throw new Granular.Exception("Invalid routed event name \"{0}\"", [eventName.LocalName]);
                }

                var routedEvent = System.Windows.EventManager.GetEvent(containingType, eventName.MemberName);

                if (routedEvent == null) {
                    throw new Granular.Exception("Can't find a routed event named \"{0}\"", [eventName]);
                }

                return routedEvent;
            }
        }
    });

    Bridge.define("System.Windows.RoutedPropertyChangedEventArgs$1", function (T) { return {
        inherits: [System.Windows.RoutedEventArgs],
        props: {
            OldValue: Bridge.getDefaultValue(T),
            NewValue: Bridge.getDefaultValue(T)
        },
        ctors: {
            ctor: function (routedEvent, originalSource, oldValue, newValue) {
                this.$initialize();
                System.Windows.RoutedEventArgs.ctor.call(this, routedEvent, originalSource);
                this.OldValue = oldValue;
                this.NewValue = newValue;
            }
        },
        methods: {
            InvokeEventHandler: function (handler, target) {
                if (Bridge.is(handler, Function)) {
                    handler(target, this);
                } else {
                    System.Windows.RoutedEventArgs.prototype.InvokeEventHandler.call(this, handler, target);
                }
            }
        }
    }; });

    Bridge.define("System.Windows.Setter", {
        inherits: [System.Windows.ITriggerAction],
        statics: {
            methods: {
                GetResolvedTarget: function (target, targetName, valueSource) {
                    return Granular.Extensions.StringExtensions.IsNullOrEmpty(targetName) ? target : Bridge.as((valueSource === System.Windows.BaseValueSource.Local ? System.Windows.NameScope.GetContainingNameScope(target) : System.Windows.NameScope.GetTemplateNameScope(target)).System$Windows$INameScope$findName(targetName), System.Windows.FrameworkElement);
                },
                GetResolvedValueSource: function (valueSource, target) {
                    return valueSource === System.Windows.BaseValueSource.TemplateTrigger && target.TemplatedParent != null ? System.Windows.BaseValueSource.ParentTemplateTrigger : valueSource;
                },
                GetInitializedValueOverlapExpression: function (target, property, valueSource) {
                    var valueOverlapExpression = Bridge.as(System.Windows.DependencyPropertyValueEntryExtensions.GetBaseValue$1(target.GetValueEntry(property), valueSource, false), System.Windows.Setter.ValueOverlapExpression);

                    if (valueOverlapExpression == null) {
                        valueOverlapExpression = new System.Windows.Setter.ValueOverlapExpression();
                        target.SetValue(property, valueOverlapExpression, valueSource);
                    }

                    return valueOverlapExpression;
                },
                IsStyleValueSource: function (valueSource) {
                    return valueSource === System.Windows.BaseValueSource.ThemeStyle || valueSource === System.Windows.BaseValueSource.Style;
                }
            }
        },
        props: {
            Property: null,
            Value: null,
            TargetName: null
        },
        alias: [
            "Apply", "System$Windows$ITriggerAction$Apply",
            "Clean", "System$Windows$ITriggerAction$Clean",
            "IsActionOverlaps", "System$Windows$ITriggerAction$IsActionOverlaps"
        ],
        methods: {
            Apply: function (target, valueSource) {
                if (this.Property == null) {
                    throw new Granular.Exception("Setter.Property cannot be null");
                }

                var resolvedTarget = System.Windows.Setter.GetResolvedTarget(target, this.TargetName, valueSource);
                var resolvedProperty = System.Windows.PropertyPathElementExtensions.GetDependencyProperty(this.Property, Bridge.getType(resolvedTarget));
                var resolvedValue = this.Value == null || Bridge.is(this.Value, System.Windows.IExpressionProvider) || Bridge.Reflection.isInstanceOfType(this.Value, resolvedProperty.PropertyType) ? this.Value : System.Windows.Markup.TypeConverter.ConvertValue(this.Value.toString(), resolvedProperty.PropertyType, System.Windows.Markup.XamlNamespaces.Empty, null);
                var resolvedValueSource = System.Windows.Setter.GetResolvedValueSource(valueSource, resolvedTarget);

                if (System.Windows.Setter.IsStyleValueSource(valueSource)) {
                    resolvedTarget.SetValue(resolvedProperty, resolvedValue, resolvedValueSource);
                } else {
                    System.Windows.Setter.GetInitializedValueOverlapExpression(resolvedTarget, resolvedProperty, resolvedValueSource).SetValue$1(this, resolvedValue);
                }
            },
            Clean: function (target, valueSource) {
                if (this.Property == null) {
                    throw new Granular.Exception("Setter.Property cannot be null");
                }

                var resolvedTarget = System.Windows.Setter.GetResolvedTarget(target, this.TargetName, valueSource);
                var resolvedProperty = System.Windows.PropertyPathElementExtensions.GetDependencyProperty(this.Property, Bridge.getType(resolvedTarget));
                var resolvedValueSource = System.Windows.Setter.GetResolvedValueSource(valueSource, resolvedTarget);

                if (System.Windows.Setter.IsStyleValueSource(valueSource)) {
                    resolvedTarget.ClearValue(resolvedProperty, resolvedValueSource);
                } else {
                    System.Windows.Setter.GetInitializedValueOverlapExpression(resolvedTarget, resolvedProperty, resolvedValueSource).ClearValue(this);
                }
            },
            IsActionOverlaps: function (action) {
                if (this.Property == null) {
                    throw new Granular.Exception("Setter.Property cannot be null");
                }

                return Bridge.is(action, System.Windows.Setter) && Bridge.referenceEquals(this.TargetName, Bridge.cast(action, System.Windows.Setter).TargetName) && Bridge.equals(this.Property, Bridge.cast(action, System.Windows.Setter).Property);
            }
        }
    });

    Bridge.define("System.Windows.SizeTypeConverter", {
        inherits: [System.Windows.Markup.ITypeConverter],
        alias: ["ConvertFrom", "System$Windows$Markup$ITypeConverter$ConvertFrom"],
        methods: {
            ConvertFrom: function (namespaces, sourceUri, value) {
                return System.Windows.Size.Parse(value.toString().trim());
            }
        }
    });

    Bridge.define("System.Windows.StaticResourceExtension", {
        inherits: [System.Windows.Markup.IMarkupExtension],
        statics: {
            methods: {
                GetStaticResource: function (context, resourceKey) {
                    if (context == null) {
                        throw new Granular.Exception("StaticResource \"{0}\" was not found", [resourceKey]);
                    }

                    var value = { };
                    return Bridge.is(context.Target, System.Windows.IResourceContainer) && Bridge.cast(context.Target, System.Windows.IResourceContainer).System$Windows$IResourceContainer$TryGetResource(resourceKey, value) ? value.v : System.Windows.StaticResourceExtension.GetStaticResource(context.ParentContext, resourceKey);
                }
            }
        },
        props: {
            ResourceKey: null
        },
        alias: ["ProvideValue", "System$Windows$Markup$IMarkupExtension$ProvideValue"],
        methods: {
            ProvideValue: function (context) {
                return System.Windows.StaticResourceExtension.GetStaticResource(context, this.ResourceKey);
            }
        }
    });

    Bridge.define("System.Windows.StyleKey", {
        inherits: [System.Windows.IResourceKey],
        fields: {
            hashCode: 0
        },
        props: {
            Assembly: {
                get: function () {
                    return this.TargetType != null ? Bridge.Reflection.getTypeAssembly(this.TargetType) : null;
                }
            },
            TargetType: null
        },
        alias: ["Assembly", "System$Windows$IResourceKey$Assembly"],
        ctors: {
            ctor: function (targetType) {
                this.$initialize();
                this.TargetType = targetType;

                this.hashCode = Bridge.getHashCode(this.TargetType);
            }
        },
        methods: {
            equals: function (obj) {
                var other = Bridge.as(obj, System.Windows.StyleKey);

                return Bridge.referenceEquals(this, other) || !Bridge.referenceEquals(other, null) && Bridge.equals(this.TargetType, other.TargetType);
            },
            getHashCode: function () {
                return this.hashCode;
            },
            toString: function () {
                return System.String.format("StyleKey({0})", Bridge.Reflection.getTypeName(this.TargetType));
            }
        }
    });

    Bridge.define("System.Windows.StyleKeyProvider", {
        inherits: [System.Windows.Markup.IDeferredValueKeyProvider],
        alias: ["GetValueKey", "System$Windows$Markup$IDeferredValueKeyProvider$GetValueKey"],
        methods: {
            GetValueKey: function (element) {
                var keyMember = System.Linq.Enumerable.from(element.Members).singleOrDefault($asm.$.System.Windows.StyleKeyProvider.f1, null);
                if (keyMember != null) {
                    return System.Windows.Markup.ElementFactory.FromValue(System.Linq.Enumerable.from(keyMember.Values).single(), System.Object, element.Namespaces, element.SourceUri).System$Windows$Markup$IElementFactory$CreateElement(new System.Windows.Markup.InitializeContext.ctor());
                }

                var targetTypeMember = System.Linq.Enumerable.from(element.Members).singleOrDefault($asm.$.System.Windows.StyleKeyProvider.f2, null);
                if (targetTypeMember != null) {
                    return new System.Windows.StyleKey(Bridge.cast(System.Windows.Markup.ElementFactory.FromValue(System.Linq.Enumerable.from(targetTypeMember.Values).single(), Function, element.Namespaces, element.SourceUri).System$Windows$Markup$IElementFactory$CreateElement(new System.Windows.Markup.InitializeContext.ctor()), Function));
                }

                throw new Granular.Exception(System.String.format("Can't create value key from \"{0}\"", element.Name));
            }
        }
    });

    Bridge.ns("System.Windows.StyleKeyProvider", $asm.$);

    Bridge.apply($asm.$.System.Windows.StyleKeyProvider, {
        f1: function (member) {
            return Bridge.referenceEquals(member.Name.LocalName, "Key");
        },
        f2: function (member) {
            return Bridge.referenceEquals(member.Name.LocalName, "TargetType");
        }
    });

    Bridge.define("System.Windows.SystemResources", {
        inherits: [System.Windows.IResourceContainer],
        statics: {
            fields: {
                ThemeName: null,
                ThemeNameAndColor: null
            },
            ctors: {
                init: function () {
                    this.ThemeName = "Generic";
                    this.ThemeNameAndColor = "Generic";
                }
            },
            methods: {
                ResolveAssemblyThemeResources: function (assembly, value) {
                    var themeInfoAttribute = Granular.Extensions.AssemblyExtensions.FirstOrDefaultCustomAttributeCached(System.Windows.ThemeInfoAttribute, assembly);

                    if (themeInfoAttribute == null || themeInfoAttribute.GenericDictionaryLocation === System.Windows.ResourceDictionaryLocation.None) {
                        value.v = null;
                        return false;
                    }

                    var themeResourcesAssemblyName = themeInfoAttribute.GenericDictionaryLocation === System.Windows.ResourceDictionaryLocation.SourceAssembly ? System.AssemblyExtensions.GetName(assembly).Name : System.String.format("{0}.{1}", System.AssemblyExtensions.GetName(assembly).Name, System.Windows.SystemResources.ThemeName);

                    value.v = Bridge.cast(System.Windows.EmbeddedResourceLoader.LoadResourceElement(Granular.Compatibility.Uri.CreateAbsoluteUri(System.String.format("pack://application:,,,/{0};component/Themes/{1}.xaml", themeResourcesAssemblyName, System.Windows.SystemResources.ThemeNameAndColor))), System.Windows.ResourceDictionary);
                    return true;
                }
            }
        },
        fields: {
            themeResourcesCache: null
        },
        props: {
            IsEmpty: {
                get: function () {
                    return false;
                }
            }
        },
        alias: [
            "IsEmpty", "System$Windows$IResourceContainer$IsEmpty",
            "TryGetResource", "System$Windows$IResourceContainer$TryGetResource"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                this.themeResourcesCache = Granular.Collections.CacheDictionary$2(System.Reflection.Assembly,System.Windows.ResourceDictionary).CreateUsingStringKeys$1(System.Windows.SystemResources.ResolveAssemblyThemeResources, $asm.$.System.Windows.SystemResources.f1);
            }
        },
        methods: {
            System$Windows$IResourceContainer$addResourcesChanged: function (value) { },
            System$Windows$IResourceContainer$removeResourcesChanged: function (value) { },
            TryGetResource: function (resourceKey, value) {
                var $t;
                value.v = null;

                var assembly = ($t = (Bridge.as(resourceKey, System.Windows.IResourceKey))) != null ? $t.System$Windows$IResourceKey$Assembly : null;
                if (assembly == null) {
                    return false;
                }

                var themeResources = { };
                return this.themeResourcesCache.TryGetValue(assembly, themeResources) && themeResources.v.tryGetValue(resourceKey, value);
            }
        }
    });

    Bridge.ns("System.Windows.SystemResources", $asm.$);

    Bridge.apply($asm.$.System.Windows.SystemResources, {
        f1: function (assembly) {
            return assembly.name;
        }
    });

    Bridge.define("System.Windows.TemplateBindingExtension", {
        inherits: [System.Windows.Markup.IMarkupExtension],
        props: {
            Property: null,
            Converter: null,
            ConverterParameter: null
        },
        alias: ["ProvideValue", "System$Windows$Markup$IMarkupExtension$ProvideValue"],
        methods: {
            ProvideValue: function (context) {
                var $t, $t1;
                return ($t = new System.Windows.Data.Binding(), $t.Path = new System.Windows.PropertyPath(System.Array.init([this.Property], System.Windows.IPropertyPathElement)), $t.RelativeSource = ($t1 = new System.Windows.Data.RelativeSource(), $t1.Mode = System.Windows.Data.RelativeSourceMode.TemplatedParent, $t1), $t.Converter = this.Converter, $t.ConverterParameter = this.ConverterParameter, $t);
            }
        }
    });

    Bridge.define("System.Windows.TemplateKey", {
        inherits: [System.Windows.IResourceKey],
        fields: {
            hashCode: 0
        },
        props: {
            Assembly: {
                get: function () {
                    return this.TargetType != null ? Bridge.Reflection.getTypeAssembly(this.TargetType) : null;
                }
            },
            TargetType: null
        },
        alias: ["Assembly", "System$Windows$IResourceKey$Assembly"],
        ctors: {
            ctor: function (targetType) {
                this.$initialize();
                this.TargetType = targetType;
                this.hashCode = Bridge.getHashCode(targetType);
            }
        },
        methods: {
            equals: function (obj) {
                var other = Bridge.as(obj, System.Windows.TemplateKey);

                return Bridge.referenceEquals(this, other) || !Bridge.referenceEquals(other, null) && Bridge.equals(this.TargetType, other.TargetType);
            },
            getHashCode: function () {
                return this.hashCode;
            },
            toString: function () {
                return System.String.format("TemplateKey({0})", Bridge.Reflection.getTypeName(this.TargetType));
            }
        }
    });

    Bridge.define("System.Windows.ThicknessTypeConverter", {
        inherits: [System.Windows.Markup.ITypeConverter],
        alias: ["ConvertFrom", "System$Windows$Markup$ITypeConverter$ConvertFrom"],
        methods: {
            ConvertFrom: function (namespaces, sourceUri, value) {
                return System.Windows.Thickness.Parse(value.toString().trim());
            }
        }
    });

    Bridge.define("System.Windows.Threading.DispatcherOperation$1", function (TResult) { return {
        inherits: [System.Windows.Threading.DispatcherOperation],
        props: {
            Result$1: {
                get: function () {
                    return Bridge.cast(Bridge.unbox(this.Result), TResult);
                }
            }
        },
        ctors: {
            ctor: function (action, priority) {
                this.$initialize();
                System.Windows.Threading.DispatcherOperation.$ctor1.call(this, function () {
                    return action();
                }, priority);
                //
            }
        }
    }; });

    Bridge.define("System.Windows.TriggerCondition", {
        inherits: [System.Windows.IDataTriggerCondition,System.IDisposable],
        statics: {
            methods: {
                Register: function (element, property, value) {
                    var condition = new System.Windows.TriggerCondition(element, property, value);
                    condition.Register();

                    return condition;
                }
            }
        },
        fields: {
            isMatched: false,
            element: null,
            property: null,
            value: null
        },
        events: {
            IsMatchedChanged: null
        },
        props: {
            IsMatched: {
                get: function () {
                    return this.isMatched;
                },
                set: function (value) {
                    if (this.isMatched === value) {
                        return;
                    }

                    this.isMatched = value;
                    Granular.Extensions.EventHandlerExtensions.Raise$2(this.IsMatchedChanged, this);
                }
            }
        },
        alias: [
            "addIsMatchedChanged", "System$Windows$IDataTriggerCondition$addIsMatchedChanged",
            "removeIsMatchedChanged", "System$Windows$IDataTriggerCondition$removeIsMatchedChanged",
            "IsMatched", "System$Windows$IDataTriggerCondition$IsMatched",
            "dispose", "System$IDisposable$dispose"
        ],
        ctors: {
            ctor: function (element, property, value) {
                this.$initialize();
                this.element = element;
                this.property = property;
                this.value = value;
            }
        },
        methods: {
            Register: function () {
                this.IsMatched = Granular.Compatibility.EqualityComparer.Default.equals2(this.element.GetValue(this.property), this.value);

                this.element.addPropertyChanged(Bridge.fn.cacheBind(this, this.OnPropertyChanged));
            },
            dispose: function () {
                this.element.removePropertyChanged(Bridge.fn.cacheBind(this, this.OnPropertyChanged));
            },
            OnPropertyChanged: function (sender, e) {
                if (!Bridge.referenceEquals(e.Property, this.property)) {
                    return;
                }

                this.IsMatched = Granular.Compatibility.EqualityComparer.Default.equals2(e.NewValue, this.value);
            }
        }
    });

    Bridge.define("System.Windows.UIElement", {
        inherits: [System.Windows.Media.Visual,System.Windows.Media.Animation.IAnimatable,System.Windows.IInputElement],
        statics: {
            fields: {
                OpacityProperty: null,
                VisibilityProperty: null,
                IsVisiblePropertyKey: null,
                IsVisibleProperty: null,
                IsEnabledProperty: null,
                IsHitTestVisibleProperty: null,
                ClipToBoundsProperty: null,
                FocusableProperty: null,
                IsMouseOverPropertyKey: null,
                IsMouseOverProperty: null,
                IsFocusedPropertyKey: null,
                IsFocusedProperty: null,
                IsKeyboardFocusedPropertyKey: null,
                IsKeyboardFocusedProperty: null,
                IsKeyboardFocusWithinPropertyKey: null,
                IsKeyboardFocusWithinProperty: null,
                RenderTransformProperty: null,
                RenderTransformOriginProperty: null,
                ClipProperty: null,
                PreviewMouseMoveEvent: null,
                PreviewMouseDownEvent: null,
                PreviewMouseUpEvent: null,
                PreviewMouseWheelEvent: null,
                MouseMoveEvent: null,
                MouseDownEvent: null,
                MouseUpEvent: null,
                MouseWheelEvent: null,
                MouseEnterEvent: null,
                MouseLeaveEvent: null,
                QueryCursorEvent: null,
                PreviewKeyDownEvent: null,
                PreviewKeyUpEvent: null,
                PreviewGotKeyboardFocusEvent: null,
                PreviewLostKeyboardFocusEvent: null,
                KeyDownEvent: null,
                KeyUpEvent: null,
                GotKeyboardFocusEvent: null,
                LostKeyboardFocusEvent: null,
                GotFocusEvent: null,
                LostFocusEvent: null
            },
            ctors: {
                init: function () {
                    this.OpacityProperty = System.Windows.DependencyProperty.Register("Opacity", System.Double, System.Windows.UIElement, new System.Windows.FrameworkPropertyMetadata.$ctor6(Bridge.box(1.0, System.Double, System.Double.format, System.Double.getHashCode), $asm.$.System.Windows.UIElement.f1));
                    this.VisibilityProperty = System.Windows.DependencyProperty.Register("Visibility", System.Windows.Visibility, System.Windows.UIElement, new System.Windows.FrameworkPropertyMetadata.$ctor3(Bridge.box(System.Windows.Visibility.Visible, System.Windows.Visibility, System.Enum.toStringFn(System.Windows.Visibility)), System.Windows.FrameworkPropertyMetadataOptions.AffectsParentMeasure, $asm.$.System.Windows.UIElement.f2));
                    this.IsVisiblePropertyKey = System.Windows.DependencyProperty.RegisterReadOnly("IsVisible", System.Boolean, System.Windows.UIElement, new System.Windows.FrameworkPropertyMetadata.$ctor7(Bridge.box(true, System.Boolean, System.Boolean.toString), $asm.$.System.Windows.UIElement.f3, $asm.$.System.Windows.UIElement.f4));
                    this.IsVisibleProperty = System.Windows.UIElement.IsVisiblePropertyKey.DependencyProperty;
                    this.IsEnabledProperty = System.Windows.DependencyProperty.Register("IsEnabled", System.Boolean, System.Windows.UIElement, new System.Windows.FrameworkPropertyMetadata.$ctor7(Bridge.box(true, System.Boolean, System.Boolean.toString), $asm.$.System.Windows.UIElement.f5, $asm.$.System.Windows.UIElement.f6));
                    this.IsHitTestVisibleProperty = System.Windows.DependencyProperty.Register("IsHitTestVisible", System.Boolean, System.Windows.UIElement, new System.Windows.FrameworkPropertyMetadata.$ctor7(Bridge.box(true, System.Boolean, System.Boolean.toString), $asm.$.System.Windows.UIElement.f7, $asm.$.System.Windows.UIElement.f8));
                    this.ClipToBoundsProperty = System.Windows.DependencyProperty.Register("ClipToBounds", System.Boolean, System.Windows.UIElement, new System.Windows.FrameworkPropertyMetadata.$ctor6(Bridge.box(false, System.Boolean, System.Boolean.toString), $asm.$.System.Windows.UIElement.f9));
                    this.FocusableProperty = System.Windows.DependencyProperty.Register("Focusable", System.Boolean, System.Windows.UIElement, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.UIElement.f10));
                    this.IsMouseOverPropertyKey = System.Windows.DependencyProperty.RegisterReadOnly("IsMouseOver", System.Boolean, System.Windows.UIElement, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.IsMouseOverProperty = System.Windows.UIElement.IsMouseOverPropertyKey.DependencyProperty;
                    this.IsFocusedPropertyKey = System.Windows.DependencyProperty.RegisterReadOnly("IsFocused", System.Boolean, System.Windows.UIElement, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.IsFocusedProperty = System.Windows.UIElement.IsFocusedPropertyKey.DependencyProperty;
                    this.IsKeyboardFocusedPropertyKey = System.Windows.DependencyProperty.RegisterReadOnly("IsKeyboardFocused", System.Boolean, System.Windows.UIElement, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.IsKeyboardFocusedProperty = System.Windows.UIElement.IsKeyboardFocusedPropertyKey.DependencyProperty;
                    this.IsKeyboardFocusWithinPropertyKey = System.Windows.DependencyProperty.RegisterReadOnly("IsKeyboardFocusWithin", System.Boolean, System.Windows.UIElement, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.IsKeyboardFocusWithinProperty = System.Windows.UIElement.IsKeyboardFocusWithinPropertyKey.DependencyProperty;
                    this.RenderTransformProperty = System.Windows.DependencyProperty.Register("RenderTransform", System.Windows.Media.Transform, System.Windows.UIElement, new System.Windows.FrameworkPropertyMetadata.$ctor6(System.Windows.Media.Transform.Identity, $asm.$.System.Windows.UIElement.f11));
                    this.RenderTransformOriginProperty = System.Windows.DependencyProperty.Register("RenderTransformOrigin", System.Windows.Point, System.Windows.UIElement, new System.Windows.FrameworkPropertyMetadata.$ctor6(System.Windows.Point.Zero, $asm.$.System.Windows.UIElement.f12));
                    this.ClipProperty = System.Windows.DependencyProperty.Register("Clip", System.Windows.Media.Geometry, System.Windows.UIElement, new System.Windows.FrameworkPropertyMetadata.$ctor6(null, $asm.$.System.Windows.UIElement.f13));
                    this.PreviewMouseMoveEvent = System.Windows.Input.Mouse.PreviewMouseMoveEvent.AddOwner(System.Windows.UIElement);
                    this.PreviewMouseDownEvent = System.Windows.Input.Mouse.PreviewMouseDownEvent.AddOwner(System.Windows.UIElement);
                    this.PreviewMouseUpEvent = System.Windows.Input.Mouse.PreviewMouseUpEvent.AddOwner(System.Windows.UIElement);
                    this.PreviewMouseWheelEvent = System.Windows.Input.Mouse.PreviewMouseWheelEvent.AddOwner(System.Windows.UIElement);
                    this.MouseMoveEvent = System.Windows.Input.Mouse.MouseMoveEvent.AddOwner(System.Windows.UIElement);
                    this.MouseDownEvent = System.Windows.Input.Mouse.MouseDownEvent.AddOwner(System.Windows.UIElement);
                    this.MouseUpEvent = System.Windows.Input.Mouse.MouseUpEvent.AddOwner(System.Windows.UIElement);
                    this.MouseWheelEvent = System.Windows.Input.Mouse.MouseWheelEvent.AddOwner(System.Windows.UIElement);
                    this.MouseEnterEvent = System.Windows.Input.Mouse.MouseEnterEvent.AddOwner(System.Windows.UIElement);
                    this.MouseLeaveEvent = System.Windows.Input.Mouse.MouseLeaveEvent.AddOwner(System.Windows.UIElement);
                    this.QueryCursorEvent = System.Windows.Input.Mouse.QueryCursorEvent.AddOwner(System.Windows.UIElement);
                    this.PreviewKeyDownEvent = System.Windows.Input.Keyboard.PreviewKeyDownEvent.AddOwner(System.Windows.UIElement);
                    this.PreviewKeyUpEvent = System.Windows.Input.Keyboard.PreviewKeyUpEvent.AddOwner(System.Windows.UIElement);
                    this.PreviewGotKeyboardFocusEvent = System.Windows.Input.Keyboard.PreviewGotKeyboardFocusEvent.AddOwner(System.Windows.UIElement);
                    this.PreviewLostKeyboardFocusEvent = System.Windows.Input.Keyboard.PreviewLostKeyboardFocusEvent.AddOwner(System.Windows.UIElement);
                    this.KeyDownEvent = System.Windows.Input.Keyboard.KeyDownEvent.AddOwner(System.Windows.UIElement);
                    this.KeyUpEvent = System.Windows.Input.Keyboard.KeyUpEvent.AddOwner(System.Windows.UIElement);
                    this.GotKeyboardFocusEvent = System.Windows.Input.Keyboard.GotKeyboardFocusEvent.AddOwner(System.Windows.UIElement);
                    this.LostKeyboardFocusEvent = System.Windows.Input.Keyboard.LostKeyboardFocusEvent.AddOwner(System.Windows.UIElement);
                    this.GotFocusEvent = System.Windows.Input.FocusManager.GotFocusEvent.AddOwner(System.Windows.UIElement);
                    this.LostFocusEvent = System.Windows.Input.FocusManager.LostFocusEvent.AddOwner(System.Windows.UIElement);
                },
                ctor: function () {
                    System.Windows.EventManager.RegisterClassHandler(System.Windows.UIElement, System.Windows.Input.Mouse.MouseEnterEvent, System.Windows.UIElement.OnMouseEnter, false);
                    System.Windows.EventManager.RegisterClassHandler(System.Windows.UIElement, System.Windows.Input.Mouse.MouseLeaveEvent, System.Windows.UIElement.OnMouseLeave, false);
                    System.Windows.EventManager.RegisterClassHandler(System.Windows.UIElement, System.Windows.Input.Mouse.QueryCursorEvent, $asm.$.System.Windows.UIElement.f14, true);

                    System.Windows.EventManager.RegisterClassHandler(System.Windows.UIElement, System.Windows.Input.Mouse.PreviewMouseMoveEvent, $asm.$.System.Windows.UIElement.f15, false);
                    System.Windows.EventManager.RegisterClassHandler(System.Windows.UIElement, System.Windows.Input.Mouse.PreviewMouseDownEvent, $asm.$.System.Windows.UIElement.f16, false);
                    System.Windows.EventManager.RegisterClassHandler(System.Windows.UIElement, System.Windows.Input.Mouse.PreviewMouseUpEvent, $asm.$.System.Windows.UIElement.f17, false);
                    System.Windows.EventManager.RegisterClassHandler(System.Windows.UIElement, System.Windows.Input.Mouse.PreviewMouseWheelEvent, $asm.$.System.Windows.UIElement.f18, false);

                    System.Windows.EventManager.RegisterClassHandler(System.Windows.UIElement, System.Windows.Input.Mouse.MouseMoveEvent, $asm.$.System.Windows.UIElement.f19, false);
                    System.Windows.EventManager.RegisterClassHandler(System.Windows.UIElement, System.Windows.Input.Mouse.MouseDownEvent, $asm.$.System.Windows.UIElement.f20, false);
                    System.Windows.EventManager.RegisterClassHandler(System.Windows.UIElement, System.Windows.Input.Mouse.MouseUpEvent, $asm.$.System.Windows.UIElement.f21, false);
                    System.Windows.EventManager.RegisterClassHandler(System.Windows.UIElement, System.Windows.Input.Mouse.MouseWheelEvent, $asm.$.System.Windows.UIElement.f22, false);

                    System.Windows.EventManager.RegisterClassHandler(System.Windows.UIElement, System.Windows.Input.Keyboard.GotKeyboardFocusEvent, System.Windows.UIElement.OnGotKeyboardFocus, true);
                    System.Windows.EventManager.RegisterClassHandler(System.Windows.UIElement, System.Windows.Input.Keyboard.LostKeyboardFocusEvent, System.Windows.UIElement.OnLostKeyboardFocus, true);

                    System.Windows.EventManager.RegisterClassHandler(System.Windows.UIElement, System.Windows.Input.Keyboard.PreviewKeyDownEvent, $asm.$.System.Windows.UIElement.f23, false);
                    System.Windows.EventManager.RegisterClassHandler(System.Windows.UIElement, System.Windows.Input.Keyboard.PreviewKeyUpEvent, $asm.$.System.Windows.UIElement.f24, false);
                    System.Windows.EventManager.RegisterClassHandler(System.Windows.UIElement, System.Windows.Input.Keyboard.KeyDownEvent, $asm.$.System.Windows.UIElement.f25, false);
                    System.Windows.EventManager.RegisterClassHandler(System.Windows.UIElement, System.Windows.Input.Keyboard.KeyUpEvent, $asm.$.System.Windows.UIElement.f26, false);

                    System.Windows.EventManager.RegisterClassHandler(System.Windows.UIElement, System.Windows.Input.FocusManager.GotFocusEvent, System.Windows.UIElement.OnGotFocus, false);
                    System.Windows.EventManager.RegisterClassHandler(System.Windows.UIElement, System.Windows.Input.FocusManager.LostFocusEvent, System.Windows.UIElement.OnLostFocus, false);
                }
            },
            methods: {
                AddHandler: function (element, routedEvent, handler, handledEventsToo) {
                    if (handledEventsToo === void 0) { handledEventsToo = false; }
                    if (Bridge.is(element, System.Windows.UIElement)) {
                        Bridge.cast(element, System.Windows.UIElement).AddHandler(routedEvent, handler, handledEventsToo);
                    }
                },
                RemoveHandler: function (element, routedEvent, handler) {
                    if (Bridge.is(element, System.Windows.UIElement)) {
                        Bridge.cast(element, System.Windows.UIElement).RemoveHandler(routedEvent, handler);
                    }
                },
                OnMouseEnter: function (sender, e) {
                    Bridge.cast(sender, System.Windows.UIElement).IsMouseOver = true;
                    Bridge.cast(sender, System.Windows.UIElement).OnMouseEnter(e);
                },
                OnMouseLeave: function (sender, e) {
                    Bridge.cast(sender, System.Windows.UIElement).IsMouseOver = false;
                    Bridge.cast(sender, System.Windows.UIElement).OnMouseLeave(e);
                },
                OnGotKeyboardFocus: function (sender, e) {
                    Bridge.cast(sender, System.Windows.UIElement).IsKeyboardFocused = Bridge.referenceEquals(e.OriginalSource, sender);
                    Bridge.cast(sender, System.Windows.UIElement).IsKeyboardFocusWithin = true;
                    Bridge.cast(sender, System.Windows.UIElement).OnGotKeyboardFocus(e);
                },
                OnLostKeyboardFocus: function (sender, e) {
                    Bridge.cast(sender, System.Windows.UIElement).IsKeyboardFocused = false;
                    Bridge.cast(sender, System.Windows.UIElement).IsKeyboardFocusWithin = false;
                    Bridge.cast(sender, System.Windows.UIElement).OnLostKeyboardFocus(e);
                },
                OnGotFocus: function (sender, e) {
                    Bridge.cast(sender, System.Windows.UIElement).IsFocused = true;
                    Bridge.cast(sender, System.Windows.UIElement).OnGotFocus(e);
                },
                OnLostFocus: function (sender, e) {
                    Bridge.cast(sender, System.Windows.UIElement).IsFocused = false;
                    Bridge.cast(sender, System.Windows.UIElement).OnLostFocus(e);
                }
            }
        },
        fields: {
            logicalParent: null,
            logicalChildren: null,
            isRootElement: false,
            animatableRootClock: null,
            disableMeasureInvalidationRequests: 0,
            disableMeasureInvalidationToken: null,
            routedEventHandlers: null,
            routedEventHandlersCache: null,
            previousDesiredSize: null,
            focus: null,
            renderElementFactory$1: null,
            drawingRenderElement: null,
            renderOperation: null
        },
        events: {
            LayoutUpdated: null
        },
        props: {
            LogicalParent: {
                get: function () {
                    return this.logicalParent;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.logicalParent, value)) {
                        return;
                    }

                    var oldLogicalParent = this.logicalParent;
                    this.logicalParent = value;
                    this.SetInheritanceParent$1();
                    this.OnLogicalParentChanged(oldLogicalParent, this.logicalParent);
                }
            },
            IsVisualValid: false,
            IsMeasureValid: false,
            IsArrangeValid: false,
            DesiredSize: null,
            RenderSize: {
                get: function () {
                    return this.VisualSize;
                }
            },
            LogicalChildren: null,
            Opacity: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.UIElement.OpacityProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.UIElement.OpacityProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            Visibility: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.UIElement.VisibilityProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.UIElement.VisibilityProperty, Bridge.box(value, System.Windows.Visibility, System.Enum.toStringFn(System.Windows.Visibility)));
                }
            },
            IsVisible: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue$1(System.Windows.UIElement.IsVisiblePropertyKey)), System.Boolean));
                },
                set: function (value) {
                    this.SetValue$1(System.Windows.UIElement.IsVisiblePropertyKey, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            },
            IsEnabled: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.UIElement.IsEnabledProperty)), System.Boolean));
                },
                set: function (value) {
                    this.SetValue(System.Windows.UIElement.IsEnabledProperty, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            },
            IsHitTestVisible: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.UIElement.IsHitTestVisibleProperty)), System.Boolean));
                },
                set: function (value) {
                    this.SetValue(System.Windows.UIElement.IsHitTestVisibleProperty, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            },
            ClipToBounds: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.UIElement.ClipToBoundsProperty)), System.Boolean));
                },
                set: function (value) {
                    this.SetValue(System.Windows.UIElement.ClipToBoundsProperty, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            },
            Focusable: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.UIElement.FocusableProperty)), System.Boolean));
                },
                set: function (value) {
                    this.SetValue(System.Windows.UIElement.FocusableProperty, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            },
            IsMouseOver: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue$1(System.Windows.UIElement.IsMouseOverPropertyKey)), System.Boolean));
                },
                set: function (value) {
                    this.SetValue$1(System.Windows.UIElement.IsMouseOverPropertyKey, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            },
            IsFocused: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue$1(System.Windows.UIElement.IsFocusedPropertyKey)), System.Boolean));
                },
                set: function (value) {
                    this.SetValue$1(System.Windows.UIElement.IsFocusedPropertyKey, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            },
            IsKeyboardFocused: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue$1(System.Windows.UIElement.IsKeyboardFocusedPropertyKey)), System.Boolean));
                },
                set: function (value) {
                    this.SetValue$1(System.Windows.UIElement.IsKeyboardFocusedPropertyKey, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            },
            IsKeyboardFocusWithin: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue$1(System.Windows.UIElement.IsKeyboardFocusWithinPropertyKey)), System.Boolean));
                },
                set: function (value) {
                    this.SetValue$1(System.Windows.UIElement.IsKeyboardFocusWithinPropertyKey, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            },
            RenderTransform: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.UIElement.RenderTransformProperty), System.Windows.Media.Transform);
                },
                set: function (value) {
                    this.SetValue(System.Windows.UIElement.RenderTransformProperty, value);
                }
            },
            RenderTransformOrigin: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.UIElement.RenderTransformOriginProperty), System.Windows.Point);
                },
                set: function (value) {
                    this.SetValue(System.Windows.UIElement.RenderTransformOriginProperty, value);
                }
            },
            Clip: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.UIElement.ClipProperty), System.Windows.Media.Geometry);
                },
                set: function (value) {
                    this.SetValue(System.Windows.UIElement.ClipProperty, value);
                }
            },
            IsRootElement: {
                get: function () {
                    return this.isRootElement;
                },
                set: function (value) {
                    if (this.isRootElement === value) {
                        return;
                    }

                    this.isRootElement = value;
                    this.CoerceValue(System.Windows.UIElement.IsVisibleProperty);
                }
            },
            System$Windows$Media$Animation$IAnimatable$RootClock: {
                get: function () {
                    if (this.animatableRootClock == null) {
                        this.animatableRootClock = new System.Windows.Media.Animation.AnimatableRootClock(System.Windows.Media.Animation.RootClock.Default, this.IsVisible);
                    }

                    return this.animatableRootClock;
                }
            },
            PreviousAvailableSize: null,
            PreviousFinalRect: null
        },
        alias: [
            "RaiseEvent", "System$Windows$IInputElement$RaiseEvent",
            "SetAnimationClocks", "System$Windows$Media$Animation$IAnimatable$SetAnimationClocks",
            "AddAnimationClocks", "System$Windows$Media$Animation$IAnimatable$AddAnimationClocks",
            "RemoveAnimationClocks", "System$Windows$Media$Animation$IAnimatable$RemoveAnimationClocks"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Visual.ctor.call(this);
                this.logicalChildren = new (System.Collections.Generic.List$1(System.Object)).ctor();
                this.LogicalChildren = new (System.Collections.ObjectModel.ReadOnlyCollection$1(System.Object))(this.logicalChildren);
                this.routedEventHandlers = new (Granular.Collections.ListDictionary$2(System.Windows.RoutedEvent,System.Windows.RoutedEventHandlerItem))();
                this.routedEventHandlersCache = Granular.Collections.CacheDictionary$2(System.Windows.RoutedEvent,System.Collections.Generic.IEnumerable$1(System.Windows.RoutedEventHandlerItem)).CreateUsingStringKeys(Bridge.fn.cacheBind(this, this.ResolveRoutedEventHandlers), $asm.$.System.Windows.UIElement.f27);
                this.DesiredSize = System.Windows.Size.Zero;
                this.PreviousFinalRect = System.Windows.Rect.Empty;
                this.PreviousAvailableSize = System.Windows.Size.Infinity;
                this.previousDesiredSize = System.Windows.Size.Empty;

                this.VisualClipToBounds = this.ClipToBounds;
                this.VisualIsHitTestVisible = this.IsHitTestVisible;
                this.VisualIsVisible = this.IsVisible;
                this.VisualOpacity = this.Opacity;

                this.disableMeasureInvalidationToken = new Granular.Disposable(Bridge.fn.bind(this, $asm.$.System.Windows.UIElement.f28));
            }
        },
        methods: {
            addPreviewMouseMove: function (value) {
                this.AddHandler(System.Windows.Input.Mouse.PreviewMouseMoveEvent, value, false);
            },
            removePreviewMouseMove: function (value) {
                this.RemoveHandler(System.Windows.Input.Mouse.PreviewMouseMoveEvent, value);
            },
            addPreviewMouseDown: function (value) {
                this.AddHandler(System.Windows.Input.Mouse.PreviewMouseDownEvent, value, false);
            },
            removePreviewMouseDown: function (value) {
                this.RemoveHandler(System.Windows.Input.Mouse.PreviewMouseDownEvent, value);
            },
            addPreviewMouseUp: function (value) {
                this.AddHandler(System.Windows.Input.Mouse.PreviewMouseUpEvent, value, false);
            },
            removePreviewMouseUp: function (value) {
                this.RemoveHandler(System.Windows.Input.Mouse.PreviewMouseUpEvent, value);
            },
            addPreviewMouseWheel: function (value) {
                this.AddHandler(System.Windows.Input.Mouse.PreviewMouseWheelEvent, value, false);
            },
            removePreviewMouseWheel: function (value) {
                this.RemoveHandler(System.Windows.Input.Mouse.PreviewMouseWheelEvent, value);
            },
            addMouseMove: function (value) {
                this.AddHandler(System.Windows.Input.Mouse.MouseMoveEvent, value, false);
            },
            removeMouseMove: function (value) {
                this.RemoveHandler(System.Windows.Input.Mouse.MouseMoveEvent, value);
            },
            addMouseDown: function (value) {
                this.AddHandler(System.Windows.Input.Mouse.MouseDownEvent, value, false);
            },
            removeMouseDown: function (value) {
                this.RemoveHandler(System.Windows.Input.Mouse.MouseDownEvent, value);
            },
            addMouseUp: function (value) {
                this.AddHandler(System.Windows.Input.Mouse.MouseUpEvent, value, false);
            },
            removeMouseUp: function (value) {
                this.RemoveHandler(System.Windows.Input.Mouse.MouseUpEvent, value);
            },
            addMouseWheel: function (value) {
                this.AddHandler(System.Windows.Input.Mouse.MouseWheelEvent, value, false);
            },
            removeMouseWheel: function (value) {
                this.RemoveHandler(System.Windows.Input.Mouse.MouseWheelEvent, value);
            },
            addMouseEnter: function (value) {
                this.AddHandler(System.Windows.Input.Mouse.MouseEnterEvent, value, false);
            },
            removeMouseEnter: function (value) {
                this.RemoveHandler(System.Windows.Input.Mouse.MouseEnterEvent, value);
            },
            addMouseLeave: function (value) {
                this.AddHandler(System.Windows.Input.Mouse.MouseLeaveEvent, value, false);
            },
            removeMouseLeave: function (value) {
                this.RemoveHandler(System.Windows.Input.Mouse.MouseLeaveEvent, value);
            },
            addQueryCursor: function (value) {
                this.AddHandler(System.Windows.Input.Mouse.QueryCursorEvent, value, false);
            },
            removeQueryCursor: function (value) {
                this.RemoveHandler(System.Windows.Input.Mouse.QueryCursorEvent, value);
            },
            addPreviewKeyDown: function (value) {
                this.AddHandler(System.Windows.Input.Keyboard.PreviewKeyDownEvent, value, false);
            },
            removePreviewKeyDown: function (value) {
                this.RemoveHandler(System.Windows.Input.Keyboard.PreviewKeyDownEvent, value);
            },
            addPreviewKeyUp: function (value) {
                this.AddHandler(System.Windows.Input.Keyboard.PreviewKeyUpEvent, value, false);
            },
            removePreviewKeyUp: function (value) {
                this.RemoveHandler(System.Windows.Input.Keyboard.PreviewKeyUpEvent, value);
            },
            addPreviewGotKeyboardFocus: function (value) {
                this.AddHandler(System.Windows.Input.Keyboard.PreviewGotKeyboardFocusEvent, value, false);
            },
            removePreviewGotKeyboardFocus: function (value) {
                this.RemoveHandler(System.Windows.Input.Keyboard.PreviewGotKeyboardFocusEvent, value);
            },
            addPreviewLostKeyboardFocus: function (value) {
                this.AddHandler(System.Windows.Input.Keyboard.PreviewLostKeyboardFocusEvent, value, false);
            },
            removePreviewLostKeyboardFocus: function (value) {
                this.RemoveHandler(System.Windows.Input.Keyboard.PreviewLostKeyboardFocusEvent, value);
            },
            addKeyDown: function (value) {
                this.AddHandler(System.Windows.Input.Keyboard.KeyDownEvent, value, false);
            },
            removeKeyDown: function (value) {
                this.RemoveHandler(System.Windows.Input.Keyboard.KeyDownEvent, value);
            },
            addKeyUp: function (value) {
                this.AddHandler(System.Windows.Input.Keyboard.KeyUpEvent, value, false);
            },
            removeKeyUp: function (value) {
                this.RemoveHandler(System.Windows.Input.Keyboard.KeyUpEvent, value);
            },
            addGotKeyboardFocus: function (value) {
                this.AddHandler(System.Windows.Input.Keyboard.GotKeyboardFocusEvent, value, false);
            },
            removeGotKeyboardFocus: function (value) {
                this.RemoveHandler(System.Windows.Input.Keyboard.GotKeyboardFocusEvent, value);
            },
            addLostKeyboardFocus: function (value) {
                this.AddHandler(System.Windows.Input.Keyboard.LostKeyboardFocusEvent, value, false);
            },
            removeLostKeyboardFocus: function (value) {
                this.RemoveHandler(System.Windows.Input.Keyboard.LostKeyboardFocusEvent, value);
            },
            addGotFocus: function (value) {
                this.AddHandler(System.Windows.UIElement.GotFocusEvent, value);
            },
            removeGotFocus: function (value) {
                this.RemoveHandler(System.Windows.UIElement.GotFocusEvent, value);
            },
            addLostFocus: function (value) {
                this.AddHandler(System.Windows.UIElement.LostFocusEvent, value);
            },
            removeLostFocus: function (value) {
                this.RemoveHandler(System.Windows.UIElement.LostFocusEvent, value);
            },
            AddLogicalChild: function (child) {
                var childElement = Bridge.as(child, System.Windows.UIElement);

                if (childElement != null) {
                    if (Bridge.referenceEquals(childElement.LogicalParent, this)) {
                        return;
                    }

                    if (childElement.LogicalParent != null) {
                        childElement.LogicalParent.RemoveLogicalChild(childElement);
                    }

                    childElement.LogicalParent = this;
                }

                this.logicalChildren.add(child);
            },
            RemoveLogicalChild: function (child) {
                var childElement = Bridge.as(child, System.Windows.UIElement);

                if (childElement != null) {
                    if (!Bridge.referenceEquals(childElement.LogicalParent, this)) {
                        return;
                    }

                    childElement.LogicalParent = null;
                }

                this.logicalChildren.remove(child);
            },
            AddHandler: function (routedEvent, handler, handledEventsToo) {
                if (handledEventsToo === void 0) { handledEventsToo = false; }
                this.routedEventHandlers.add(routedEvent, new System.Windows.RoutedEventHandlerItem(handler, handledEventsToo));
                this.routedEventHandlersCache.Remove(routedEvent);
            },
            RemoveHandler: function (routedEvent, handler) {
                this.routedEventHandlers.remove(routedEvent, System.Linq.Enumerable.from(this.routedEventHandlers.getValues(routedEvent)).firstOrDefault(function (item) {
                        return Bridge.staticEquals(item.Handler, handler);
                    }, null));
                this.routedEventHandlersCache.Remove(routedEvent);
            },
            RaiseEvent: function (e) {
                var eventRoute = new System.Windows.EventRoute(e.RoutedEvent, this.GetEventRouteItems(e.RoutedEvent, this, this));
                e.Source = this;
                eventRoute.InvokeHandlers(e);
            },
            GetEventRouteItems: function (routedEvent, originalSource, logicalSource) {
                var items = System.Linq.Enumerable.from(this.GetRoutedEventHandlers(routedEvent)).select(Bridge.fn.bind(this, function (handler) {
                        return new System.Windows.EventRouteItem(handler, originalSource, logicalSource, this);
                    }));

                if (routedEvent.RoutingStrategy === System.Windows.RoutingStrategy.Bubble || routedEvent.RoutingStrategy === System.Windows.RoutingStrategy.Tunnel) {
                    var visualParent = Bridge.as(this.VisualParent, System.Windows.UIElement);

                    if (visualParent != null) {
                        var parentItems = visualParent.GetEventRouteItems(routedEvent, originalSource, !Bridge.referenceEquals(this.LogicalParent, visualParent) ? visualParent : logicalSource);

                        if (routedEvent.RoutingStrategy === System.Windows.RoutingStrategy.Bubble) {
                            items = System.Linq.Enumerable.from(items).concat(parentItems);
                        } else {
                            items = System.Linq.Enumerable.from(parentItems).concat(items);
                        }
                    }
                }

                return System.Linq.Enumerable.from(items).toArray();
            },
            GetRoutedEventHandlers: function (routedEvent) {
                return this.routedEventHandlersCache.GetValue(routedEvent);
            },
            ResolveRoutedEventHandlers: function (routedEvent) {
                return System.Linq.Enumerable.from(routedEvent.GetClassHandlers(Bridge.getType(this))).concat(this.GetRoutedEventHandlersOverride(routedEvent)).concat(this.routedEventHandlers.getValues(routedEvent)).toArray(System.Windows.RoutedEventHandlerItem);
            },
            GetRoutedEventHandlersOverride: function (routedEvent) {
                return System.Array.init(0, null, System.Windows.RoutedEventHandlerItem);
            },
            UpdateLayout: function () {
                System.Windows.LayoutManager.Current.UpdateLayout();
            },
            Measure: function (availableSize) {
                var $t, $t1;
                $t = System.Windows.Threading.Dispatcher.CurrentDispatcher.DisableProcessing();
                try {
                    $t1 = this.DisableMeasureInvalidation();
                    try {
                        if (this.Visibility === System.Windows.Visibility.Collapsed) {
                            this.DesiredSize = System.Windows.Size.Zero;
                        } else if (this.IsMeasureValid && System.Windows.SizeExtensions.IsClose(this.PreviousAvailableSize, availableSize)) {
                            this.DesiredSize = this.previousDesiredSize;
                        } else {
                            this.DesiredSize = this.MeasureCore(availableSize);

                            this.PreviousAvailableSize = availableSize;
                            this.previousDesiredSize = this.DesiredSize;
                        }

                        this.IsMeasureValid = true;
                        System.Windows.LayoutManager.Current.RemoveMeasure(this);
                    }
                    finally {
                        if (Bridge.hasValue($t1)) {
                            $t1.System$IDisposable$dispose();
                        }
                    }
                }
                finally {
                    if (Bridge.hasValue($t)) {
                        $t.System$IDisposable$dispose();
                    }
                }
            },
            MeasureCore: function (availableSize) {
                return System.Windows.Size.Empty;
            },
            InvalidateMeasure: function () {
                if (this.disableMeasureInvalidationRequests > 0 || !this.IsMeasureValid) {
                    return;
                }

                this.IsMeasureValid = false;
                System.Windows.LayoutManager.Current.AddMeasure(this);
            },
            InvalidateParentMeasure: function () {
                if (this.VisualParent != null) {
                    Bridge.cast(this.VisualParent, System.Windows.UIElement).InvalidateMeasure();
                }
            },
            Arrange: function (finalRect) {
                var $t, $t1;
                $t = System.Windows.Threading.Dispatcher.CurrentDispatcher.DisableProcessing();
                try {
                    $t1 = this.DisableMeasureInvalidation();
                    try {
                        if (this.Visibility !== System.Windows.Visibility.Visible || this.IsArrangeValid && System.Windows.RectExtensions.IsClose(finalRect, this.PreviousFinalRect)) {
                            System.Windows.LayoutManager.Current.RemoveArrange(this);
                            return;
                        }

                        if (!this.IsMeasureValid) {
                            this.Measure(finalRect.Size);
                        }

                        this.ArrangeCore(finalRect);

                        this.PreviousFinalRect = finalRect;

                        this.IsArrangeValid = true;
                        this.IsVisualValid = false;

                        this.Render();

                        System.Windows.LayoutManager.Current.RemoveArrange(this);
                        System.Windows.LayoutManager.Current.AddUpdatedElement(this);
                    }
                    finally {
                        if (Bridge.hasValue($t1)) {
                            $t1.System$IDisposable$dispose();
                        }
                    }
                }
                finally {
                    if (Bridge.hasValue($t)) {
                        $t.System$IDisposable$dispose();
                    }
                }
            },
            ArrangeCore: function (finalRect) {
                //
            },
            InvalidateArrange: function () {
                if (!this.IsArrangeValid) {
                    return;
                }

                this.IsArrangeValid = false;
                System.Windows.LayoutManager.Current.AddArrange(this);
            },
            InvalidateParentArrange: function () {
                if (this.VisualParent != null) {
                    Bridge.cast(this.VisualParent, System.Windows.UIElement).InvalidateArrange();
                }
            },
            DisableMeasureInvalidation: function () {
                this.disableMeasureInvalidationRequests = (this.disableMeasureInvalidationRequests + 1) | 0;
                return this.disableMeasureInvalidationToken;
            },
            RaiseLayoutUpdated: function () {
                this.OnLayoutUpdated();
                Granular.Extensions.EventHandlerExtensions.Raise$3(this.LayoutUpdated, this, { });
            },
            OnLayoutUpdated: function () {
                //
            },
            RenderAsync: function () {
                if (this.renderOperation != null && this.renderOperation.Status === System.Windows.Threading.DispatcherOperationStatus.Pending) {
                    return;
                }

                this.renderOperation = System.Windows.Threading.Dispatcher.CurrentDispatcher.InvokeAsync(Bridge.fn.cacheBind(this, this.Render), System.Windows.Threading.DispatcherPriority.Render);
            },
            Render: function () {
                if (this.IsVisualValid || !this.IsArrangeValid || this.drawingRenderElement == null) {
                    return;
                }

                var drawingContext = new System.Windows.Media.RenderElementDrawingContext(this.drawingRenderElement, this.renderElementFactory$1);

                this.OnRender(drawingContext);

                drawingContext.Close();

                this.IsVisualValid = true;
            },
            OnRender: function (drawingContext) {
                //
            },
            InvalidateVisual: function () {
                if (!this.IsVisualValid) {
                    return;
                }

                this.IsVisualValid = false;

                this.RenderAsync();
            },
            CreateRenderElementContentOverride: function (factory) {
                if (this.drawingRenderElement == null) {
                    this.renderElementFactory$1 = factory;
                    this.drawingRenderElement = factory.System$Windows$Media$IRenderElementFactory$CreateDrawingRenderElement(this);

                    this.RenderAsync();
                }

                return this.drawingRenderElement;
            },
            OnVisualParentChanged: function (oldVisualParent, newVisualParent) {
                this.CoerceValue(System.Windows.UIElement.IsVisibleProperty);
                this.CoerceValue(System.Windows.UIElement.IsEnabledProperty);
                this.CoerceValue(System.Windows.UIElement.IsHitTestVisibleProperty);

                this.SetInheritanceParent$1();

                if (oldVisualParent != null) {
                    Bridge.cast(oldVisualParent, System.Windows.UIElement).InvalidateMeasure();
                }

                if (newVisualParent != null) {
                    Bridge.cast(newVisualParent, System.Windows.UIElement).InvalidateMeasure();
                }
            },
            OnLogicalParentChanged: function (oldLogicalParent, newLogicalParent) {
                //
            },
            SetInheritanceParent$1: function () {
                this.SetInheritanceParent(this.LogicalParent || this.VisualParent);
            },
            SetAnimationClocks: function (dependencyProperty, animationClocks, layerOwner) {
                var animationExpression = this.GetInitializedAnimationExpression(dependencyProperty);
                animationExpression.SetClocks(animationClocks, layerOwner);
            },
            AddAnimationClocks: function (dependencyProperty, animationClocks, layerOwner) {
                var animationExpression = this.GetInitializedAnimationExpression(dependencyProperty);
                animationExpression.AddClocks(animationClocks, layerOwner);
            },
            RemoveAnimationClocks: function (dependencyProperty, animationClocks, layerOwner) {
                var animationExpression = this.GetInitializedAnimationExpression(dependencyProperty);
                animationExpression.RemoveClocks(animationClocks, layerOwner);
            },
            GetInitializedAnimationExpression: function (dependencyProperty) {
                var entry = this.GetValueEntry(dependencyProperty);
                var animationExpression = Bridge.as(System.Windows.DependencyPropertyValueEntryExtensions.GetAnimationValue(entry, false), System.Windows.Media.Animation.AnimationExpression);

                if (animationExpression == null) {
                    animationExpression = new System.Windows.Media.Animation.AnimationExpression(this, dependencyProperty);

                    System.Windows.DependencyPropertyValueEntryExtensions.SetAnimationValue(entry, animationExpression);
                }

                return animationExpression;
            },
            GetHitTestBoundsOverride: function () {
                if (!this.IsHitTestVisible || !this.IsVisible || !this.IsEnabled) {
                    return System.Windows.Rect.Empty;
                }

                return System.Windows.Media.Visual.prototype.GetHitTestBoundsOverride.call(this);
            },
            HitTest: function (position) {
                if (!System.Windows.RectExtensions.Contains(this.GetHitTestBounds(), position)) {
                    return null;
                }

                var relativePosition = System.Windows.Media.MatrixExtensions.IsNullOrIdentity(this.VisualTransform) ? System.Windows.Point.op_Subtraction(position, this.VisualOffset) : System.Windows.Media.Matrix.op_Multiply$1((System.Windows.Point.op_Subtraction(position, this.VisualOffset)), this.VisualTransform.Inverse);

                for (var i = (this.VisualChildren.Count - 1) | 0; i >= 0; i = (i - 1) | 0) {
                    var childHit = Bridge.cast(this.VisualChildren.getItem(i), System.Windows.UIElement).HitTest(relativePosition);

                    if (childHit != null) {
                        return childHit;
                    }
                }

                return this.HitTestOverride(relativePosition) ? this : null;
            },
            HitTestOverride: function (position) {
                return false;
            },
            Focus: function () {
                if (!this.IsFocused && this.Focusable) {
                    this.focus = Granular.Disposable.Combine(System.Windows.Input.Keyboard.Focus(this), System.Windows.Input.FocusManager.Focus(this));
                }
            },
            ClearFocus: function () {
                if (this.focus != null) {
                    this.focus.System$IDisposable$dispose();
                    this.focus = null;
                }
            },
            SetAnimatableRootClock: function (animatableRootClock) {
                if (this.animatableRootClock != null) {
                    throw new Granular.Exception("AnimatableRootClock was already initialized");
                }

                this.animatableRootClock = animatableRootClock;
            },
            ForceDefaultValueInheritance: function (e) {
                // clear modified value if it's equal to a default value that should be inherited
                if (Granular.Compatibility.EqualityComparer.Default.equals2(e.NewValue, e.Property.GetMetadata(Bridge.getType(this)).DefaultValue) && !this.GetValueSource(e.Property).IsExpression) {
                    this.ClearValue(e.Property);
                }
            },
            OnVisibilityChanged: function (e) {
                this.DesiredSize = this.Visibility === System.Windows.Visibility.Collapsed ? System.Windows.Size.Zero : this.previousDesiredSize;

                this.IsVisible = this.Visibility === System.Windows.Visibility.Visible;
            },
            OnIsVisibleChanged: function (e) {
                this.ClearFocus();

                if (this.animatableRootClock != null) {
                    // add or remove animation clocks from the global root clock
                    this.animatableRootClock.IsConnected = this.IsVisible;
                }

                this.VisualIsVisible = this.IsVisible;

                this.CoerceChildrenInheritedValue(System.Windows.UIElement.IsVisibleProperty);
                this.InvalidateHitTestBounds();
            },
            OnIsEnabledChanged: function (e) {
                this.ClearFocus();

                this.CoerceChildrenInheritedValue(System.Windows.UIElement.IsEnabledProperty);
                this.InvalidateHitTestBounds();
            },
            OnIsHitTestVisibleChanged: function (e) {
                this.VisualIsHitTestVisible = this.IsHitTestVisible;

                this.CoerceChildrenInheritedValue(System.Windows.UIElement.IsHitTestVisibleProperty);
                this.InvalidateHitTestBounds();
            },
            OnClipToBoundsChanged: function (e) {
                this.VisualClipToBounds = System.Nullable.getValue(Bridge.cast(Bridge.unbox(e.NewValue), System.Boolean));
            },
            CoerceIsVisible: function (value) {
                return value && (this.VisualParent != null ? Bridge.cast(this.VisualParent, System.Windows.UIElement).IsVisible : this.IsRootElement);
            },
            OnRenderTransformChanged: function (e) {
                this.InvalidateVisualTransform();
            },
            OnRenderTransformOriginChanged: function (e) {
                if (System.Windows.Media.TransformExtensions.IsNullOrIdentity(this.RenderTransform)) {
                    return;
                }

                this.InvalidateVisualTransform();
            },
            OnClipChanged: function (e) {
                this.VisualClip = Bridge.cast(e.NewValue, System.Windows.Media.Geometry);
            },
            OnVisualBoundsChanged: function () {
                if (System.Windows.Media.TransformExtensions.IsNullOrIdentity(this.RenderTransform)) {
                    return;
                }

                this.InvalidateVisualTransform();
            },
            GetVisualTransformOverride: function () {
                if (System.Windows.Media.TransformExtensions.IsNullOrIdentity(this.RenderTransform)) {
                    return System.Windows.Media.Matrix.Identity;
                }

                var offsetX = this.RenderTransformOrigin.X * this.RenderSize.Width;
                var offsetY = this.RenderTransformOrigin.Y * this.RenderSize.Height;

                return System.Windows.Media.Matrix.op_Multiply(System.Windows.Media.Matrix.op_Multiply(System.Windows.Media.Matrix.TranslationMatrix(-offsetX, -offsetY), this.RenderTransform.Value), System.Windows.Media.Matrix.TranslationMatrix(offsetX, offsetY));
            },
            CoerceInheritedValue: function (dependencyProperty, value) {
                return this.VisualParent != null ? value && System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.VisualParent.GetValue(dependencyProperty)), System.Boolean)) : value;
            },
            CoerceChildrenInheritedValue: function (dependencyProperty) {
                var $t;
                $t = Bridge.getEnumerator(this.VisualChildren);
                try {
                    while ($t.moveNext()) {
                        var child = $t.Current;
                        child.CoerceValue(dependencyProperty);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }},
            OnFocusableChanged: function (e) {
                this.ClearFocus();
            },
            System$Windows$IInputElement$GetPathFromRoot: function () {
                var path = new (System.Collections.Generic.List$1(System.Windows.IInputElement)).ctor();

                var element = this;

                while (element != null) {
                    path.add(Bridge.cast(element, System.Windows.IInputElement));
                    element = element.VisualParent;
                }

                path.reverse();

                return path;
            },
            System$Windows$IInputElement$GetRelativePosition: function (absolutePosition) {
                return this.PointFromRoot(absolutePosition);
            },
            OnMouseEnter: function (e) {
                //
            },
            OnMouseLeave: function (e) {
                //
            },
            OnQueryCursor: function (e) {
                //
            },
            OnPreviewMouseMove: function (e) {
                //
            },
            OnPreviewMouseDown: function (e) {
                //
            },
            OnPreviewMouseUp: function (e) {
                //
            },
            OnPreviewMouseWheel: function (e) {
                //
            },
            OnMouseMove: function (e) {
                //
            },
            OnMouseDown: function (e) {
                //
            },
            OnMouseUp: function (e) {
                //
            },
            OnMouseWheel: function (e) {
                //
            },
            OnGotKeyboardFocus: function (e) {
                //
            },
            OnLostKeyboardFocus: function (e) {
                //
            },
            OnPreviewKeyDown: function (e) {
                //
            },
            OnPreviewKeyUp: function (e) {
                //
            },
            OnKeyDown: function (e) {
                //
            },
            OnKeyUp: function (e) {
                //
            },
            OnGotFocus: function (e) {
                //
            },
            OnLostFocus: function (e) {
                //
            }
        }
    });

    Bridge.ns("System.Windows.UIElement", $asm.$);

    Bridge.apply($asm.$.System.Windows.UIElement, {
        f1: function (sender, e) {
            (Bridge.as(sender, System.Windows.UIElement)).VisualOpacity = System.Nullable.getValue(Bridge.cast(Bridge.unbox(e.NewValue), System.Double));
        },
        f2: function (sender, e) {
            Bridge.cast(sender, System.Windows.UIElement).OnVisibilityChanged(e);
        },
        f3: function (sender, e) {
            Bridge.cast(sender, System.Windows.UIElement).OnIsVisibleChanged(e);
        },
        f4: function (sender, value) {
            return Bridge.box(Bridge.cast(sender, System.Windows.UIElement).CoerceIsVisible(System.Nullable.getValue(Bridge.cast(Bridge.unbox(value), System.Boolean))), System.Boolean, System.Boolean.toString);
        },
        f5: function (sender, e) {
            Bridge.cast(sender, System.Windows.UIElement).OnIsEnabledChanged(e);
        },
        f6: function (sender, value) {
            return Bridge.box(Bridge.cast(sender, System.Windows.UIElement).CoerceInheritedValue(System.Windows.UIElement.IsEnabledProperty, System.Nullable.getValue(Bridge.cast(Bridge.unbox(value), System.Boolean))), System.Boolean, System.Boolean.toString);
        },
        f7: function (sender, e) {
            Bridge.cast(sender, System.Windows.UIElement).OnIsHitTestVisibleChanged(e);
        },
        f8: function (sender, value) {
            return Bridge.box(Bridge.cast(sender, System.Windows.UIElement).CoerceInheritedValue(System.Windows.UIElement.IsHitTestVisibleProperty, System.Nullable.getValue(Bridge.cast(Bridge.unbox(value), System.Boolean))), System.Boolean, System.Boolean.toString);
        },
        f9: function (sender, e) {
            Bridge.cast(sender, System.Windows.UIElement).OnClipToBoundsChanged(e);
        },
        f10: function (sender, e) {
            Bridge.cast(sender, System.Windows.UIElement).OnFocusableChanged(e);
        },
        f11: function (sender, e) {
            Bridge.cast(sender, System.Windows.UIElement).OnRenderTransformChanged(e);
        },
        f12: function (sender, e) {
            Bridge.cast(sender, System.Windows.UIElement).OnRenderTransformOriginChanged(e);
        },
        f13: function (sender, e) {
            Bridge.cast(sender, System.Windows.UIElement).OnClipChanged(e);
        },
        f14: function (sender, e) {
            Bridge.cast(sender, System.Windows.UIElement).OnQueryCursor(e);
        },
        f15: function (sender, e) {
            Bridge.cast(sender, System.Windows.UIElement).OnPreviewMouseMove(e);
        },
        f16: function (sender, e) {
            Bridge.cast(sender, System.Windows.UIElement).OnPreviewMouseDown(e);
        },
        f17: function (sender, e) {
            Bridge.cast(sender, System.Windows.UIElement).OnPreviewMouseUp(e);
        },
        f18: function (sender, e) {
            Bridge.cast(sender, System.Windows.UIElement).OnPreviewMouseWheel(e);
        },
        f19: function (sender, e) {
            Bridge.cast(sender, System.Windows.UIElement).OnMouseMove(e);
        },
        f20: function (sender, e) {
            Bridge.cast(sender, System.Windows.UIElement).OnMouseDown(e);
        },
        f21: function (sender, e) {
            Bridge.cast(sender, System.Windows.UIElement).OnMouseUp(e);
        },
        f22: function (sender, e) {
            Bridge.cast(sender, System.Windows.UIElement).OnMouseWheel(e);
        },
        f23: function (sender, e) {
            Bridge.cast(sender, System.Windows.UIElement).OnPreviewKeyDown(e);
        },
        f24: function (sender, e) {
            Bridge.cast(sender, System.Windows.UIElement).OnPreviewKeyUp(e);
        },
        f25: function (sender, e) {
            Bridge.cast(sender, System.Windows.UIElement).OnKeyDown(e);
        },
        f26: function (sender, e) {
            Bridge.cast(sender, System.Windows.UIElement).OnKeyUp(e);
        },
        f27: function (routedEvent) {
            return routedEvent.StringKey;
        },
        f28: function () {
            Bridge.identity(this.disableMeasureInvalidationRequests, (this.disableMeasureInvalidationRequests = (this.disableMeasureInvalidationRequests - 1) | 0));
        }
    });

    Bridge.define("System.Windows.Controls.ColumnDefinition", {
        inherits: [System.Windows.Freezable,System.Windows.Controls.IDefinitionBase],
        statics: {
            fields: {
                WidthProperty: null,
                MinWidthProperty: null,
                MaxWidthProperty: null,
                ActualWidthPropertyKey: null,
                ActualWidthProperty: null
            },
            ctors: {
                init: function () {
                    this.WidthProperty = System.Windows.DependencyProperty.Register("Width", System.Windows.GridLength, System.Windows.Controls.ColumnDefinition, new System.Windows.FrameworkPropertyMetadata.$ctor1(System.Windows.GridLength.Star));
                    this.MinWidthProperty = System.Windows.DependencyProperty.Register("MinWidth", System.Double, System.Windows.Controls.ColumnDefinition, new System.Windows.FrameworkPropertyMetadata.$ctor8(0.0));
                    this.MaxWidthProperty = System.Windows.DependencyProperty.Register("MaxWidth", System.Double, System.Windows.Controls.ColumnDefinition, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(Number.POSITIVE_INFINITY, System.Double, System.Double.format, System.Double.getHashCode)));
                    this.ActualWidthPropertyKey = System.Windows.DependencyProperty.RegisterReadOnly("ActualWidth", System.Double, System.Windows.Controls.ColumnDefinition, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.ActualWidthProperty = System.Windows.Controls.ColumnDefinition.ActualWidthPropertyKey.DependencyProperty;
                }
            }
        },
        fields: {
            actualWidthValueEntry: null
        },
        props: {
            Width: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.ColumnDefinition.WidthProperty), System.Windows.GridLength);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.ColumnDefinition.WidthProperty, value);
                }
            },
            MinWidth: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.ColumnDefinition.MinWidthProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.ColumnDefinition.MinWidthProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            MaxWidth: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.ColumnDefinition.MaxWidthProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.ColumnDefinition.MaxWidthProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            ActualWidth: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.actualWidthValueEntry.System$Windows$IDependencyPropertyValueEntry$Value), System.Double));
                },
                set: function (value) {
                    System.Windows.DependencyPropertyValueEntryExtensions.SetBaseValue(this.actualWidthValueEntry, System.Windows.BaseValueSource.Local, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            System$Windows$Controls$IDefinitionBase$ActualLength: {
                get: function () {
                    return this.ActualWidth;
                },
                set: function (value) {
                    this.ActualWidth = value;
                }
            },
            System$Windows$Controls$IDefinitionBase$MinLength: {
                get: function () {
                    return this.MinWidth;
                }
            },
            System$Windows$Controls$IDefinitionBase$MaxLength: {
                get: function () {
                    return this.MaxWidth;
                }
            },
            System$Windows$Controls$IDefinitionBase$Length: {
                get: function () {
                    return this.Width;
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Freezable.ctor.call(this);
                this.actualWidthValueEntry = this.GetValueEntry$1(System.Windows.Controls.ColumnDefinition.ActualWidthPropertyKey);
            }
        }
    });

    Bridge.define("System.Windows.Controls.ControlTemplate", {
        inherits: [System.Windows.FrameworkTemplate],
        fields: {
            targetType: null
        },
        props: {
            TargetType: {
                get: function () {
                    return this.targetType;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.targetType, value)) {
                        return;
                    }

                    this.targetType = value;
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.FrameworkTemplate.ctor.call(this);
                //
            }
        }
    });

    Bridge.define("System.Windows.Controls.ItemsPanelTemplate", {
        inherits: [System.Windows.FrameworkTemplate]
    });

    Bridge.define("System.Windows.Controls.RowDefinition", {
        inherits: [System.Windows.Freezable,System.Windows.Controls.IDefinitionBase],
        statics: {
            fields: {
                HeightProperty: null,
                MinHeightProperty: null,
                MaxHeightProperty: null,
                ActualHeightPropertyKey: null,
                ActualHeightProperty: null
            },
            ctors: {
                init: function () {
                    this.HeightProperty = System.Windows.DependencyProperty.Register("Height", System.Windows.GridLength, System.Windows.Controls.RowDefinition, new System.Windows.FrameworkPropertyMetadata.$ctor1(System.Windows.GridLength.Star));
                    this.MinHeightProperty = System.Windows.DependencyProperty.Register("MinHeight", System.Double, System.Windows.Controls.RowDefinition, new System.Windows.FrameworkPropertyMetadata.$ctor8(0.0));
                    this.MaxHeightProperty = System.Windows.DependencyProperty.Register("MaxHeight", System.Double, System.Windows.Controls.RowDefinition, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(Number.POSITIVE_INFINITY, System.Double, System.Double.format, System.Double.getHashCode)));
                    this.ActualHeightPropertyKey = System.Windows.DependencyProperty.RegisterReadOnly("ActualHeight", System.Double, System.Windows.Controls.RowDefinition, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.ActualHeightProperty = System.Windows.Controls.RowDefinition.ActualHeightPropertyKey.DependencyProperty;
                }
            }
        },
        fields: {
            actualHeightValueEntry: null
        },
        props: {
            Height: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.RowDefinition.HeightProperty), System.Windows.GridLength);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.RowDefinition.HeightProperty, value);
                }
            },
            MinHeight: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.RowDefinition.MinHeightProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.RowDefinition.MinHeightProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            MaxHeight: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.RowDefinition.MaxHeightProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.RowDefinition.MaxHeightProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            ActualHeight: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.actualHeightValueEntry.System$Windows$IDependencyPropertyValueEntry$Value), System.Double));
                },
                set: function (value) {
                    System.Windows.DependencyPropertyValueEntryExtensions.SetBaseValue(this.actualHeightValueEntry, System.Windows.BaseValueSource.Local, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            System$Windows$Controls$IDefinitionBase$ActualLength: {
                get: function () {
                    return this.ActualHeight;
                },
                set: function (value) {
                    this.ActualHeight = value;
                }
            },
            System$Windows$Controls$IDefinitionBase$MinLength: {
                get: function () {
                    return this.MinHeight;
                }
            },
            System$Windows$Controls$IDefinitionBase$MaxLength: {
                get: function () {
                    return this.MaxHeight;
                }
            },
            System$Windows$Controls$IDefinitionBase$Length: {
                get: function () {
                    return this.Height;
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Freezable.ctor.call(this);
                this.actualHeightValueEntry = this.GetValueEntry$1(System.Windows.Controls.RowDefinition.ActualHeightPropertyKey);
            }
        }
    });

    Bridge.define("System.Windows.Data.BindingExpression", {
        inherits: [System.Windows.IExpression,System.IDisposable],
        statics: {
            fields: {
                DisconnectedItem: null
            },
            ctors: {
                init: function () {
                    this.DisconnectedItem = new System.Windows.Data.NamedObject("BindingExpression.DisconnectedItem");
                }
            },
            methods: {
                CreateSourceObserver: function (target, source, relativeSource, elementName) {
                    if (source != null) {
                        return new System.Windows.Data.StaticObservableValue(source);
                    }

                    if (relativeSource != null) {
                        return relativeSource.CreateSourceObserver(target);
                    }

                    if (!Granular.Extensions.StringExtensions.IsNullOrEmpty(elementName)) {
                        return new System.Windows.Data.ScopeElementSourceObserver(target, elementName);
                    }

                    return new System.Windows.Data.DataContextSourceObserver(target);
                },
                GetDefaultBindingMode: function (dependencyObject, dependencyProperty) {
                    var FrameworkPropertyMetadata = Bridge.as(dependencyProperty.GetMetadata(Bridge.getType(dependencyObject)), System.Windows.FrameworkPropertyMetadata);
                    return FrameworkPropertyMetadata != null && FrameworkPropertyMetadata.BindsTwoWayByDefault ? System.Windows.Data.BindingMode.TwoWay : System.Windows.Data.BindingMode.OneWay;
                }
            }
        },
        fields: {
            sourceObserver: null,
            sourceExpression: null,
            targetValue: null,
            isSourceUpdateMode: false,
            isTargetUpdateMode: false,
            disableSourceUpdate: null,
            disableTargetUpdate: null
        },
        events: {
            ValueChanged: null
        },
        props: {
            Value: {
                get: function () {
                    return this.targetValue.Value;
                }
            },
            Target: null,
            TargetProperty: null,
            Path: null,
            Source: null,
            RelativeSource: null,
            ElementName: null,
            Mode: 0,
            UpdateSourceTrigger: 0,
            Converter: null,
            ConverterParameter: null,
            FallbackValue: null,
            TargetNullValue: null,
            Status: 0
        },
        alias: [
            "addValueChanged", "System$Windows$Data$IObservableValue$addValueChanged",
            "removeValueChanged", "System$Windows$Data$IObservableValue$removeValueChanged",
            "Value", "System$Windows$Data$IObservableValue$Value",
            "dispose", "System$IDisposable$dispose",
            "SetValue", "System$Windows$IExpression$SetValue"
        ],
        ctors: {
            ctor: function (target, targetProperty, path, source, relativeSource, elementName, mode, updateSourceTrigger, converter, converterParameter, fallbackValue, targetNullValue) {
                if (source === void 0) { source = null; }
                if (relativeSource === void 0) { relativeSource = null; }
                if (elementName === void 0) { elementName = null; }
                if (mode === void 0) { mode = 3; }
                if (updateSourceTrigger === void 0) { updateSourceTrigger = 0; }
                if (converter === void 0) { converter = null; }
                if (converterParameter === void 0) { converterParameter = null; }
                if (fallbackValue === void 0) { fallbackValue = null; }
                if (targetNullValue === void 0) { targetNullValue = null; }

                this.$initialize();
                this.Target = target;
                this.TargetProperty = targetProperty;
                this.Path = path;
                this.Source = source;
                this.RelativeSource = relativeSource;
                this.ElementName = elementName;
                this.Mode = mode;
                this.UpdateSourceTrigger = updateSourceTrigger;
                this.Converter = converter;
                this.ConverterParameter = converterParameter;
                this.FallbackValue = fallbackValue;
                this.TargetNullValue = targetNullValue;

                this.Status = System.Windows.Data.BindingStatus.Inactive;

                this.disableSourceUpdate = new Granular.ReentrancyLock();
                this.disableTargetUpdate = new Granular.ReentrancyLock();

                this.targetValue = new System.Windows.Data.ObservableValue.$ctor1(this.Target.GetValue(this.TargetProperty));
                this.targetValue.addValueChanged(Bridge.fn.cacheBind(this, this.OnTargetValueChanged));

                var resolvedBindingMode = this.Mode === System.Windows.Data.BindingMode.Default ? System.Windows.Data.BindingExpression.GetDefaultBindingMode(this.Target, this.TargetProperty) : this.Mode;

                this.isSourceUpdateMode = resolvedBindingMode === System.Windows.Data.BindingMode.TwoWay || resolvedBindingMode === System.Windows.Data.BindingMode.OneWayToSource;
                this.isTargetUpdateMode = resolvedBindingMode === System.Windows.Data.BindingMode.TwoWay || resolvedBindingMode === System.Windows.Data.BindingMode.OneWay;

                this.sourceObserver = System.Windows.Data.BindingExpression.CreateSourceObserver(this.Target, this.Source, this.RelativeSource, this.ElementName);
                this.sourceExpression = new System.Windows.Data.ObservableExpression.$ctor1(this.sourceObserver, this.Path || System.Windows.PropertyPath.Empty);

                // try to update the target (or the source on OneWayToSource)
                if (this.isTargetUpdateMode) {
                    this.sourceExpression.addValueChanged(Bridge.fn.bind(this, $asm.$.System.Windows.Data.BindingExpression.f1));
                    this.UpdateTargetOnSourceChanged();
                } else if (this.isSourceUpdateMode) {
                    this.sourceExpression.addValueChanged(Bridge.fn.bind(this, $asm.$.System.Windows.Data.BindingExpression.f2));

                    this.UpdateSourceOnTargetChanged();
                }

                if (this.UpdateSourceTrigger === System.Windows.Data.UpdateSourceTrigger.LostFocus && this.isSourceUpdateMode && Bridge.is(this.Target, System.Windows.UIElement)) {
                    Bridge.cast(this.Target, System.Windows.UIElement).addLostFocus(Bridge.fn.cacheBind(this, this.OnLostFocus));
                }
            }
        },
        methods: {
            dispose: function () {
                this.sourceExpression.dispose();

                if (Bridge.is(this.sourceObserver, System.IDisposable)) {
                    Bridge.cast(this.sourceObserver, System.IDisposable).System$IDisposable$dispose();
                }

                if (this.UpdateSourceTrigger === System.Windows.Data.UpdateSourceTrigger.LostFocus && this.isSourceUpdateMode && Bridge.is(this.Target, System.Windows.UIElement)) {
                    Bridge.cast(this.Target, System.Windows.UIElement).removeLostFocus(Bridge.fn.cacheBind(this, this.OnLostFocus));
                }

                this.Target = null;
                this.TargetProperty = null;

                this.Status = System.Windows.Data.BindingStatus.Detached;
            },
            SetValue: function (value) {
                this.targetValue.BaseValue = value;
                return true;
            },
            UpdateTargetOnSourceChanged: function () {
                var $t;
                if (Granular.ReentrancyLock.op_Implicit(this.disableTargetUpdate)) {
                    return;
                }

                $t = this.disableSourceUpdate.Enter();
                try {
                    this.UpdateTarget();
                }
                finally {
                    if (Bridge.hasValue($t)) {
                        $t.System$IDisposable$dispose();
                    }
                }
            },
            UpdateTarget: function () {
                var value = this.sourceExpression != null ? this.sourceExpression.Value : System.Windows.Data.ObservableValue.UnsetValue;

                if (Bridge.referenceEquals(value, System.Windows.Data.ObservableValue.UnsetValue) && this.FallbackValue != null) {
                    value = this.FallbackValue;
                } else if (value == null && this.TargetNullValue != null) {
                    value = this.TargetNullValue;
                } else if (!Bridge.referenceEquals(value, System.Windows.Data.ObservableValue.UnsetValue) && this.Converter != null) {
                    value = this.Converter.System$Windows$Data$IValueConverter$Convert(value, this.TargetProperty.PropertyType, this.ConverterParameter);
                }

                this.targetValue.BaseValue = value;

                this.Status = !Bridge.referenceEquals(value, System.Windows.Data.ObservableValue.UnsetValue) ? System.Windows.Data.BindingStatus.Active : System.Windows.Data.BindingStatus.UpdateTargetError;
            },
            UpdateSourceOnTargetChanged: function () {
                var $t;
                if (Granular.ReentrancyLock.op_Implicit(this.disableSourceUpdate)) {
                    return;
                }

                $t = this.disableTargetUpdate.Enter();
                try {
                    this.UpdateSource();
                }
                finally {
                    if (Bridge.hasValue($t)) {
                        $t.System$IDisposable$dispose();
                    }
                }
            },
            UpdateSource: function () {
                var convertedValue = this.Converter != null ? this.Converter.System$Windows$Data$IValueConverter$ConvertBack(this.targetValue.Value, this.sourceExpression.ValueType, this.ConverterParameter) : this.targetValue.Value;

                if (this.sourceExpression.TrySetValue(convertedValue)) {
                    this.Status = System.Windows.Data.BindingStatus.Active;
                } else {
                    this.Status = System.Windows.Data.BindingStatus.UpdateSourceError;
                }
            },
            OnTargetValueChanged: function (sender, oldValue, newValue) {
                if (this.UpdateSourceTrigger === System.Windows.Data.UpdateSourceTrigger.Default && this.isSourceUpdateMode) {
                    this.UpdateSourceOnTargetChanged();
                }

                System.Windows.Data.ObservableValueChangedEventHandlerExtensions.Raise(this.ValueChanged, this, oldValue, newValue);
            },
            OnLostFocus: function (sender, e) {
                this.UpdateSourceOnTargetChanged();
            }
        }
    });

    Bridge.ns("System.Windows.Data.BindingExpression", $asm.$);

    Bridge.apply($asm.$.System.Windows.Data.BindingExpression, {
        f1: function (sender, oldValue, newValue) {
            this.UpdateTargetOnSourceChanged();
        },
        f2: function (sender, oldValue, newValue) {
            if (this.Status === System.Windows.Data.BindingStatus.UpdateSourceError && !Bridge.referenceEquals(this.sourceExpression.Value, System.Windows.Data.ObservableValue.UnsetValue) && !Granular.ReentrancyLock.op_Implicit(this.disableTargetUpdate)) {
                // source was connected
                this.UpdateSourceOnTargetChanged();
            }
        }
    });

    Bridge.define("System.Windows.Data.ClrPropertyObserver", {
        inherits: [System.Windows.Data.IPropertyObserver,System.IDisposable],
        fields: {
            observableValue: null,
            propertyInfo: null,
            propertyGetMethod: null,
            propertySetMethod: null,
            index: null,
            currentPropertyNotifier: null,
            currentCollectionNotifier: null,
            baseValue: null
        },
        events: {
            ValueChanged: null
        },
        props: {
            Value: {
                get: function () {
                    return this.observableValue.Value;
                }
            },
            ValueType: {
                get: function () {
                    return this.propertyInfo.rt;
                }
            }
        },
        alias: [
            "addValueChanged", "System$Windows$Data$IObservableValue$addValueChanged",
            "removeValueChanged", "System$Windows$Data$IObservableValue$removeValueChanged",
            "Value", "System$Windows$Data$IObservableValue$Value",
            "ValueType", "System$Windows$Data$IPropertyObserver$ValueType",
            "SetBaseValue", "System$Windows$Data$IPropertyObserver$SetBaseValue",
            "TrySetValue", "System$Windows$Data$IPropertyObserver$TrySetValue",
            "dispose", "System$IDisposable$dispose"
        ],
        ctors: {
            ctor: function (propertyInfo, index) {
                this.$initialize();
                this.propertyInfo = propertyInfo;
                this.propertyGetMethod = System.Reflection.PropertyInfoExtensions.GetGetMethod(propertyInfo);
                this.propertySetMethod = System.Reflection.PropertyInfoExtensions.GetSetMethod(propertyInfo);
                this.index = index;

                this.observableValue = new System.Windows.Data.ObservableValue.ctor();
                this.observableValue.addValueChanged(Bridge.fn.bind(this, $asm.$.System.Windows.Data.ClrPropertyObserver.f1));
            }
        },
        methods: {
            SetBaseValue: function (baseValue) {
                this.baseValue = baseValue;
                this.RegisterNotifiers();
                this.observableValue.BaseValue = this.GetValue();
            },
            TrySetValue: function (value) {
                if (System.Windows.Data.ObservableValue.IsNullOrUnset(this.baseValue) || this.propertySetMethod == null) {
                    return false;
                }

                Bridge.Reflection.midel(this.propertySetMethod, Bridge.unbox(this.baseValue)).apply(null, Bridge.unbox(System.Linq.Enumerable.from(this.index).concat(System.Array.init([value], System.Object)).toArray(System.Object)));
                this.observableValue.BaseValue = this.GetValue();
                return true;
            },
            GetValue: function () {
                if (System.Windows.Data.ObservableValue.IsNullOrUnset(this.baseValue) || this.propertyGetMethod == null) {
                    return System.Windows.Data.ObservableValue.UnsetValue;
                }

                return Bridge.Reflection.midel(this.propertyGetMethod, Bridge.unbox(this.baseValue)).apply(null, Bridge.unbox(System.Linq.Enumerable.from(this.index).toArray()));
            },
            RegisterNotifiers: function () {
                if (this.currentPropertyNotifier != null) {
                    this.currentPropertyNotifier.System$ComponentModel$INotifyPropertyChanged$removePropertyChanged(Bridge.fn.cacheBind(this, this.OnNotifierPropertyChanged));
                }

                if (this.currentCollectionNotifier != null) {
                    this.currentCollectionNotifier.Granular$Collections$INotifyCollectionChanged$removeCollectionChanged(Bridge.fn.cacheBind(this, this.OnNotifierCollectionChanged));
                }

                this.currentPropertyNotifier = Bridge.as(this.baseValue, System.ComponentModel.INotifyPropertyChanged);

                if (System.Linq.Enumerable.from(this.index).any()) {
                    this.currentCollectionNotifier = Bridge.as(this.baseValue, Granular.Collections.INotifyCollectionChanged);
                }

                if (this.currentPropertyNotifier != null) {
                    this.currentPropertyNotifier.System$ComponentModel$INotifyPropertyChanged$addPropertyChanged(Bridge.fn.cacheBind(this, this.OnNotifierPropertyChanged));
                }

                if (this.currentCollectionNotifier != null) {
                    this.currentCollectionNotifier.Granular$Collections$INotifyCollectionChanged$addCollectionChanged(Bridge.fn.cacheBind(this, this.OnNotifierCollectionChanged));
                }
            },
            OnNotifierPropertyChanged: function (sender, e) {
                if (Bridge.referenceEquals(e.propertyName, this.propertyInfo.n)) {
                    this.observableValue.BaseValue = this.GetValue();
                }
            },
            OnNotifierCollectionChanged: function (sender, e) {
                this.observableValue.BaseValue = this.GetValue();
            },
            dispose: function () {
                if (this.currentPropertyNotifier != null) {
                    this.currentPropertyNotifier.System$ComponentModel$INotifyPropertyChanged$removePropertyChanged(Bridge.fn.cacheBind(this, this.OnNotifierPropertyChanged));
                }
            }
        }
    });

    Bridge.ns("System.Windows.Data.ClrPropertyObserver", $asm.$);

    Bridge.apply($asm.$.System.Windows.Data.ClrPropertyObserver, {
        f1: function (sender, oldValue, newValue) {
            System.Windows.Data.ObservableValueChangedEventHandlerExtensions.Raise(this.ValueChanged, this, oldValue, newValue);
        }
    });

    Bridge.define("System.Windows.Data.DependencyPropertyObserver", {
        inherits: [System.Windows.Data.IPropertyObserver,System.IDisposable],
        fields: {
            observableValue: null,
            dependencyProperty: null,
            currentDependencyObject: null,
            baseValue: null
        },
        events: {
            ValueChanged: null
        },
        props: {
            Value: {
                get: function () {
                    return this.observableValue.Value;
                }
            },
            ValueType: {
                get: function () {
                    return this.dependencyProperty.PropertyType;
                }
            }
        },
        alias: [
            "addValueChanged", "System$Windows$Data$IObservableValue$addValueChanged",
            "removeValueChanged", "System$Windows$Data$IObservableValue$removeValueChanged",
            "Value", "System$Windows$Data$IObservableValue$Value",
            "ValueType", "System$Windows$Data$IPropertyObserver$ValueType",
            "SetBaseValue", "System$Windows$Data$IPropertyObserver$SetBaseValue",
            "TrySetValue", "System$Windows$Data$IPropertyObserver$TrySetValue",
            "dispose", "System$IDisposable$dispose"
        ],
        ctors: {
            ctor: function (dependencyProperty) {
                this.$initialize();
                this.dependencyProperty = dependencyProperty;

                this.observableValue = new System.Windows.Data.ObservableValue.ctor();
                this.observableValue.addValueChanged(Bridge.fn.bind(this, $asm.$.System.Windows.Data.DependencyPropertyObserver.f1));
            }
        },
        methods: {
            SetBaseValue: function (baseValue) {
                this.baseValue = baseValue;
                this.RegisterDependencyObject();
                this.observableValue.BaseValue = this.GetValue();
            },
            TrySetValue: function (value) {
                var dependencyObject = Bridge.as(this.baseValue, System.Windows.DependencyObject);

                if (dependencyObject == null || this.dependencyProperty.IsReadOnly) {
                    return false;
                }

                dependencyObject.SetValue(this.dependencyProperty, value);
                this.observableValue.BaseValue = this.GetValue();
                return true;
            },
            GetValue: function () {
                var dependencyObject = Bridge.as(this.baseValue, System.Windows.DependencyObject);
                return dependencyObject != null ? dependencyObject.GetValue(this.dependencyProperty) : System.Windows.Data.ObservableValue.UnsetValue;
            },
            RegisterDependencyObject: function () {
                if (this.currentDependencyObject != null) {
                    this.currentDependencyObject.removePropertyChanged(Bridge.fn.cacheBind(this, this.OnDependencyObjectPropertyChanged));
                }

                this.currentDependencyObject = Bridge.as(this.baseValue, System.Windows.DependencyObject);

                if (this.currentDependencyObject != null) {
                    this.currentDependencyObject.addPropertyChanged(Bridge.fn.cacheBind(this, this.OnDependencyObjectPropertyChanged));
                }
            },
            OnDependencyObjectPropertyChanged: function (sender, e) {
                if (Bridge.referenceEquals(e.Property, this.dependencyProperty)) {
                    this.observableValue.BaseValue = this.GetValue();
                }
            },
            dispose: function () {
                if (this.currentDependencyObject != null) {
                    this.currentDependencyObject.removePropertyChanged(Bridge.fn.cacheBind(this, this.OnDependencyObjectPropertyChanged));
                }
            }
        }
    });

    Bridge.ns("System.Windows.Data.DependencyPropertyObserver", $asm.$);

    Bridge.apply($asm.$.System.Windows.Data.DependencyPropertyObserver, {
        f1: function (sender, oldValue, newValue) {
            System.Windows.Data.ObservableValueChangedEventHandlerExtensions.Raise(this.ValueChanged, this, oldValue, newValue);
        }
    });

    Bridge.define("System.Windows.Data.FindAncestorSourceObserver", {
        inherits: [System.Windows.Data.ContextSourceObserver],
        statics: {
            methods: {
                GetAncestor: function (target, ancestorType, ancestorLevel) {
                    var $t;
                    if (!(Bridge.is(target, System.Windows.IContextElement))) {
                        return System.Windows.Data.ObservableValue.UnsetValue;
                    }

                    var contextElement = Bridge.cast(target, System.Windows.IContextElement).System$Windows$IContextElement$ContextParent;
                    var level = (ancestorLevel - 1) | 0;

                    while (contextElement != null && (level > 0 || ancestorType != null && !Bridge.Reflection.isInstanceOfType(contextElement, ancestorType))) {
                        if (ancestorType == null || Bridge.Reflection.isInstanceOfType(contextElement, ancestorType)) {
                            level = (level - 1) | 0;
                        }

                        contextElement = contextElement.System$Windows$IContextElement$ContextParent;
                    }

                    return ($t = contextElement, $t != null ? $t : System.Windows.Data.ObservableValue.UnsetValue);
                }
            }
        },
        fields: {
            target$1: null,
            ancestorType: null,
            ancestorLevel: 0
        },
        ctors: {
            ctor: function (target, ancestorType, ancestorLevel) {
                this.$initialize();
                System.Windows.Data.ContextSourceObserver.ctor.call(this, target, System.Windows.Data.FindAncestorSourceObserver.GetAncestor(target, ancestorType, ancestorLevel));
                this.target$1 = target;
                this.ancestorType = ancestorType;
                this.ancestorLevel = ancestorLevel;
            }
        },
        methods: {
            GetBaseValue: function () {
                return System.Windows.Data.FindAncestorSourceObserver.GetAncestor(this.target$1, this.ancestorType, this.ancestorLevel);
            }
        }
    });

    Bridge.define("System.Windows.Data.IndexPropertyObserver", {
        inherits: [System.Windows.Data.IPropertyObserver,System.IDisposable],
        statics: {
            methods: {
                CreateBaseObserver: function (containingType, propertyName) {
                    if (propertyName.IsEmpty) {
                        return null;
                    }

                    containingType = System.Windows.Markup.XamlNameExtensions.ResolveContainingType(propertyName, containingType);

                    var dependencyProperty = System.Windows.DependencyProperty.GetProperty(containingType, propertyName.MemberName);
                    if (dependencyProperty != null) {
                        return new System.Windows.Data.DependencyPropertyObserver(dependencyProperty);
                    }

                    var propertyInfo = Granular.Extensions.TypeExtensions.GetInstanceProperty(containingType, propertyName.MemberName);
                    if (propertyInfo != null && !System.Linq.Enumerable.from((propertyInfo.ipi || [])).any()) {
                        return new System.Windows.Data.ClrPropertyObserver(propertyInfo, System.Array.init(0, null, System.Object));
                    }

                    return null;
                }
            }
        },
        fields: {
            baseObserver: null,
            indexerObserver: null
        },
        events: {
            ValueChanged: null
        },
        props: {
            Value: {
                get: function () {
                    return this.indexerObserver.System$Windows$Data$IObservableValue$Value;
                }
            },
            ValueType: {
                get: function () {
                    return this.indexerObserver.System$Windows$Data$IPropertyObserver$ValueType;
                }
            }
        },
        alias: [
            "addValueChanged", "System$Windows$Data$IObservableValue$addValueChanged",
            "removeValueChanged", "System$Windows$Data$IObservableValue$removeValueChanged",
            "Value", "System$Windows$Data$IObservableValue$Value",
            "ValueType", "System$Windows$Data$IPropertyObserver$ValueType",
            "dispose", "System$IDisposable$dispose",
            "TrySetValue", "System$Windows$Data$IPropertyObserver$TrySetValue",
            "SetBaseValue", "System$Windows$Data$IPropertyObserver$SetBaseValue"
        ],
        ctors: {
            ctor: function (propertyContainingType, propertyPathElement, namespaces) {
                this.$initialize();
                this.baseObserver = System.Windows.Data.IndexPropertyObserver.CreateBaseObserver(propertyContainingType, propertyPathElement.PropertyName);

                var indexPropertyInfo = this.baseObserver != null ? Granular.Extensions.TypeExtensions.GetDefaultIndexProperty(this.baseObserver.System$Windows$Data$IPropertyObserver$ValueType) : propertyPathElement.PropertyName.IsEmpty ? Granular.Extensions.TypeExtensions.GetDefaultIndexProperty(propertyContainingType) : Granular.Extensions.TypeExtensions.GetInstanceProperty(propertyContainingType, propertyPathElement.PropertyName.MemberName);

                if (indexPropertyInfo == null) {
                    throw new Granular.Exception("Property \"{0}.{1}\" does not have an indexer", [Bridge.Reflection.getTypeName(propertyContainingType), propertyPathElement.PropertyName.MemberName]);
                }

                if (System.Linq.Enumerable.from((indexPropertyInfo.ipi || [])).count() !== System.Linq.Enumerable.from(propertyPathElement.IndexRawValues).count()) {
                    throw new Granular.Exception("Invalid number of index parameters for \"{0}.{1}\"", [Bridge.Reflection.getTypeName(indexPropertyInfo.td), indexPropertyInfo.n]);
                }

                this.indexerObserver = new System.Windows.Data.ClrPropertyObserver(indexPropertyInfo, propertyPathElement.ParseIndexValues(indexPropertyInfo));
                this.indexerObserver.System$Windows$Data$IObservableValue$addValueChanged(Bridge.fn.bind(this, $asm.$.System.Windows.Data.IndexPropertyObserver.f1));

                if (this.baseObserver != null) {
                    this.baseObserver.System$Windows$Data$IObservableValue$addValueChanged(Bridge.fn.bind(this, $asm.$.System.Windows.Data.IndexPropertyObserver.f2));
                    this.indexerObserver.System$Windows$Data$IPropertyObserver$SetBaseValue(this.baseObserver.System$Windows$Data$IObservableValue$Value);
                }
            }
        },
        methods: {
            dispose: function () {
                if (Bridge.is(this.baseObserver, System.IDisposable)) {
                    Bridge.cast(this.baseObserver, System.IDisposable).System$IDisposable$dispose();
                }

                if (Bridge.is(this.indexerObserver, System.IDisposable)) {
                    Bridge.cast(this.indexerObserver, System.IDisposable).System$IDisposable$dispose();
                }
            },
            TrySetValue: function (value) {
                return this.indexerObserver != null ? this.indexerObserver.System$Windows$Data$IPropertyObserver$TrySetValue(value) : false;
            },
            SetBaseValue: function (baseValue) {
                if (this.baseObserver != null) {
                    this.baseObserver.System$Windows$Data$IPropertyObserver$SetBaseValue(baseValue);
                } else {
                    this.indexerObserver.System$Windows$Data$IPropertyObserver$SetBaseValue(baseValue);
                }
            }
        }
    });

    Bridge.ns("System.Windows.Data.IndexPropertyObserver", $asm.$);

    Bridge.apply($asm.$.System.Windows.Data.IndexPropertyObserver, {
        f1: function (sender, oldValue, newValue) {
            System.Windows.Data.ObservableValueChangedEventHandlerExtensions.Raise(this.ValueChanged, this, oldValue, newValue);
        },
        f2: function (sender, oldValue, newValue) {
            this.indexerObserver.System$Windows$Data$IPropertyObserver$SetBaseValue(this.baseObserver.System$Windows$Data$IObservableValue$Value);
        }
    });

    Bridge.define("System.Windows.Data.ScopeElementSourceObserver", {
        inherits: [System.Windows.Data.ContextSourceObserver],
        statics: {
            methods: {
                GetScopeElement: function (target, elementName) {
                    var nameScope = System.Windows.NameScope.GetContainingNameScope(target);
                    return nameScope != null ? nameScope.System$Windows$INameScope$findName(elementName) : System.Windows.Data.ObservableValue.UnsetValue;
                }
            }
        },
        fields: {
            target$1: null,
            elementName: null
        },
        ctors: {
            ctor: function (target, elementName) {
                this.$initialize();
                System.Windows.Data.ContextSourceObserver.ctor.call(this, target, System.Windows.Data.ScopeElementSourceObserver.GetScopeElement(target, elementName));
                this.target$1 = target;
                this.elementName = elementName;
            }
        },
        methods: {
            GetBaseValue: function () {
                return System.Windows.Data.ScopeElementSourceObserver.GetScopeElement(this.target$1, this.elementName);
            }
        }
    });

    Bridge.define("System.Windows.Data.TemplatedParentSourceObserver", {
        inherits: [System.Windows.Data.ContextSourceObserver],
        statics: {
            methods: {
                GetTemplatedParent: function (target) {
                    while (!(Bridge.is(target, System.Windows.FrameworkElement)) && Bridge.is(target, System.Windows.IContextElement)) {
                        target = Bridge.cast(target, System.Windows.IContextElement).System$Windows$IContextElement$ContextParent;
                    }

                    return Bridge.is(target, System.Windows.FrameworkElement) ? Bridge.cast(target, System.Windows.FrameworkElement).TemplatedParent : System.Windows.Data.ObservableValue.UnsetValue;
                }
            }
        },
        fields: {
            target$1: null
        },
        ctors: {
            ctor: function (target) {
                this.$initialize();
                System.Windows.Data.ContextSourceObserver.ctor.call(this, target, System.Windows.Data.TemplatedParentSourceObserver.GetTemplatedParent(target));
                this.target$1 = target;
            }
        },
        methods: {
            GetBaseValue: function () {
                return System.Windows.Data.TemplatedParentSourceObserver.GetTemplatedParent(this.target$1);
            }
        }
    });

    Bridge.define("System.Windows.DataTemplate", {
        inherits: [System.Windows.FrameworkTemplate],
        fields: {
            dataType: null,
            key: null
        },
        props: {
            DataType: {
                get: function () {
                    return this.dataType;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.dataType, value)) {
                        return;
                    }

                    this.dataType = value;
                }
            },
            Key: {
                get: function () {
                    var $t;
                    return ($t = this.key, $t != null ? $t : new System.Windows.TemplateKey(this.DataType));
                },
                set: function (value) {
                    this.key = value;
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.FrameworkTemplate.ctor.call(this);
                //
            }
        }
    });

    Bridge.define("System.Windows.TriggerBase", {
        inherits: [System.Windows.Freezable,System.Windows.ITrigger]
    });

    Bridge.define("System.Windows.DataTriggerCondition", {
        inherits: [System.Windows.Freezable,System.Windows.IDataTriggerCondition,System.IDisposable],
        statics: {
            fields: {
                ValueProperty: null
            },
            ctors: {
                init: function () {
                    this.ValueProperty = System.Windows.DependencyProperty.Register("Value", System.Object, System.Windows.DataTriggerCondition, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.DataTriggerCondition.f1));
                }
            },
            methods: {
                GetResolvedValue: function (value, type) {
                    if (Bridge.Reflection.isInstanceOfType(value, type)) {
                        return value;
                    }

                    var resolvedValue = { };
                    if (System.Windows.Markup.TypeConverter.TryConvertValue(value.toString(), type, System.Windows.Markup.XamlNamespaces.Empty, null, resolvedValue)) {
                        return resolvedValue.v;
                    }

                    return null;
                },
                Register: function (element, expressionProvider, value) {
                    var condition = new System.Windows.DataTriggerCondition(element, expressionProvider, value);
                    condition.Register();
                    return condition;
                }
            }
        },
        fields: {
            isMatched: false,
            element: null,
            expressionProvider: null,
            value: null,
            resolvedValue: null,
            isDisposed: false
        },
        events: {
            IsMatchedChanged: null
        },
        props: {
            IsMatched: {
                get: function () {
                    return this.isMatched;
                },
                set: function (value) {
                    if (this.isMatched === value) {
                        return;
                    }

                    this.isMatched = value;
                    Granular.Extensions.EventHandlerExtensions.Raise$2(this.IsMatchedChanged, this);
                }
            }
        },
        alias: [
            "addIsMatchedChanged", "System$Windows$IDataTriggerCondition$addIsMatchedChanged",
            "removeIsMatchedChanged", "System$Windows$IDataTriggerCondition$removeIsMatchedChanged",
            "IsMatched", "System$Windows$IDataTriggerCondition$IsMatched",
            "dispose", "System$IDisposable$dispose"
        ],
        ctors: {
            ctor: function (element, expressionProvider, value) {
                this.$initialize();
                System.Windows.Freezable.ctor.call(this);
                this.element = element;
                this.expressionProvider = expressionProvider;
                this.value = value;
            }
        },
        methods: {
            Register: function () {
                this.TrySetContextParent(this.element);
                this.SetValue(System.Windows.DataTriggerCondition.ValueProperty, this.expressionProvider);
            },
            dispose: function () {
                this.isDisposed = true;
                this.TrySetContextParent(null);
                this.ClearValue(System.Windows.DataTriggerCondition.ValueProperty);
            },
            OnValueChanged: function (e) {
                if (this.isDisposed) {
                    return;
                }

                if (e.NewValue != null && this.value != null) {
                    this.resolvedValue = System.Windows.DataTriggerCondition.GetResolvedValue(this.value, Bridge.getType(e.NewValue));
                    this.value = null;
                }

                this.IsMatched = Granular.Compatibility.EqualityComparer.Default.equals2(e.NewValue, this.resolvedValue);
            }
        }
    });

    Bridge.ns("System.Windows.DataTriggerCondition", $asm.$);

    Bridge.apply($asm.$.System.Windows.DataTriggerCondition, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.DataTriggerCondition).OnValueChanged(e);
        }
    });

    Bridge.define("System.Windows.DependencyPropertyValueEntry.IndexedObservableValue", {
        inherits: [System.Windows.Data.ObservableValue],
        props: {
            Index: 0
        },
        ctors: {
            ctor: function (index, baseValue) {
                this.$initialize();
                System.Windows.Data.ObservableValue.$ctor1.call(this, baseValue);
                this.Index = index;
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.Animatable", {
        inherits: [System.Windows.Freezable,System.Windows.Media.Animation.IAnimatable],
        props: {
            RootClock: null
        },
        alias: [
            "RootClock", "System$Windows$Media$Animation$IAnimatable$RootClock",
            "SetAnimationClocks", "System$Windows$Media$Animation$IAnimatable$SetAnimationClocks",
            "AddAnimationClocks", "System$Windows$Media$Animation$IAnimatable$AddAnimationClocks",
            "RemoveAnimationClocks", "System$Windows$Media$Animation$IAnimatable$RemoveAnimationClocks"
        ],
        methods: {
            SetAnimationClocks: function (dependencyProperty, animationClocks, layerOwner) {
                var animationExpression = this.GetInitializedAnimationExpression(dependencyProperty);
                animationExpression.SetClocks(animationClocks, layerOwner);
            },
            AddAnimationClocks: function (dependencyProperty, animationClocks, layerOwner) {
                var animationExpression = this.GetInitializedAnimationExpression(dependencyProperty);
                animationExpression.AddClocks(animationClocks, layerOwner);
            },
            RemoveAnimationClocks: function (dependencyProperty, animationClocks, layerOwner) {
                var animationExpression = this.GetInitializedAnimationExpression(dependencyProperty);
                animationExpression.RemoveClocks(animationClocks, layerOwner);
            },
            GetInitializedAnimationExpression: function (dependencyProperty) {
                var entry = this.GetValueEntry(dependencyProperty);
                var animationExpression = Bridge.as(System.Windows.DependencyPropertyValueEntryExtensions.GetAnimationValue(entry, false), System.Windows.Media.Animation.AnimationExpression);

                if (animationExpression == null) {
                    animationExpression = new System.Windows.Media.Animation.AnimationExpression(this, dependencyProperty);

                    System.Windows.DependencyPropertyValueEntryExtensions.SetAnimationValue(entry, animationExpression);
                }

                return animationExpression;
            },
            OnInheritanceParentChanged: function (oldInheritanceParent, newInheritanceParent) {
                System.Windows.Freezable.prototype.OnInheritanceParentChanged.call(this, oldInheritanceParent, newInheritanceParent);

                this.RootClock = Bridge.is(newInheritanceParent, System.Windows.Media.Animation.IAnimatable) ? Bridge.cast(newInheritanceParent, System.Windows.Media.Animation.IAnimatable).System$Windows$Media$Animation$IAnimatable$RootClock : null;
            }
        }
    });

    Bridge.define("System.Windows.FrameworkContentElement", {
        inherits: [System.Windows.ContentElement]
    });

    Bridge.define("System.Windows.FreezableCollection$1", function (T) { return {
        inherits: [System.Windows.Freezable,Granular.Collections.IObservableCollection$1(T),System.Collections.Generic.IList$1(T)],
        fields: {
            collection: null
        },
        events: {
            CollectionChanged: null
        },
        props: {
            Count: {
                get: function () {
                    return this.collection.Count;
                }
            },
            IsReadOnly: {
                get: function () {
                    return this.collection.IsReadOnly;
                }
            }
        },
        alias: [
            "addCollectionChanged", "Granular$Collections$INotifyCollectionChanged$addCollectionChanged",
            "removeCollectionChanged", "Granular$Collections$INotifyCollectionChanged$removeCollectionChanged",
            "Count", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$Count",
            "getItem", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$getItem",
            "setItem", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$setItem",
            "IsReadOnly", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$IsReadOnly",
            "add", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$add",
            "clear", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$clear",
            "contains", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$contains",
            "indexOf", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$indexOf",
            "insert", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$insert",
            "remove", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$remove",
            "removeAt", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$removeAt",
            "copyTo", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$copyTo",
            "getEnumerator", ["System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(T) + "$getEnumerator", "System$Collections$Generic$IEnumerable$1$getEnumerator"]
        ],
        ctors: {
            ctor: function () {
                System.Windows.FreezableCollection$1(T).$ctor1.call(this, System.Array.init(0, function (){
                    return Bridge.getDefaultValue(T);
                }, T));
                //
            },
            $ctor1: function (collection) {
                var $t;
                this.$initialize();
                System.Windows.Freezable.ctor.call(this);
                this.collection = new (Granular.Collections.ObservableCollection$1(T)).$ctor1(collection);
                this.collection.addCollectionChanged(Bridge.fn.cacheBind(this, this.OnCollectionChanged));

                $t = Bridge.getEnumerator(collection, T);
                try {
                    while ($t.moveNext()) {
                        var value = $t.Current;
                        if (Bridge.is(value, System.Windows.IContextElement)) {
                            Bridge.cast(value, System.Windows.IContextElement).System$Windows$IContextElement$TrySetContextParent(this);
                        }

                        if (Bridge.is(value, System.Windows.INotifyChanged)) {
                            Bridge.cast(value, System.Windows.INotifyChanged).System$Windows$INotifyChanged$addChanged(Bridge.fn.cacheBind(this, this.OnItemChanged));
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }}
        },
        methods: {
            getItem: function (index) {
                return this.collection.getItem(index);
            },
            setItem: function (index, value) {
                this.collection.setItem(index, value);
            },
            OnCollectionChanged: function (sender, e) {
                var $t, $t1;
                $t = Bridge.getEnumerator(e.OldItems, System.Object);
                try {
                    while ($t.moveNext()) {
                        var value = Bridge.cast($t.Current, T);
                        if (Bridge.is(value, System.Windows.IContextElement)) {
                            Bridge.cast(value, System.Windows.IContextElement).System$Windows$IContextElement$TrySetContextParent(null);
                        }

                        if (Bridge.is(value, System.Windows.INotifyChanged)) {
                            Bridge.cast(value, System.Windows.INotifyChanged).System$Windows$INotifyChanged$removeChanged(Bridge.fn.cacheBind(this, this.OnItemChanged));
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                $t1 = Bridge.getEnumerator(e.NewItems, System.Object);
                try {
                    while ($t1.moveNext()) {
                        var value1 = Bridge.cast($t1.Current, T);
                        if (Bridge.is(value1, System.Windows.IContextElement)) {
                            Bridge.cast(value1, System.Windows.IContextElement).System$Windows$IContextElement$TrySetContextParent(this);
                        }

                        if (Bridge.is(value1, System.Windows.INotifyChanged)) {
                            Bridge.cast(value1, System.Windows.INotifyChanged).System$Windows$INotifyChanged$addChanged(Bridge.fn.cacheBind(this, this.OnItemChanged));
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$dispose();
                    }
                }
                Granular.Collections.NotifyCollectionChangedEventHandlerExtensions.Raise(this.CollectionChanged, this, e);
                this.RaiseChanged();
            },
            OnItemChanged: function (sender, e) {
                this.RaiseChanged();
            },
            add: function (item) {
                this.collection.add(item);
            },
            clear: function () {
                this.collection.clear();
            },
            contains: function (item) {
                return this.collection.contains(item);
            },
            indexOf: function (item) {
                return this.collection.indexOf(item);
            },
            insert: function (index, item) {
                this.collection.insert(index, item);
            },
            remove: function (item) {
                return this.collection.remove(item);
            },
            removeAt: function (index) {
                this.collection.removeAt(index);
            },
            copyTo: function (array, arrayIndex) {
                this.collection.copyTo(array, arrayIndex);
            },
            getEnumerator: function () {
                return this.collection.getEnumerator();
            },
            System$Collections$IEnumerable$getEnumerator: function () {
                return Bridge.getEnumerator(Bridge.cast(this.collection, System.Collections.IEnumerable));
            }
        }
    }; });

    Bridge.define("System.Windows.Input.KeyboardEventArgs", {
        inherits: [System.Windows.Input.InputEventArgs],
        props: {
            KeyboardDevice: null
        },
        ctors: {
            ctor: function (routedEvent, originalSource, keyboardDevice, timestamp) {
                this.$initialize();
                System.Windows.Input.InputEventArgs.ctor.call(this, routedEvent, originalSource, keyboardDevice, timestamp);
                this.KeyboardDevice = keyboardDevice;
            }
        }
    });

    Bridge.define("System.Windows.Input.KeyboardNavigationTarget.ContainedNavigation", {
        inherits: [System.Windows.Input.KeyboardNavigationTarget.BaseNavigation],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Input.KeyboardNavigationTarget.ContainedNavigation();
                }
            }
        },
        alias: [
            "FindNextTarget", "System$Windows$Input$KeyboardNavigationTarget$INavigation$FindNextTarget",
            "FindPreviousTarget", "System$Windows$Input$KeyboardNavigationTarget$INavigation$FindPreviousTarget",
            "FindFirstTarget", "System$Windows$Input$KeyboardNavigationTarget$INavigation$FindFirstTarget",
            "FindLastTarget", "System$Windows$Input$KeyboardNavigationTarget$INavigation$FindLastTarget"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Input.KeyboardNavigationTarget.BaseNavigation.ctor.call(this);
                //
            }
        },
        methods: {
            FindNextTarget: function (scope, currentStop, navigationModeProperty, stopComparerProvider) {
                return System.Windows.Input.KeyboardNavigationTarget.FindNextContainedTarget(scope, currentStop, navigationModeProperty, stopComparerProvider) || currentStop.Element; // stay at the edge
            },
            FindPreviousTarget: function (scope, currentStop, navigationModeProperty, stopComparerProvider) {
                return System.Windows.Input.KeyboardNavigationTarget.FindPreviousContainedTarget(scope, currentStop, navigationModeProperty, stopComparerProvider) || currentStop.Element; // stay at the edge
            },
            FindFirstTarget: function (scope, currentStop, navigationModeProperty, stopComparerProvider) {
                return System.Windows.Input.KeyboardNavigationTarget.FindFirstContainedTarget(scope, currentStop, navigationModeProperty, stopComparerProvider);
            },
            FindLastTarget: function (scope, currentStop, navigationModeProperty, stopComparerProvider) {
                return System.Windows.Input.KeyboardNavigationTarget.FindLastContainedTarget(scope, currentStop, navigationModeProperty, stopComparerProvider);
            }
        }
    });

    Bridge.define("System.Windows.Input.KeyboardNavigationTarget.ContinueNavigation", {
        inherits: [System.Windows.Input.KeyboardNavigationTarget.BaseNavigation],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Input.KeyboardNavigationTarget.ContinueNavigation();
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Input.KeyboardNavigationTarget.BaseNavigation.ctor.call(this);
                //
            }
        }
    });

    Bridge.define("System.Windows.Input.KeyboardNavigationTarget.CycleNavigation", {
        inherits: [System.Windows.Input.KeyboardNavigationTarget.BaseNavigation],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Input.KeyboardNavigationTarget.CycleNavigation();
                }
            }
        },
        alias: [
            "FindNextTarget", "System$Windows$Input$KeyboardNavigationTarget$INavigation$FindNextTarget",
            "FindPreviousTarget", "System$Windows$Input$KeyboardNavigationTarget$INavigation$FindPreviousTarget",
            "FindFirstTarget", "System$Windows$Input$KeyboardNavigationTarget$INavigation$FindFirstTarget",
            "FindLastTarget", "System$Windows$Input$KeyboardNavigationTarget$INavigation$FindLastTarget"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Input.KeyboardNavigationTarget.BaseNavigation.ctor.call(this);
                //
            }
        },
        methods: {
            FindNextTarget: function (scope, currentStop, navigationModeProperty, stopComparerProvider) {
                return System.Windows.Input.KeyboardNavigationTarget.FindNextContainedTarget(scope, currentStop, navigationModeProperty, stopComparerProvider) || System.Windows.Input.KeyboardNavigationTarget.FindFirstContainedTarget(scope, currentStop, navigationModeProperty, stopComparerProvider);
            },
            FindPreviousTarget: function (scope, currentStop, navigationModeProperty, stopComparerProvider) {
                return System.Windows.Input.KeyboardNavigationTarget.FindPreviousContainedTarget(scope, currentStop, navigationModeProperty, stopComparerProvider) || System.Windows.Input.KeyboardNavigationTarget.FindLastContainedTarget(scope, currentStop, navigationModeProperty, stopComparerProvider);
            },
            FindFirstTarget: function (scope, currentStop, navigationModeProperty, stopComparerProvider) {
                return System.Windows.Input.KeyboardNavigationTarget.FindFirstContainedTarget(scope, currentStop, navigationModeProperty, stopComparerProvider);
            },
            FindLastTarget: function (scope, currentStop, navigationModeProperty, stopComparerProvider) {
                return System.Windows.Input.KeyboardNavigationTarget.FindLastContainedTarget(scope, currentStop, navigationModeProperty, stopComparerProvider);
            }
        }
    });

    Bridge.define("System.Windows.Input.KeyboardNavigationTarget.LocalNavigation", {
        inherits: [System.Windows.Input.KeyboardNavigationTarget.BaseNavigation],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Input.KeyboardNavigationTarget.LocalNavigation();
                }
            }
        },
        alias: [
            "FindNextTarget", "System$Windows$Input$KeyboardNavigationTarget$INavigation$FindNextTarget",
            "FindPreviousTarget", "System$Windows$Input$KeyboardNavigationTarget$INavigation$FindPreviousTarget",
            "GetGlobalStops", "System$Windows$Input$KeyboardNavigationTarget$INavigation$GetGlobalStops"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Input.KeyboardNavigationTarget.BaseNavigation.ctor.call(this);
                //
            }
        },
        methods: {
            FindNextTarget: function (scope, currentStop, navigationModeProperty, stopComparerProvider) {
                return System.Windows.Input.KeyboardNavigationTarget.FindNextContainedTarget(scope, currentStop, navigationModeProperty, stopComparerProvider) || (scope.VisualParent != null ? System.Windows.Input.KeyboardNavigationTarget.FindNextTarget(scope.VisualParent, new System.Windows.Input.KeyboardNavigationTarget.Stop.$ctor1(currentStop.Element, System.Windows.Input.KeyboardNavigation.GetTabIndex(scope)), navigationModeProperty, stopComparerProvider) : null); // translate currentStop and forward request to parent
            },
            FindPreviousTarget: function (scope, currentStop, navigationModeProperty, stopComparerProvider) {
                return System.Windows.Input.KeyboardNavigationTarget.FindPreviousContainedTarget(scope, currentStop, navigationModeProperty, stopComparerProvider) || (scope.VisualParent != null ? System.Windows.Input.KeyboardNavigationTarget.FindPreviousTarget(scope.VisualParent, new System.Windows.Input.KeyboardNavigationTarget.Stop.$ctor1(currentStop.Element, System.Windows.Input.KeyboardNavigation.GetTabIndex(scope)), navigationModeProperty, stopComparerProvider) : null); // translate currentStop and forward request to parent
            },
            GetGlobalStops: function (scope, currentElement, navigationModeProperty) {
                return new (Bridge.GeneratorEnumerable$1(System.Windows.Input.KeyboardNavigationTarget.Stop))(Bridge.fn.bind(this, function (scope, currentElement, navigationModeProperty) {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        scopeTabIndex,
                        $t,
                        stop,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(System.Windows.Input.KeyboardNavigationTarget.Stop))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        scopeTabIndex = System.Windows.Input.KeyboardNavigation.GetTabIndex(scope);

                                            if (System.Windows.Input.KeyboardNavigationTarget.IsStop(Bridge.cast(scope, System.Windows.UIElement)) || Bridge.referenceEquals(scope, currentElement)) {
                                                $step = 1;
                                                continue;
                                            } 
                                            $step = 3;
                                            continue;
                                    }
                                    case 1: {
                                        $enumerator.current = new System.Windows.Input.KeyboardNavigationTarget.Stop.$ctor1(scope, scopeTabIndex);
                                            $step = 2;
                                            return true;
                                    }
                                    case 2: {
                                        $step = 3;
                                        continue;
                                    }
                                    case 3: {
                                        // translate stops to have scope tab index instead of local tab index, local order is kept
                                            $t = Bridge.getEnumerator(System.Linq.Enumerable.from(scope.VisualChildren).selectMany(function (child) {
                                                    return System.Windows.Input.KeyboardNavigationTarget.GetGlobalStops(child, currentElement, navigationModeProperty);
                                                }).orderBy($asm.$.System.Windows.Input.KeyboardNavigationTarget.LocalNavigation.f1));
                                            $step = 4;
                                            continue;
                                    }
                                    case 4: {
                                        if ($t.moveNext()) {
                                                stop = $t.Current;
                                                $step = 5;
                                                continue;
                                            }
                                        $step = 7;
                                        continue;
                                    }
                                    case 5: {
                                        $enumerator.current = new System.Windows.Input.KeyboardNavigationTarget.Stop.$ctor1(stop.Element, scopeTabIndex);
                                            $step = 6;
                                            return true;
                                    }
                                    case 6: {
                                        $step = 4;
                                        continue;
                                    }
                                    case 7: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }, arguments));
            }
        }
    });

    Bridge.ns("System.Windows.Input.KeyboardNavigationTarget.LocalNavigation", $asm.$);

    Bridge.apply($asm.$.System.Windows.Input.KeyboardNavigationTarget.LocalNavigation, {
        f1: function (childStop) {
            return childStop.TabIndex;
        }
    });

    Bridge.define("System.Windows.Input.KeyboardNavigationTarget.NoneNavigation", {
        inherits: [System.Windows.Input.KeyboardNavigationTarget.BaseNavigation],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Input.KeyboardNavigationTarget.NoneNavigation();
                }
            }
        },
        alias: [
            "FindNextTarget", "System$Windows$Input$KeyboardNavigationTarget$INavigation$FindNextTarget",
            "FindPreviousTarget", "System$Windows$Input$KeyboardNavigationTarget$INavigation$FindPreviousTarget",
            "GetGlobalStops", "System$Windows$Input$KeyboardNavigationTarget$INavigation$GetGlobalStops"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Input.KeyboardNavigationTarget.BaseNavigation.ctor.call(this);
                //
            }
        },
        methods: {
            FindNextTarget: function (scope, currentStop, navigationModeProperty, stopComparerProvider) {
                // forward the request to the parent
                return scope.VisualParent != null ? System.Windows.Input.KeyboardNavigationTarget.FindNextTarget(scope.VisualParent, currentStop, navigationModeProperty, stopComparerProvider) : null;
            },
            FindPreviousTarget: function (scope, currentStop, navigationModeProperty, stopComparerProvider) {
                // forward the request to the parent
                return scope.VisualParent != null ? System.Windows.Input.KeyboardNavigationTarget.FindPreviousTarget(scope.VisualParent, currentStop, navigationModeProperty, stopComparerProvider) : null;
            },
            GetGlobalStops: function (scope, currentElement, navigationModeProperty) {
                return new (Bridge.GeneratorEnumerable$1(System.Windows.Input.KeyboardNavigationTarget.Stop))(Bridge.fn.bind(this, function (scope, currentElement, navigationModeProperty) {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        childrenStop,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(System.Windows.Input.KeyboardNavigationTarget.Stop))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        if (System.Windows.Input.KeyboardNavigationTarget.IsStop(Bridge.cast(scope, System.Windows.UIElement)) || Bridge.referenceEquals(scope, currentElement)) {
                                                $step = 1;
                                                continue;
                                            } 
                                            $step = 3;
                                            continue;
                                    }
                                    case 1: {
                                        $enumerator.current = new System.Windows.Input.KeyboardNavigationTarget.Stop.ctor(scope);
                                            $step = 2;
                                            return true;
                                    }
                                    case 2: {
                                        $step = 3;
                                        continue;
                                    }
                                    case 3: {
                                        // add currentElement stop if it's a descendant of scope
                                            if (System.Windows.Media.VisualExtensions.IsAncestorOf(scope, currentElement)) {
                                                $step = 4;
                                                continue;
                                            } 
                                            $step = 6;
                                            continue;
                                    }
                                    case 4: {
                                        childrenStop = System.Linq.Enumerable.from(scope.VisualChildren).selectMany(function (child) {
                                                    return System.Windows.Input.KeyboardNavigationTarget.GetGlobalStops(child, currentElement, navigationModeProperty);
                                                });
                                            $enumerator.current = System.Linq.Enumerable.from(childrenStop).first(function (childStop) {
                                                    return Bridge.referenceEquals(childStop.Element, currentElement);
                                                });
                                            $step = 5;
                                            return true;
                                    }
                                    case 5: {
                                        $step = 6;
                                        continue;
                                    }
                                    case 6: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }, arguments));
            }
        }
    });

    Bridge.define("System.Windows.Input.KeyboardNavigationTarget.OnceNavigation", {
        inherits: [System.Windows.Input.KeyboardNavigationTarget.BaseNavigation],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Input.KeyboardNavigationTarget.OnceNavigation();
                }
            }
        },
        alias: [
            "FindNextTarget", "System$Windows$Input$KeyboardNavigationTarget$INavigation$FindNextTarget",
            "FindPreviousTarget", "System$Windows$Input$KeyboardNavigationTarget$INavigation$FindPreviousTarget",
            "GetGlobalStops", "System$Windows$Input$KeyboardNavigationTarget$INavigation$GetGlobalStops"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Input.KeyboardNavigationTarget.BaseNavigation.ctor.call(this);
                //
            }
        },
        methods: {
            FindNextTarget: function (scope, currentStop, navigationModeProperty, stopComparerProvider) {
                // forward the request to the parent
                return scope.VisualParent != null ? System.Windows.Input.KeyboardNavigationTarget.FindNextTarget(scope.VisualParent, currentStop, navigationModeProperty, stopComparerProvider) : null;
            },
            FindPreviousTarget: function (scope, currentStop, navigationModeProperty, stopComparerProvider) {
                // forward the request to the parent
                return scope.VisualParent != null ? System.Windows.Input.KeyboardNavigationTarget.FindPreviousTarget(scope.VisualParent, currentStop, navigationModeProperty, stopComparerProvider) : null;
            },
            GetGlobalStops: function (scope, currentElement, navigationModeProperty) {
                return new (Bridge.GeneratorEnumerable$1(System.Windows.Input.KeyboardNavigationTarget.Stop))(Bridge.fn.bind(this, function (scope, currentElement, navigationModeProperty) {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        navigationFocusElementReference,
                        navigationFocusElement,
                        stops,
                        $t,
                        stop,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(System.Windows.Input.KeyboardNavigationTarget.Stop))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        if (System.Windows.Input.KeyboardNavigationTarget.IsStop(Bridge.cast(scope, System.Windows.UIElement)) || Bridge.referenceEquals(scope, currentElement)) {
                                                $step = 1;
                                                continue;
                                            } 
                                            $step = 3;
                                            continue;
                                    }
                                    case 1: {
                                        $enumerator.current = new System.Windows.Input.KeyboardNavigationTarget.Stop.ctor(scope);
                                            $step = 2;
                                            return true;
                                    }
                                    case 2: {
                                        $step = 3;
                                        continue;
                                    }
                                    case 3: {
                                        navigationFocusElementReference = System.Windows.Input.KeyboardNavigation.GetNavigationFocusElement(scope);
                                            navigationFocusElement = navigationFocusElementReference != null ? navigationFocusElementReference.Visual : null;

                                            stops = System.Linq.Enumerable.from(scope.VisualChildren).selectMany(function (child) {
                                                    return System.Windows.Input.KeyboardNavigationTarget.GetGlobalStops(child, currentElement, navigationModeProperty);
                                                }).toArray(System.Windows.Input.KeyboardNavigationTarget.Stop);

                                            if (System.Linq.Enumerable.from(stops).any()) {
                                                $step = 4;
                                                continue;
                                            } 
                                            $step = 9;
                                            continue;
                                    }
                                    case 4: {
                                        stops = System.Linq.Enumerable.from(stops).where(function (stop) {
                                                    return Bridge.referenceEquals(stop.Element, currentElement) || Bridge.referenceEquals(stop.Element, navigationFocusElement);
                                                }).defaultIfEmpty(System.Linq.Enumerable.from(stops).first()).toArray(System.Windows.Input.KeyboardNavigationTarget.Stop);

                                            $t = Bridge.getEnumerator(stops);
                                            $step = 5;
                                            continue;
                                    }
                                    case 5: {
                                        if ($t.moveNext()) {
                                                stop = $t.Current;
                                                $step = 6;
                                                continue;
                                            }
                                        $step = 8;
                                        continue;
                                    }
                                    case 6: {
                                        $enumerator.current = stop;
                                            $step = 7;
                                            return true;
                                    }
                                    case 7: {
                                        $step = 5;
                                        continue;
                                    }
                                    case 8: {
                                        $step = 9;
                                        continue;
                                    }
                                    case 9: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }, arguments));
            }
        }
    });

    Bridge.define("System.Windows.Input.MouseEventArgs", {
        inherits: [System.Windows.Input.InputEventArgs],
        props: {
            MouseDevice: null,
            LeftButton: 0,
            MiddleButton: 0,
            RightButton: 0,
            XButton1: 0,
            XButton2: 0,
            AbsolutePosition: null
        },
        ctors: {
            ctor: function (routedEvent, originalSource, mouseDevice, timestamp, absolutePosition) {
                this.$initialize();
                System.Windows.Input.InputEventArgs.ctor.call(this, routedEvent, originalSource, mouseDevice, timestamp);
                this.MouseDevice = mouseDevice;
                this.AbsolutePosition = absolutePosition;

                this.LeftButton = mouseDevice.GetButtonState(System.Windows.Input.MouseButton.Left);
                this.MiddleButton = mouseDevice.GetButtonState(System.Windows.Input.MouseButton.Middle);
                this.RightButton = mouseDevice.GetButtonState(System.Windows.Input.MouseButton.Right);
                this.XButton1 = mouseDevice.GetButtonState(System.Windows.Input.MouseButton.XButton1);
                this.XButton2 = mouseDevice.GetButtonState(System.Windows.Input.MouseButton.XButton2);
            }
        },
        methods: {
            GetPosition: function (relativeTo) {
                return relativeTo.System$Windows$IInputElement$GetRelativePosition(this.AbsolutePosition);
            },
            InvokeEventHandler: function (handler, target) {
                if (Bridge.is(handler, Function)) {
                    handler(target, this);
                } else {
                    System.Windows.Input.InputEventArgs.prototype.InvokeEventHandler.call(this, handler, target);
                }
            }
        }
    });

    Bridge.define("System.Windows.Input.RawMouseButtonEventArgs", {
        inherits: [System.Windows.Input.RawMouseEventArgs],
        props: {
            Button: 0,
            ButtonState: 0
        },
        ctors: {
            ctor: function (button, buttonState, position, timestamp) {
                this.$initialize();
                System.Windows.Input.RawMouseEventArgs.ctor.call(this, position, timestamp);
                this.Button = button;
                this.ButtonState = buttonState;
            }
        }
    });

    Bridge.define("System.Windows.Input.RawMouseWheelEventArgs", {
        inherits: [System.Windows.Input.RawMouseEventArgs],
        props: {
            Delta: 0
        },
        ctors: {
            ctor: function (delta, position, timestamp) {
                this.$initialize();
                System.Windows.Input.RawMouseEventArgs.ctor.call(this, position, timestamp);
                this.Delta = delta;
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.AnimationExpression", {
        inherits: [System.Windows.IExpression],
        fields: {
            layers: null,
            observableValue: null,
            dependencyObject: null,
            dependencyProperty: null
        },
        events: {
            ValueChanged: null
        },
        props: {
            Value: {
                get: function () {
                    return this.observableValue.Value;
                }
            }
        },
        alias: [
            "addValueChanged", "System$Windows$Data$IObservableValue$addValueChanged",
            "removeValueChanged", "System$Windows$Data$IObservableValue$removeValueChanged",
            "Value", "System$Windows$Data$IObservableValue$Value",
            "SetValue", "System$Windows$IExpression$SetValue"
        ],
        ctors: {
            ctor: function (dependencyObject, dependencyProperty) {
                this.$initialize();
                this.dependencyObject = dependencyObject;
                this.dependencyProperty = dependencyProperty;

                this.observableValue = new System.Windows.Data.ObservableValue.ctor();
                this.observableValue.addValueChanged(Bridge.fn.bind(this, $asm.$.System.Windows.Media.Animation.AnimationExpression.f1));

                this.layers = new System.Windows.Media.Animation.AnimationLayerCollection();
                this.layers.addLayerInvalidated(Bridge.fn.cacheBind(this, this.OnLayerInvalidated));

                this.SetAnimationValue();
            }
        },
        methods: {
            SetValue: function (value) {
                return false;
            },
            SetClocks: function (clocks, layerOwner) {
                this.layers.SetClocks(clocks, this.GetAnimationBaseValue(), System.Windows.Media.Animation.AnimationLayerKey.FromLayerOwner(layerOwner));
            },
            AddClocks: function (clocks, layerOwner) {
                this.layers.AddClocks(clocks, System.Windows.Media.Animation.AnimationLayerKey.FromLayerOwner(layerOwner));
            },
            RemoveClocks: function (clocks, layerOwner) {
                this.layers.RemoveClocks(clocks, System.Windows.Media.Animation.AnimationLayerKey.FromLayerOwner(layerOwner));
            },
            SetAnimationValue: function () {
                this.observableValue.BaseValue = this.layers.HasValue ? this.layers.GetValue(this.GetAnimationBaseValue()) : System.Windows.Data.ObservableValue.UnsetValue;
            },
            GetAnimationBaseValue: function () {
                if (this.dependencyObject == null) {
                    return System.Windows.Data.ObservableValue.UnsetValue;
                }

                var entry = this.dependencyObject.GetValueEntry(this.dependencyProperty);
                return System.Windows.DependencyPropertyValueEntryExtensions.GetBaseValue(entry, true);
            },
            OnLayerInvalidated: function (sender, e) {
                this.SetAnimationValue();
            }
        }
    });

    Bridge.ns("System.Windows.Media.Animation.AnimationExpression", $asm.$);

    Bridge.apply($asm.$.System.Windows.Media.Animation.AnimationExpression, {
        f1: function (sender, oldValue, newValue) {
            System.Windows.Data.ObservableValueChangedEventHandlerExtensions.Raise(this.ValueChanged, this, oldValue, newValue);
        }
    });

    Bridge.define("System.Windows.Media.Animation.Timeline", {
        inherits: [System.Windows.Freezable],
        statics: {
            fields: {
                BeginTimeProperty: null,
                DurationProperty: null,
                FillBehaviorProperty: null,
                RepeatBehaviorProperty: null,
                AutoReverseProperty: null
            },
            ctors: {
                init: function () {
                    this.BeginTimeProperty = System.Windows.DependencyProperty.Register("BeginTime", System.TimeSpan, System.Windows.Media.Animation.Timeline, new System.Windows.FrameworkPropertyMetadata.$ctor1(System.TimeSpan.zero));
                    this.DurationProperty = System.Windows.DependencyProperty.Register("Duration", System.Windows.Duration, System.Windows.Media.Animation.Timeline, new System.Windows.FrameworkPropertyMetadata.$ctor1(new System.Windows.Duration.ctor(System.TimeSpan.fromSeconds(1))));
                    this.FillBehaviorProperty = System.Windows.DependencyProperty.Register("FillBehavior", System.Windows.Media.Animation.FillBehavior, System.Windows.Media.Animation.Timeline, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.RepeatBehaviorProperty = System.Windows.DependencyProperty.Register("RepeatBehavior", System.Windows.Media.Animation.RepeatBehavior, System.Windows.Media.Animation.Timeline, new System.Windows.FrameworkPropertyMetadata.$ctor1(System.Windows.Media.Animation.RepeatBehavior.OneTime));
                    this.AutoReverseProperty = System.Windows.DependencyProperty.Register("AutoReverse", System.Boolean, System.Windows.Media.Animation.Timeline, new System.Windows.FrameworkPropertyMetadata.ctor());
                }
            }
        },
        fields: {
            parent: null
        },
        props: {
            BeginTime: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.Animation.Timeline.BeginTimeProperty)), System.TimeSpan));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Animation.Timeline.BeginTimeProperty, value);
                }
            },
            Duration: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Media.Animation.Timeline.DurationProperty), System.Windows.Duration);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Animation.Timeline.DurationProperty, value);
                }
            },
            FillBehavior: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.Animation.Timeline.FillBehaviorProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Animation.Timeline.FillBehaviorProperty, Bridge.box(value, System.Windows.Media.Animation.FillBehavior, System.Enum.toStringFn(System.Windows.Media.Animation.FillBehavior)));
                }
            },
            RepeatBehavior: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Media.Animation.Timeline.RepeatBehaviorProperty), System.Windows.Media.Animation.RepeatBehavior);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Animation.Timeline.RepeatBehaviorProperty, value);
                }
            },
            AutoReverse: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.Animation.Timeline.AutoReverseProperty)), System.Boolean));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Animation.Timeline.AutoReverseProperty, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            },
            Parent: {
                get: function () {
                    return this.parent;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.parent, value)) {
                        return;
                    }

                    this.parent = value;
                    this.TrySetContextParent(value);
                }
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.AnimationTimelineClock", {
        inherits: [System.Windows.Media.Animation.TimelineClock],
        statics: {
            methods: {
                CreateAnimationClock: function (timeline) {
                    if (!timeline.Duration.HasTimeSpan) {
                        throw new Granular.Exception("Can't resolve animation duration \"{0}\"", [timeline.Duration]);
                    }

                    return new System.Windows.Media.Animation.AnimationClock(timeline.Duration.TimeSpan);
                }
            }
        },
        fields: {
            timeline: null
        },
        ctors: {
            ctor: function (timeline) {
                this.$initialize();
                System.Windows.Media.Animation.TimelineClock.ctor.call(this, System.Windows.Media.Animation.AnimationTimelineClock.CreateAnimationClock(timeline), timeline);
                this.timeline = timeline;
            }
        },
        methods: {
            GetValue: function (defaultOriginValue, defaultDestinationValue) {
                return this.timeline.GetCurrentValue(defaultOriginValue, defaultDestinationValue, this);
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.EasingFunctionBase", {
        inherits: [System.Windows.Freezable,System.Windows.Media.Animation.IEasingFunction],
        statics: {
            fields: {
                EasingModeProperty: null
            },
            ctors: {
                init: function () {
                    this.EasingModeProperty = System.Windows.DependencyProperty.Register("EasingMode", System.Windows.Media.Animation.EasingMode, System.Windows.Media.Animation.EasingFunctionBase, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(System.Windows.Media.Animation.EasingMode.EaseOut, System.Windows.Media.Animation.EasingMode, System.Enum.toStringFn(System.Windows.Media.Animation.EasingMode))));
                }
            }
        },
        props: {
            EasingMode: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.Animation.EasingFunctionBase.EasingModeProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Animation.EasingFunctionBase.EasingModeProperty, Bridge.box(value, System.Windows.Media.Animation.EasingMode, System.Enum.toStringFn(System.Windows.Media.Animation.EasingMode)));
                }
            }
        },
        alias: ["Ease", "System$Windows$Media$Animation$IEasingFunction$Ease"],
        methods: {
            Ease: function (normalizedTime) {
                switch (this.EasingMode) {
                    case System.Windows.Media.Animation.EasingMode.EaseIn: 
                        return this.EaseOverride(normalizedTime);
                    case System.Windows.Media.Animation.EasingMode.EaseOut: 
                        return 1 - this.EaseOverride(1 - normalizedTime);
                    case System.Windows.Media.Animation.EasingMode.EaseInOut: 
                        return normalizedTime < 0.5 ? this.EaseOverride(normalizedTime * 2) / 2 : (2 - this.EaseOverride((1 - normalizedTime) * 2)) / 2;
                }

                throw new Granular.Exception("Unexpected EasingMode \"{0}\"", [Bridge.box(this.EasingMode, System.Windows.Media.Animation.EasingMode, System.Enum.toStringFn(System.Windows.Media.Animation.EasingMode))]);
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.BeginStoryboard", {
        inherits: [System.Windows.Freezable,System.Windows.ITriggerAction],
        statics: {
            fields: {
                StoryboardProperty: null
            },
            ctors: {
                init: function () {
                    this.StoryboardProperty = System.Windows.DependencyProperty.Register("Storyboard", System.Windows.Media.Animation.Storyboard, System.Windows.Media.Animation.BeginStoryboard, new System.Windows.FrameworkPropertyMetadata.ctor());
                }
            }
        },
        props: {
            Storyboard: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Media.Animation.BeginStoryboard.StoryboardProperty), System.Windows.Media.Animation.Storyboard);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Animation.BeginStoryboard.StoryboardProperty, value);
                }
            },
            HandoffBehavior: 0,
            Name: null
        },
        alias: [
            "Apply", "System$Windows$ITriggerAction$Apply",
            "Clean", "System$Windows$ITriggerAction$Clean",
            "IsActionOverlaps", "System$Windows$ITriggerAction$IsActionOverlaps"
        ],
        methods: {
            Apply: function (target, valueSource) {
                var nameScope = valueSource === System.Windows.BaseValueSource.Local ? System.Windows.NameScope.GetContainingNameScope(target) : System.Windows.NameScope.GetTemplateNameScope(target);
                var layerOwner = valueSource === System.Windows.BaseValueSource.Local ? null : target.TemplatedParent;
                this.Begin(target, nameScope, layerOwner);
            },
            Clean: function (target, valueSource) {
                //
            },
            IsActionOverlaps: function (action) {
                return false;
            },
            Begin: function (target, nameScope, layerOwner) {
                if (this.Storyboard != null) {
                    this.Storyboard.Begin(target, nameScope, this.HandoffBehavior, layerOwner);
                }
            },
            Remove: function (target, nameScope, layerOwner) {
                if (this.Storyboard != null) {
                    this.Storyboard.Remove(target, nameScope, layerOwner);
                }
            },
            Stop: function (target) {
                if (this.Storyboard != null) {
                    this.Storyboard.Stop(target);
                }
            },
            Pause: function (target) {
                if (this.Storyboard != null) {
                    this.Storyboard.Pause(target);
                }
            },
            Resume: function (target) {
                if (this.Storyboard != null) {
                    this.Storyboard.Pause(target);
                }
            },
            SkipToFill: function (target) {
                if (this.Storyboard != null) {
                    this.Storyboard.SkipToFill(target);
                }
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.KeyFrame$1", function (T) { return {
        inherits: [System.Windows.Freezable],
        statics: {
            fields: {
                ValueProperty: null,
                KeyTimeProperty: null
            },
            ctors: {
                init: function () {
                    this.ValueProperty = System.Windows.Media.Animation.KeyFrame$1(T).DependencyPropertyRegisterNonGeneric("Value", T, System.Windows.Media.Animation.KeyFrame$1(T), new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.KeyTimeProperty = System.Windows.Media.Animation.KeyFrame$1(T).DependencyPropertyRegisterNonGeneric("KeyTime", System.Windows.Media.Animation.KeyTime, System.Windows.Media.Animation.KeyFrame$1(T), new System.Windows.FrameworkPropertyMetadata.ctor());
                }
            },
            methods: {
                DependencyPropertyRegisterNonGeneric: function (name, propertyType, ownerType, metadata, validateValueCallback) {
                    if (metadata === void 0) { metadata = null; }
                    if (validateValueCallback === void 0) { validateValueCallback = null; }
                    return (T.$isTypeParameter || false) ? null : System.Windows.DependencyProperty.Register(name, propertyType, ownerType, metadata, validateValueCallback);
                }
            }
        },
        props: {
            Value: {
                get: function () {
                    return Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.Animation.KeyFrame$1(T).ValueProperty)), T);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Animation.KeyFrame$1(T).ValueProperty, value);
                }
            },
            KeyTime: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Media.Animation.KeyFrame$1(T).KeyTimeProperty), System.Windows.Media.Animation.KeyTime);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Animation.KeyFrame$1(T).KeyTimeProperty, value);
                }
            }
        }
    }; });

    Bridge.define("System.Windows.Media.Animation.TimelineGroupClock", {
        inherits: [System.Windows.Media.Animation.TimelineClock],
        props: {
            Children: null
        },
        ctors: {
            ctor: function (baseGroupClock, timelineGroup, children) {
                this.$initialize();
                System.Windows.Media.Animation.TimelineClock.ctor.call(this, baseGroupClock, timelineGroup);
                this.Children = children;
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.StoryboardAction", {
        inherits: [System.Windows.Freezable,System.Windows.ITriggerAction],
        props: {
            BeginStoryboardName: null
        },
        alias: [
            "Clean", "System$Windows$ITriggerAction$Clean",
            "IsActionOverlaps", "System$Windows$ITriggerAction$IsActionOverlaps"
        ],
        methods: {
            Clean: function (target, valueSource) {
                //
            },
            IsActionOverlaps: function (action) {
                return false;
            },
            GetBeginStoryboard: function (target) {
                var nameScope = System.Windows.NameScope.GetContainingNameScope(target);
                return nameScope != null ? Bridge.as(nameScope.System$Windows$INameScope$findName(this.BeginStoryboardName), System.Windows.Media.Animation.BeginStoryboard) : null;
            }
        }
    });

    Bridge.define("System.Windows.Media.IImageBrushRenderResource", {
        inherits: [System.Windows.Media.ITileBrushRenderResource],
        $kind: "interface"
    });

    Bridge.define("System.Windows.Media.ILinearGradientBrushRenderResource", {
        inherits: [System.Windows.Media.IGradientBrushRenderResource],
        $kind: "interface"
    });

    Bridge.define("System.Windows.Media.IRadialGradientBrushRenderResource", {
        inherits: [System.Windows.Media.IGradientBrushRenderResource],
        $kind: "interface"
    });

    Bridge.define("System.Windows.ResourceReferenceExpression", {
        inherits: [System.Windows.IExpression,System.IDisposable],
        fields: {
            resourceKey: null,
            observableValue: null,
            resourceContainer: null
        },
        events: {
            ValueChanged: null
        },
        props: {
            Value: {
                get: function () {
                    return this.observableValue.Value;
                }
            }
        },
        alias: [
            "addValueChanged", "System$Windows$Data$IObservableValue$addValueChanged",
            "removeValueChanged", "System$Windows$Data$IObservableValue$removeValueChanged",
            "Value", "System$Windows$Data$IObservableValue$Value",
            "dispose", "System$IDisposable$dispose",
            "SetValue", "System$Windows$IExpression$SetValue"
        ],
        ctors: {
            ctor: function (resourceContainer, resourceKey) {
                this.$initialize();
                this.resourceContainer = resourceContainer;
                this.resourceKey = resourceKey;

                this.observableValue = new System.Windows.Data.ObservableValue.ctor();
                this.observableValue.addValueChanged(Bridge.fn.bind(this, $asm.$.System.Windows.ResourceReferenceExpression.f1));
                this.observableValue.BaseValue = this.GetResourceValue();

                resourceContainer.System$Windows$IResourceContainer$addResourcesChanged(Bridge.fn.cacheBind(this, this.OnResourcesChanged));
            }
        },
        methods: {
            dispose: function () {
                this.observableValue.BaseValue = System.Windows.Data.ObservableValue.UnsetValue;
                this.resourceContainer.System$Windows$IResourceContainer$removeResourcesChanged(Bridge.fn.cacheBind(this, this.OnResourcesChanged));
            },
            OnResourcesChanged: function (sender, e) {
                if (e.Contains(this.resourceKey)) {
                    this.observableValue.BaseValue = this.GetResourceValue();
                }
            },
            SetValue: function (value) {
                return false;
            },
            GetResourceValue: function () {
                var value = { };
                return this.resourceContainer.System$Windows$IResourceContainer$TryGetResource(this.resourceKey, value) ? value.v : System.Windows.Data.ObservableValue.UnsetValue;
            }
        }
    });

    Bridge.ns("System.Windows.ResourceReferenceExpression", $asm.$);

    Bridge.apply($asm.$.System.Windows.ResourceReferenceExpression, {
        f1: function (sender, oldValue, newValue) {
            System.Windows.Data.ObservableValueChangedEventHandlerExtensions.Raise(this.ValueChanged, this, oldValue, newValue);
        }
    });

    Bridge.define("System.Windows.Setter.ValueOverlapExpression", {
        inherits: [System.Windows.IExpressionProvider,System.Windows.IExpression],
        fields: {
            values: null,
            observableValue: null
        },
        events: {
            ValueChanged: null
        },
        props: {
            Value: {
                get: function () {
                    return this.observableValue.Value;
                }
            }
        },
        alias: [
            "addValueChanged", "System$Windows$Data$IObservableValue$addValueChanged",
            "removeValueChanged", "System$Windows$Data$IObservableValue$removeValueChanged",
            "Value", "System$Windows$Data$IObservableValue$Value",
            "CreateExpression", "System$Windows$IExpressionProvider$CreateExpression",
            "SetValue", "System$Windows$IExpression$SetValue"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                this.values = new (System.Collections.Generic.List$1(System.Object)).ctor();

                this.observableValue = new System.Windows.Data.ObservableValue.ctor();
                this.observableValue.addValueChanged(Bridge.fn.bind(this, $asm.$.System.Windows.Setter.ValueOverlapExpression.f1));
            }
        },
        methods: {
            CreateExpression: function (dependencyObject, dependencyProperty) {
                return this;
            },
            SetValue: function (value) {
                return false;
            },
            SetValue$1: function (owner, value) {
                this.values.remove(System.Linq.Enumerable.from(this.values).firstOrDefault(function (tuple) {
                        return Bridge.referenceEquals(tuple.item1, owner);
                    }, null));
                this.values.add({ item1: owner, item2: value });

                this.observableValue.BaseValue = value;
            },
            ClearValue: function (owner) {
                this.values.remove(System.Linq.Enumerable.from(this.values).firstOrDefault(function (tuple) {
                        return Bridge.referenceEquals(tuple.item1, owner);
                    }, null));

                this.observableValue.BaseValue = this.values.Count > 0 ? System.Linq.Enumerable.from(this.values).last().item2 : System.Windows.Data.ObservableValue.UnsetValue;
            }
        }
    });

    Bridge.ns("System.Windows.Setter.ValueOverlapExpression", $asm.$);

    Bridge.apply($asm.$.System.Windows.Setter.ValueOverlapExpression, {
        f1: function (sender, oldValue, newValue) {
            System.Windows.Data.ObservableValueChangedEventHandlerExtensions.Raise(this.ValueChanged, this, oldValue, newValue);
        }
    });

    Bridge.define("System.Windows.VisualState", {
        inherits: [System.Windows.Freezable],
        statics: {
            fields: {
                StoryboardProperty: null
            },
            ctors: {
                init: function () {
                    this.StoryboardProperty = System.Windows.DependencyProperty.Register("Storyboard", System.Windows.Media.Animation.Storyboard, System.Windows.VisualState, new System.Windows.FrameworkPropertyMetadata.ctor());
                }
            }
        },
        props: {
            Name: null,
            Storyboard: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.VisualState.StoryboardProperty), System.Windows.Media.Animation.Storyboard);
                },
                set: function (value) {
                    this.SetValue(System.Windows.VisualState.StoryboardProperty, value);
                }
            }
        }
    });

    Bridge.define("System.Windows.VisualStateGroup", {
        inherits: [System.Windows.Freezable],
        statics: {
            methods: {
                GetTransition: function (transitions, fromStateName, toStateName) {
                    return System.Linq.Enumerable.from(transitions).firstOrDefault(function (transition) {
                            return Bridge.referenceEquals(transition.From, fromStateName) && Bridge.referenceEquals(transition.To, toStateName);
                        }, null) || System.Linq.Enumerable.from(transitions).firstOrDefault(function (transition) {
                            return Granular.Extensions.StringExtensions.IsNullOrEmpty(transition.From) && Bridge.referenceEquals(transition.To, toStateName);
                        }, null) || System.Linq.Enumerable.from(transitions).firstOrDefault(function (transition) {
                            return Bridge.referenceEquals(transition.From, fromStateName) && Granular.Extensions.StringExtensions.IsNullOrEmpty(transition.To);
                        }, null) || System.Linq.Enumerable.from(transitions).firstOrDefault($asm.$.System.Windows.VisualStateGroup.f1, null);
                }
            }
        },
        fields: {
            currentStoryboard: null,
            container: null
        },
        props: {
            Name: null,
            States: null,
            Transitions: null,
            CurrentState: null
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Freezable.ctor.call(this);
                this.States = new (System.Windows.FreezableCollection$1(System.Windows.VisualState)).ctor();
                this.States.TrySetContextParent(this);

                this.Transitions = new (System.Windows.FreezableCollection$1(System.Windows.VisualTransition)).ctor();
                this.Transitions.TrySetContextParent(this);
            }
        },
        methods: {
            SetContainer: function (container) {
                if (this.container != null && !Bridge.referenceEquals(this.container, container)) {
                    throw new Granular.Exception("Can't change VisualStateGroup container");
                }

                this.container = container;
            },
            GoToState: function (state, useTransitions) {
                if (Bridge.referenceEquals(state, this.CurrentState)) {
                    return true;
                }

                var currentStateName = this.CurrentState != null ? this.CurrentState.Name : "";
                var transition = useTransitions ? System.Windows.VisualStateGroup.GetTransition(this.Transitions, currentStateName, state.Name) : null;
                var transitionStoryboard = transition != null ? transition.Storyboard : null;

                var storyboard;
                if (transitionStoryboard != null && state.Storyboard != null) {
                    // create a sequential animation with the transition storyboard first and then the state storyboard
                    var sequentialTimeline = new System.Windows.Media.Animation.SequentialTimeline();
                    sequentialTimeline.Children.add(transitionStoryboard);
                    sequentialTimeline.Children.add(state.Storyboard);

                    storyboard = new System.Windows.Media.Animation.Storyboard();
                    storyboard.Children.add(sequentialTimeline);
                } else {
                    storyboard = transitionStoryboard || state.Storyboard;
                }

                this.StartNewStoryboard(storyboard);

                this.CurrentState = state;
                return true;
            },
            StartNewStoryboard: function (newStoryboard) {
                if (newStoryboard != null) {
                    newStoryboard.Begin(this.container, System.Windows.NameScope.GetTemplateNameScope(this.container));

                    if (this.currentStoryboard != null) {
                        this.currentStoryboard.Stop(this.container);
                    }
                } else if (this.currentStoryboard != null) {
                    this.currentStoryboard.Remove(this.container);
                }

                this.currentStoryboard = newStoryboard;
            }
        }
    });

    Bridge.ns("System.Windows.VisualStateGroup", $asm.$);

    Bridge.apply($asm.$.System.Windows.VisualStateGroup, {
        f1: function (transition) {
            return Granular.Extensions.StringExtensions.IsNullOrEmpty(transition.From) && Granular.Extensions.StringExtensions.IsNullOrEmpty(transition.To);
        }
    });

    Bridge.define("System.Windows.VisualTransition", {
        inherits: [System.Windows.Freezable],
        statics: {
            fields: {
                StoryboardProperty: null
            },
            ctors: {
                init: function () {
                    this.StoryboardProperty = System.Windows.DependencyProperty.Register("Storyboard", System.Windows.Media.Animation.Storyboard, System.Windows.VisualTransition, new System.Windows.FrameworkPropertyMetadata.ctor());
                }
            }
        },
        props: {
            From: null,
            To: null,
            Storyboard: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.VisualTransition.StoryboardProperty), System.Windows.Media.Animation.Storyboard);
                },
                set: function (value) {
                    this.SetValue(System.Windows.VisualTransition.StoryboardProperty, value);
                }
            }
        }
    });

    Bridge.define("System.Windows.FrameworkElement", {
        inherits: [System.Windows.UIElement,System.Windows.IResourceContainer],
        statics: {
            fields: {
                InitializedEvent: null,
                HorizontalAlignmentProperty: null,
                VerticalAlignmentProperty: null,
                MarginProperty: null,
                WidthProperty: null,
                HeightProperty: null,
                MinWidthProperty: null,
                MinHeightProperty: null,
                MaxWidthProperty: null,
                MaxHeightProperty: null,
                ActualWidthPropertyKey: null,
                ActualWidthProperty: null,
                ActualHeightPropertyKey: null,
                ActualHeightProperty: null,
                StyleProperty: null,
                DefaultStyleKeyProperty: null,
                FocusVisualStyleProperty: null,
                DataContextProperty: null,
                CursorProperty: null,
                ForceCursorProperty: null,
                LayoutTransformProperty: null
            },
            ctors: {
                init: function () {
                    this.InitializedEvent = System.Windows.EventManager.RegisterRoutedEvent("Initialized", System.Windows.RoutingStrategy.Direct, Function, System.Windows.FrameworkElement);
                    this.HorizontalAlignmentProperty = System.Windows.DependencyProperty.Register("HorizontalAlignment", System.Windows.HorizontalAlignment, System.Windows.FrameworkElement, new System.Windows.FrameworkPropertyMetadata.$ctor3(Bridge.box(System.Windows.HorizontalAlignment.Stretch, System.Windows.HorizontalAlignment, System.Enum.toStringFn(System.Windows.HorizontalAlignment)), 3, $asm.$.System.Windows.FrameworkElement.f1));
                    this.VerticalAlignmentProperty = System.Windows.DependencyProperty.Register("VerticalAlignment", System.Windows.VerticalAlignment, System.Windows.FrameworkElement, new System.Windows.FrameworkPropertyMetadata.$ctor3(Bridge.box(System.Windows.VerticalAlignment.Stretch, System.Windows.VerticalAlignment, System.Enum.toStringFn(System.Windows.VerticalAlignment)), 3, $asm.$.System.Windows.FrameworkElement.f1));
                    this.MarginProperty = System.Windows.DependencyProperty.Register("Margin", System.Windows.Thickness, System.Windows.FrameworkElement, new System.Windows.FrameworkPropertyMetadata.$ctor2(System.Windows.Thickness.Zero, 3));
                    this.WidthProperty = System.Windows.DependencyProperty.Register("Width", System.Double, System.Windows.FrameworkElement, new System.Windows.FrameworkPropertyMetadata.$ctor3(Bridge.box(Number.NaN, System.Double, System.Double.format, System.Double.getHashCode), 3, $asm.$.System.Windows.FrameworkElement.f2));
                    this.HeightProperty = System.Windows.DependencyProperty.Register("Height", System.Double, System.Windows.FrameworkElement, new System.Windows.FrameworkPropertyMetadata.$ctor3(Bridge.box(Number.NaN, System.Double, System.Double.format, System.Double.getHashCode), 3, $asm.$.System.Windows.FrameworkElement.f2));
                    this.MinWidthProperty = System.Windows.DependencyProperty.Register("MinWidth", System.Double, System.Windows.FrameworkElement, new System.Windows.FrameworkPropertyMetadata.$ctor3(Bridge.box(0.0, System.Double, System.Double.format, System.Double.getHashCode), 3, $asm.$.System.Windows.FrameworkElement.f3));
                    this.MinHeightProperty = System.Windows.DependencyProperty.Register("MinHeight", System.Double, System.Windows.FrameworkElement, new System.Windows.FrameworkPropertyMetadata.$ctor3(Bridge.box(0.0, System.Double, System.Double.format, System.Double.getHashCode), 3, $asm.$.System.Windows.FrameworkElement.f3));
                    this.MaxWidthProperty = System.Windows.DependencyProperty.Register("MaxWidth", System.Double, System.Windows.FrameworkElement, new System.Windows.FrameworkPropertyMetadata.$ctor3(Bridge.box(Number.POSITIVE_INFINITY, System.Double, System.Double.format, System.Double.getHashCode), 3, $asm.$.System.Windows.FrameworkElement.f4));
                    this.MaxHeightProperty = System.Windows.DependencyProperty.Register("MaxHeight", System.Double, System.Windows.FrameworkElement, new System.Windows.FrameworkPropertyMetadata.$ctor3(Bridge.box(Number.POSITIVE_INFINITY, System.Double, System.Double.format, System.Double.getHashCode), 3, $asm.$.System.Windows.FrameworkElement.f4));
                    this.ActualWidthPropertyKey = System.Windows.DependencyProperty.RegisterReadOnly("ActualWidth", System.Double, System.Windows.FrameworkElement, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.ActualWidthProperty = System.Windows.FrameworkElement.ActualWidthPropertyKey.DependencyProperty;
                    this.ActualHeightPropertyKey = System.Windows.DependencyProperty.RegisterReadOnly("ActualHeight", System.Double, System.Windows.FrameworkElement, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.ActualHeightProperty = System.Windows.FrameworkElement.ActualHeightPropertyKey.DependencyProperty;
                    this.StyleProperty = System.Windows.DependencyProperty.Register("Style", System.Windows.Style, System.Windows.FrameworkElement, new System.Windows.FrameworkPropertyMetadata.$ctor9(System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure, $asm.$.System.Windows.FrameworkElement.f5));
                    this.DefaultStyleKeyProperty = System.Windows.DependencyProperty.Register("DefaultStyleKey", System.Object, System.Windows.FrameworkElement, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.FocusVisualStyleProperty = System.Windows.DependencyProperty.Register("FocusVisualStyle", System.Windows.Style, System.Windows.FrameworkElement, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.DataContextProperty = System.Windows.DependencyProperty.Register("DataContext", System.Object, System.Windows.FrameworkElement, new System.Windows.FrameworkPropertyMetadata.$ctor9(System.Windows.FrameworkPropertyMetadataOptions.Inherits, $asm.$.System.Windows.FrameworkElement.f6));
                    this.CursorProperty = System.Windows.DependencyProperty.Register("Cursor", System.Windows.Input.Cursor, System.Windows.FrameworkElement, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.FrameworkElement.f7));
                    this.ForceCursorProperty = System.Windows.DependencyProperty.Register("ForceCursor", System.Boolean, System.Windows.FrameworkElement, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.FrameworkElement.f7));
                    this.LayoutTransformProperty = System.Windows.DependencyProperty.Register("LayoutTransform", System.Windows.Media.Transform, System.Windows.FrameworkElement, new System.Windows.FrameworkPropertyMetadata.$ctor3(System.Windows.Media.Transform.Identity, 3, $asm.$.System.Windows.FrameworkElement.f8));
                }
            },
            methods: {
                GetAlignmentOffset: function (container, alignedRectSize, horizontalAlignment, verticalAlignment) {
                    var alignedLeft = container.Left;
                    var alignedTop = container.Top;

                    if (horizontalAlignment === System.Windows.HorizontalAlignment.Right) {
                        alignedLeft = container.Left + container.Width - alignedRectSize.Width;
                    }

                    if (horizontalAlignment === System.Windows.HorizontalAlignment.Center || horizontalAlignment === System.Windows.HorizontalAlignment.Stretch) {
                        alignedLeft = container.Left + (container.Width - alignedRectSize.Width) / 2;
                    }

                    if (verticalAlignment === System.Windows.VerticalAlignment.Bottom) {
                        alignedTop = container.Top + container.Height - alignedRectSize.Height;
                    }

                    if (verticalAlignment === System.Windows.VerticalAlignment.Center || verticalAlignment === System.Windows.VerticalAlignment.Stretch) {
                        alignedTop = container.Top + (container.Height - alignedRectSize.Height) / 2;
                    }

                    return alignedLeft === 0 && alignedTop === 0 ? System.Windows.Point.Zero : new System.Windows.Point.$ctor1(alignedLeft, alignedTop);
                }
            }
        },
        fields: {
            actualWidthValueEntry: null,
            actualHeightValueEntry: null,
            templateChild: null,
            resources: null,
            resourceInheritanceParent: null,
            appliedTemplate: null,
            layoutTransformValue: null,
            isDefaultAlignment: false
        },
        events: {
            ResourcesChanged: null,
            DataContextChanged: null
        },
        props: {
            HorizontalAlignment: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.FrameworkElement.HorizontalAlignmentProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.FrameworkElement.HorizontalAlignmentProperty, Bridge.box(value, System.Windows.HorizontalAlignment, System.Enum.toStringFn(System.Windows.HorizontalAlignment)));
                }
            },
            VerticalAlignment: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.FrameworkElement.VerticalAlignmentProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.FrameworkElement.VerticalAlignmentProperty, Bridge.box(value, System.Windows.VerticalAlignment, System.Enum.toStringFn(System.Windows.VerticalAlignment)));
                }
            },
            Margin: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.FrameworkElement.MarginProperty), System.Windows.Thickness);
                },
                set: function (value) {
                    this.SetValue(System.Windows.FrameworkElement.MarginProperty, value);
                }
            },
            Width: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.FrameworkElement.WidthProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.FrameworkElement.WidthProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            Height: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.FrameworkElement.HeightProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.FrameworkElement.HeightProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            MinWidth: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.FrameworkElement.MinWidthProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.FrameworkElement.MinWidthProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            MinHeight: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.FrameworkElement.MinHeightProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.FrameworkElement.MinHeightProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            MaxWidth: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.FrameworkElement.MaxWidthProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.FrameworkElement.MaxWidthProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            MaxHeight: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.FrameworkElement.MaxHeightProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.FrameworkElement.MaxHeightProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            ActualWidth: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue$1(System.Windows.FrameworkElement.ActualWidthPropertyKey)), System.Double));
                },
                set: function (value) {
                    System.Windows.DependencyPropertyValueEntryExtensions.SetBaseValue(this.actualWidthValueEntry, System.Windows.BaseValueSource.Local, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            ActualHeight: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue$1(System.Windows.FrameworkElement.ActualHeightPropertyKey)), System.Double));
                },
                set: function (value) {
                    System.Windows.DependencyPropertyValueEntryExtensions.SetBaseValue(this.actualHeightValueEntry, System.Windows.BaseValueSource.Local, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            ActualSize: null,
            Size: null,
            MinSize: null,
            MaxSize: null,
            IsInitialized: false,
            TemplatedParent: null,
            TemplateChild: {
                get: function () {
                    return this.templateChild;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.templateChild, value)) {
                        return;
                    }

                    if (this.templateChild != null) {
                        this.RemoveVisualChild(this.templateChild);
                    }

                    this.templateChild = value;

                    if (this.templateChild != null) {
                        this.AddVisualChild(this.templateChild);
                    }

                    this.InvalidateMeasure();

                    this.OnTemplateChildChanged();
                }
            },
            Style: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.FrameworkElement.StyleProperty), System.Windows.Style);
                },
                set: function (value) {
                    this.SetValue(System.Windows.FrameworkElement.StyleProperty, value);
                }
            },
            DefaultStyleKey: {
                get: function () {
                    return this.GetValue(System.Windows.FrameworkElement.DefaultStyleKeyProperty);
                },
                set: function (value) {
                    this.SetValue(System.Windows.FrameworkElement.DefaultStyleKeyProperty, value);
                }
            },
            FocusVisualStyle: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.FrameworkElement.FocusVisualStyleProperty), System.Windows.Style);
                },
                set: function (value) {
                    this.SetValue(System.Windows.FrameworkElement.FocusVisualStyleProperty, value);
                }
            },
            Resources: {
                get: function () {
                    return this.resources;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.resources, value)) {
                        return;
                    }

                    if (this.resources != null) {
                        this.resources.removeResourcesChanged(Bridge.fn.cacheBind(this, this.OnResourceDictionaryChanged));
                    }

                    this.resources = value;

                    if (this.resources != null) {
                        this.resources.addResourcesChanged(Bridge.fn.cacheBind(this, this.OnResourceDictionaryChanged));
                    }

                    this.RaiseResourcesChanged(System.Windows.ResourcesChangedEventArgs.Reset);
                }
            },
            ResourceInheritanceParent: {
                get: function () {
                    return this.resourceInheritanceParent;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.resourceInheritanceParent, value)) {
                        return;
                    }

                    var oldResourceInheritanceParent = this.resourceInheritanceParent;

                    if (this.resourceInheritanceParent != null) {
                        this.resourceInheritanceParent.System$Windows$IResourceContainer$removeResourcesChanged(Bridge.fn.cacheBind(this, this.OnParentResourcesChanged));
                    }

                    this.resourceInheritanceParent = value;

                    if (this.resourceInheritanceParent != null) {
                        this.resourceInheritanceParent.System$Windows$IResourceContainer$addResourcesChanged(Bridge.fn.cacheBind(this, this.OnParentResourcesChanged));
                    }

                    if (oldResourceInheritanceParent != null && !oldResourceInheritanceParent.System$Windows$IResourceContainer$IsEmpty || this.resourceInheritanceParent != null && !this.resourceInheritanceParent.System$Windows$IResourceContainer$IsEmpty) {
                        this.RaiseResourcesChanged(System.Windows.ResourcesChangedEventArgs.Reset);
                    }
                }
            },
            System$Windows$IResourceContainer$IsEmpty: {
                get: function () {
                    return (this.ResourceInheritanceParent == null || this.ResourceInheritanceParent.System$Windows$IResourceContainer$IsEmpty) && (this.Resources == null || this.Resources.IsEmpty);
                }
            },
            DataContext: {
                get: function () {
                    return this.GetValue(System.Windows.FrameworkElement.DataContextProperty);
                },
                set: function (value) {
                    this.SetValue(System.Windows.FrameworkElement.DataContextProperty, value);
                }
            },
            Cursor: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.FrameworkElement.CursorProperty), System.Windows.Input.Cursor);
                },
                set: function (value) {
                    this.SetValue(System.Windows.FrameworkElement.CursorProperty, value);
                }
            },
            ForceCursor: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.FrameworkElement.ForceCursorProperty)), System.Boolean));
                },
                set: function (value) {
                    this.SetValue(System.Windows.FrameworkElement.ForceCursorProperty, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            },
            LayoutTransform: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.FrameworkElement.LayoutTransformProperty), System.Windows.Media.Transform);
                },
                set: function (value) {
                    this.SetValue(System.Windows.FrameworkElement.LayoutTransformProperty, value);
                }
            },
            Triggers: null,
            Name: null
        },
        alias: [
            "addResourcesChanged", "System$Windows$IResourceContainer$addResourcesChanged",
            "removeResourcesChanged", "System$Windows$IResourceContainer$removeResourcesChanged",
            "TryGetResource", "System$Windows$IResourceContainer$TryGetResource"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.UIElement.ctor.call(this);
                this.Triggers = new (Granular.Collections.ObservableCollection$1(System.Windows.ITrigger)).ctor();
                this.Triggers.addCollectionChanged(Bridge.fn.cacheBind(this, this.OnTriggersCollectionChanged));

                this.actualWidthValueEntry = this.GetValueEntry$1(System.Windows.FrameworkElement.ActualWidthPropertyKey);
                this.actualHeightValueEntry = this.GetValueEntry$1(System.Windows.FrameworkElement.ActualHeightPropertyKey);

                this.ActualSize = System.Windows.Size.Empty;
                this.Size = System.Windows.Size.Empty;
                this.MinSize = System.Windows.Size.Zero;
                this.MaxSize = System.Windows.Size.Infinity;

                this.isDefaultAlignment = true;
            }
        },
        methods: {
            addInitialized: function (value) {
                this.AddHandler(System.Windows.FrameworkElement.InitializedEvent, value);
            },
            removeInitialized: function (value) {
                this.RemoveHandler(System.Windows.FrameworkElement.InitializedEvent, value);
            },
            toString: function () {
                return Granular.Extensions.StringExtensions.IsNullOrEmpty(this.Name) ? System.String.format("{0}", Bridge.Reflection.getTypeName(Bridge.getType(this))) : System.String.format("{0} ({1})", Bridge.Reflection.getTypeName(Bridge.getType(this)), this.Name);
            },
            OnPropertyChanged: function (e) {
                System.Windows.UIElement.prototype.OnPropertyChanged.call(this, e);

                var metadata = Bridge.as(e.Property.GetMetadata(Bridge.getType(this)), System.Windows.FrameworkPropertyMetadata);

                if (metadata != null) {
                    if (metadata.AffectsMeasure) {
                        this.InvalidateMeasure();
                    }

                    if (metadata.AffectsArrange) {
                        this.InvalidateArrange();
                    }

                    if (metadata.AffectsRender) {
                        this.InvalidateVisual();
                    }

                    if (metadata.AffectsParentMeasure && this.VisualParent != null) {
                        Bridge.cast(this.VisualParent, System.Windows.UIElement).InvalidateMeasure();
                    }

                    if (metadata.AffectsParentArrange && this.VisualParent != null) {
                        Bridge.cast(this.VisualParent, System.Windows.UIElement).InvalidateArrange();
                    }
                }

                if (!e.IsSubPropertyChange) {
                    var baseValueSource = this.GetBaseValueSource(e.Property);
                    if (baseValueSource !== System.Windows.BaseValueSource.Default && baseValueSource !== System.Windows.BaseValueSource.Inherited) {
                        if (Bridge.is(e.OldValue, System.Windows.IContextElement)) {
                            Bridge.cast(e.OldValue, System.Windows.IContextElement).System$Windows$IContextElement$TrySetContextParent(null);
                        }

                        if (Bridge.is(e.NewValue, System.Windows.IContextElement)) {
                            Bridge.cast(e.NewValue, System.Windows.IContextElement).System$Windows$IContextElement$TrySetContextParent(this);
                        }
                    }
                }
            },
            MeasureCore: function (availableSize) {
                availableSize = System.Windows.Size.op_Subtraction(availableSize, this.Margin.Size);

                if (!System.Windows.Media.MatrixExtensions.IsNullOrIdentity(this.layoutTransformValue)) {
                    availableSize = System.Windows.Media.MatrixExtensions.GetContainedSize(this.layoutTransformValue, availableSize);
                }

                availableSize = System.Windows.SizeExtensions.Bounds(System.Windows.SizeExtensions.Combine(this.Size, availableSize), this.MinSize, this.MaxSize);

                var measuredSize = this.MeasureOverride(availableSize);

                measuredSize = System.Windows.SizeExtensions.Bounds(System.Windows.SizeExtensions.Combine(this.Size, measuredSize), this.MinSize, this.MaxSize);

                if (!System.Windows.Media.MatrixExtensions.IsNullOrIdentity(this.layoutTransformValue)) {
                    measuredSize = System.Windows.Media.MatrixExtensions.GetContainingSize(this.layoutTransformValue, measuredSize);
                }

                measuredSize = System.Windows.Size.op_Addition(measuredSize, this.Margin.Size);

                return measuredSize;
            },
            MeasureOverride: function (availableSize) {
                return System.Windows.Size.Zero;
            },
            ArrangeCore: function (finalRect) {
                var finalSize = this.isDefaultAlignment ? finalRect.Size : new System.Windows.Size(this.HorizontalAlignment !== System.Windows.HorizontalAlignment.Stretch ? Granular.Extensions.DoubleExtensions.Min(this.DesiredSize.Width, finalRect.Width) : finalRect.Width, this.VerticalAlignment !== System.Windows.VerticalAlignment.Stretch ? Granular.Extensions.DoubleExtensions.Min(this.DesiredSize.Height, finalRect.Height) : finalRect.Height);

                finalSize = System.Windows.Size.op_Subtraction(finalSize, this.Margin.Size);

                if (!System.Windows.Media.MatrixExtensions.IsNullOrIdentity(this.layoutTransformValue)) {
                    finalSize = System.Windows.Media.MatrixExtensions.GetContainedSize(this.layoutTransformValue, finalSize);
                }

                finalSize = System.Windows.SizeExtensions.Bounds(System.Windows.SizeExtensions.Combine(this.Size, finalSize), this.MinSize, this.MaxSize);

                var arrangedSize = this.ArrangeOverride(finalSize);

                var containingRect = new System.Windows.Rect.$ctor3(arrangedSize);

                if (!System.Windows.Media.MatrixExtensions.IsNullOrIdentity(this.layoutTransformValue)) {
                    containingRect = System.Windows.Media.MatrixExtensions.GetContainingRect(this.layoutTransformValue, containingRect);
                }

                containingRect = System.Windows.RectExtensions.AddMargin(containingRect, this.Margin);

                var alignedOffset = System.Windows.FrameworkElement.GetAlignmentOffset(finalRect, containingRect.Size, this.HorizontalAlignment, this.VerticalAlignment);

                var visualOffset = System.Windows.Point.op_Subtraction(alignedOffset, containingRect.Location);

                this.VisualBounds = new System.Windows.Rect.$ctor2(visualOffset, arrangedSize);

                this.ActualWidth = arrangedSize.Width;
                this.ActualHeight = arrangedSize.Height;
                this.ActualSize = arrangedSize;
            },
            ArrangeOverride: function (finalSize) {
                return finalSize;
            },
            GetTemplate: function () {
                return null;
            },
            ApplyTemplate: function () {
                var template = this.GetTemplate();

                if (Bridge.referenceEquals(this.appliedTemplate, template)) {
                    return false;
                }

                if (this.appliedTemplate != null) {
                    this.appliedTemplate.System$Windows$IFrameworkTemplate$Detach(this);
                }

                this.appliedTemplate = template;

                if (this.appliedTemplate != null) {
                    this.appliedTemplate.System$Windows$IFrameworkTemplate$Attach(this);
                }

                this.OnApplyTemplate();

                return true;
            },
            OnApplyTemplate: function () {
                //
            },
            OnVisualParentChanged: function (oldVisualParent, newVisualParent) {
                System.Windows.UIElement.prototype.OnVisualParentChanged.call(this, oldVisualParent, newVisualParent);

                this.Initialize();
                this.ResourceInheritanceParent = Bridge.as((this.LogicalParent || this.VisualParent), System.Windows.FrameworkElement);
            },
            OnLogicalParentChanged: function (oldLogicalParent, newLogicalParent) {
                this.ResourceInheritanceParent = Bridge.as((this.LogicalParent || this.VisualParent), System.Windows.FrameworkElement);
            },
            Initialize: function () {
                if (this.IsInitialized) {
                    return;
                }

                this.IsInitialized = true;

                this.OnInitialized({ });
                this.RaiseEvent(new System.Windows.RoutedEventArgs(System.Windows.FrameworkElement.InitializedEvent, this));
            },
            OnInitialized: function (e) {
                //
            },
            OnStyleChanged: function (e) {
                if (e.OldValue != null) {
                    (Bridge.as(e.OldValue, System.Windows.Style)).Detach(this);
                }

                if (e.NewValue != null) {
                    (Bridge.as(e.NewValue, System.Windows.Style)).Attach(this);
                }
            },
            TryGetResource: function (resourceKey, value) {
                if ((this.Resources == null || !this.Resources.tryGetValue(resourceKey, value)) && (this.ResourceInheritanceParent == null || !this.ResourceInheritanceParent.System$Windows$IResourceContainer$TryGetResource(resourceKey, value))) {
                    value.v = null;
                    return false;
                }

                return true;
            },
            OnParentResourcesChanged: function (sender, e) {
                this.RaiseResourcesChanged(e);
            },
            OnResourceDictionaryChanged: function (sender, e) {
                this.RaiseResourcesChanged(e);
            },
            RaiseResourcesChanged: function (e) {
                this.OnResourcesChanged(e);
                Granular.Extensions.EventHandlerExtensions.Raise$4(Bridge.global.System.Windows.ResourcesChangedEventArgs, this.ResourcesChanged, this, e);
            },
            OnResourcesChanged: function (e) {
                if (this.DefaultStyleKey == null || !e.Contains(this.DefaultStyleKey)) {
                    return;
                }

                var value = { };
                if (!this.TryGetResource(this.DefaultStyleKey, value)) {
                    value.v = null;
                }

                this.SetValue(System.Windows.FrameworkElement.StyleProperty, value.v, System.Windows.BaseValueSource.Default);
            },
            SetResourceInheritanceParent: function (parent) {
                this.ResourceInheritanceParent = parent;
            },
            OnTemplateChildChanged: function () {
                //
            },
            OnTriggersCollectionChanged: function (sender, e) {
                var $t, $t1;
                $t = Bridge.getEnumerator(e.OldItems, System.Object);
                try {
                    while ($t.moveNext()) {
                        var trigger = Bridge.cast($t.Current, System.Windows.ITrigger);
                        trigger.System$Windows$ITrigger$Detach(this, System.Windows.BaseValueSource.Local);

                        if (Bridge.is(trigger, System.Windows.IContextElement)) {
                            Bridge.cast(trigger, System.Windows.IContextElement).System$Windows$IContextElement$TrySetContextParent(null);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                $t1 = Bridge.getEnumerator(e.NewItems, System.Object);
                try {
                    while ($t1.moveNext()) {
                        var trigger1 = Bridge.cast($t1.Current, System.Windows.ITrigger);
                        if (Bridge.is(trigger1, System.Windows.IContextElement)) {
                            Bridge.cast(trigger1, System.Windows.IContextElement).System$Windows$IContextElement$TrySetContextParent(this);
                        }

                        trigger1.System$Windows$ITrigger$Attach(this, System.Windows.BaseValueSource.Local);
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$dispose();
                    }
                }},
            OnDataContextChanged: function (e) {
                System.Windows.DependencyPropertyChangedEventHandlerExtensions.Raise(this.DataContextChanged, this, e);
            },
            UpdateCursor: function () {
                if (this.IsMouseOver) {
                    System.Windows.ApplicationHostExtensions.GetMouseDeviceFromElement(System.Windows.ApplicationHost.Current, this).UpdateCursor();
                }
            },
            OnQueryCursor: function (e) {
                if (this.Cursor != null && (this.ForceCursor || !e.Handled)) {
                    e.Cursor = this.Cursor;
                    e.Handled = true;
                }
            },
            OnLayoutTransformChanged: function (e) {
                var newLayoutTransform = Bridge.cast(e.NewValue, System.Windows.Media.Transform);
                this.layoutTransformValue = System.Windows.Media.TransformExtensions.IsNullOrIdentity(newLayoutTransform) ? null : newLayoutTransform.Value;
                this.InvalidateVisualTransform();
            },
            OnAlignmentChanged: function (e) {
                this.isDefaultAlignment = this.HorizontalAlignment === System.Windows.HorizontalAlignment.Stretch && this.VerticalAlignment === System.Windows.VerticalAlignment.Stretch;
            },
            GetVisualTransformOverride: function () {
                if (System.Windows.Media.MatrixExtensions.IsNullOrIdentity(this.layoutTransformValue)) {
                    return System.Windows.UIElement.prototype.GetVisualTransformOverride.call(this);
                }

                return System.Windows.Media.Matrix.op_Multiply(this.layoutTransformValue, System.Windows.UIElement.prototype.GetVisualTransformOverride.call(this));
            },
            SetSize: function () {
                this.Size = new System.Windows.Size(this.Width, this.Height);
            },
            SetMinSize: function () {
                this.MinSize = new System.Windows.Size(this.MinWidth, this.MinHeight);
            },
            SetMaxSize: function () {
                this.MaxSize = new System.Windows.Size(this.MaxWidth, this.MaxHeight);
            }
        }
    });

    Bridge.ns("System.Windows.FrameworkElement", $asm.$);

    Bridge.apply($asm.$.System.Windows.FrameworkElement, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.FrameworkElement).OnAlignmentChanged(e);
        },
        f2: function (sender, e) {
            Bridge.cast(sender, System.Windows.FrameworkElement).SetSize();
        },
        f3: function (sender, e) {
            Bridge.cast(sender, System.Windows.FrameworkElement).SetMinSize();
        },
        f4: function (sender, e) {
            Bridge.cast(sender, System.Windows.FrameworkElement).SetMaxSize();
        },
        f5: function (sender, e) {
            (Bridge.as(sender, System.Windows.FrameworkElement)).OnStyleChanged(e);
        },
        f6: function (sender, e) {
            Bridge.cast(sender, System.Windows.FrameworkElement).OnDataContextChanged(e);
        },
        f7: function (sender, e) {
            Bridge.cast(sender, System.Windows.FrameworkElement).UpdateCursor();
        },
        f8: function (sender, e) {
            Bridge.cast(sender, System.Windows.FrameworkElement).OnLayoutTransformChanged(e);
        }
    });

    Bridge.define("System.Windows.Controls.UIElementCollection", {
        inherits: [System.Collections.Generic.IList$1(System.Windows.UIElement),Granular.Collections.INotifyCollectionChanged],
        fields: {
            parent: null,
            children: null
        },
        events: {
            CollectionChanged: null
        },
        props: {
            Count: {
                get: function () {
                    return this.children.Count;
                }
            },
            IsReadOnly: {
                get: function () {
                    return false;
                }
            }
        },
        alias: [
            "addCollectionChanged", "Granular$Collections$INotifyCollectionChanged$addCollectionChanged",
            "removeCollectionChanged", "Granular$Collections$INotifyCollectionChanged$removeCollectionChanged",
            "Count", "System$Collections$Generic$ICollection$1$System$Windows$UIElement$Count",
            "getItem", "System$Collections$Generic$IList$1$System$Windows$UIElement$getItem",
            "setItem", "System$Collections$Generic$IList$1$System$Windows$UIElement$setItem",
            "IsReadOnly", "System$Collections$Generic$ICollection$1$System$Windows$UIElement$IsReadOnly",
            "add", "System$Collections$Generic$ICollection$1$System$Windows$UIElement$add",
            "clear", "System$Collections$Generic$ICollection$1$System$Windows$UIElement$clear",
            "contains", "System$Collections$Generic$ICollection$1$System$Windows$UIElement$contains",
            "indexOf", "System$Collections$Generic$IList$1$System$Windows$UIElement$indexOf",
            "insert", "System$Collections$Generic$IList$1$System$Windows$UIElement$insert",
            "remove", "System$Collections$Generic$ICollection$1$System$Windows$UIElement$remove",
            "removeAt", "System$Collections$Generic$IList$1$System$Windows$UIElement$removeAt",
            "copyTo", "System$Collections$Generic$ICollection$1$System$Windows$UIElement$copyTo",
            "getEnumerator", ["System$Collections$Generic$IEnumerable$1$System$Windows$UIElement$getEnumerator", "System$Collections$Generic$IEnumerable$1$getEnumerator"]
        ],
        ctors: {
            ctor: function (parent) {
                this.$initialize();
                this.parent = parent;
                this.children = new (System.Collections.Generic.List$1(System.Windows.UIElement)).ctor();
            }
        },
        methods: {
            getItem: function (index) {
                return this.children.getItem(index);
            },
            setItem: function (index, value) {
                if (Bridge.referenceEquals(this.children.getItem(index), value)) {
                    return;
                }

                var args = Granular.Collections.NotifyCollectionChangedEventArgs.Replace(this.children.getItem(index), value, index);

                if (this.children.getItem(index) != null) {
                    this.ClearChildParent(this.children.getItem(index));
                }

                this.children.setItem(index, value);

                if (this.children.getItem(index) != null) {
                    this.SetChildParent(this.children.getItem(index));
                }

                Granular.Collections.NotifyCollectionChangedEventHandlerExtensions.Raise(this.CollectionChanged, this, args);
            },
            add: function (item) {
                this.children.add(item);
                this.SetChildParent(item);

                Granular.Collections.NotifyCollectionChangedEventHandlerExtensions.Raise(this.CollectionChanged, this, Granular.Collections.NotifyCollectionChangedEventArgs.Add(item, this.children.Count));
            },
            clear: function () {
                var $t;
                var lastChildren = this.children.toArray();
                this.children.clear();

                $t = Bridge.getEnumerator(lastChildren, System.Windows.UIElement);
                try {
                    while ($t.moveNext()) {
                        var child = $t.Current;
                        this.ClearChildParent(child);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                Granular.Collections.NotifyCollectionChangedEventHandlerExtensions.Raise(this.CollectionChanged, this, Granular.Collections.NotifyCollectionChangedEventArgs.RemoveRange(lastChildren, 0));
            },
            contains: function (item) {
                return this.children.contains(item);
            },
            indexOf: function (item) {
                return this.children.indexOf(item);
            },
            insert: function (index, item) {
                this.children.insert(index, item);
                this.SetChildParent(item);

                Granular.Collections.NotifyCollectionChangedEventHandlerExtensions.Raise(this.CollectionChanged, this, Granular.Collections.NotifyCollectionChangedEventArgs.Add(item, index));
            },
            remove: function (item) {
                var index = this.children.indexOf(item);
                if (index === -1) {
                    return false;
                }

                var result = this.children.remove(item);
                this.ClearChildParent(item);

                Granular.Collections.NotifyCollectionChangedEventHandlerExtensions.Raise(this.CollectionChanged, this, Granular.Collections.NotifyCollectionChangedEventArgs.Remove(item, index));

                return result;
            },
            removeAt: function (index) {
                this.remove(this.children.getItem(index));
            },
            copyTo: function (array, arrayIndex) {
                this.children.copyTo(array, arrayIndex);
            },
            ClearChildParent: function (child) {
                this.parent.RemoveLogicalChild(child);
                this.parent.RemoveVisualChild(child);
            },
            SetChildParent: function (child) {
                this.parent.AddLogicalChild(child);
                this.parent.AddVisualChild(child);
            },
            getEnumerator: function () {
                return this.children.getEnumerator().$clone();
            },
            System$Collections$IEnumerable$getEnumerator: function () {
                return this.getEnumerator();
            }
        }
    });

    Bridge.define("System.Windows.DataTriggerBase", {
        inherits: [System.Windows.TriggerBase,System.Windows.IDataTriggerConditionProvider],
        fields: {
            attachedConditions: null
        },
        alias: [
            "Attach", "System$Windows$ITrigger$Attach",
            "Detach", "System$Windows$ITrigger$Detach"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.TriggerBase.ctor.call(this);
                this.attachedConditions = new (System.Collections.Generic.Dictionary$2(System.Windows.FrameworkElement,System.Windows.IDataTriggerCondition))();
            }
        },
        methods: {
            Attach: function (element, valueSource) {
                var condition = this.CreateDataTriggerCondition(element);

                condition.System$Windows$IDataTriggerCondition$addIsMatchedChanged(Bridge.fn.bind(this, function (sender, e) {
                    this.OnConditionIsMatchedChanged(element, valueSource, condition.System$Windows$IDataTriggerCondition$IsMatched);
                }));

                if (condition.System$Windows$IDataTriggerCondition$IsMatched) {
                    this.Apply(element, valueSource);
                }

                this.attachedConditions.add(element, condition);
            },
            Detach: function (element, valueSource) {
                var condition = this.attachedConditions.get(element);

                if (condition.System$Windows$IDataTriggerCondition$IsMatched) {
                    this.Clean(element, valueSource);
                }

                if (Bridge.is(condition, System.IDisposable)) {
                    Bridge.cast(condition, System.IDisposable).System$IDisposable$dispose();
                }

                this.attachedConditions.remove(element);
            },
            OnConditionIsMatchedChanged: function (element, valueSource, isMatched) {
                if (isMatched) {
                    this.Apply(element, valueSource);
                } else {
                    this.Clean(element, valueSource);
                }
            },
            Apply: function (element, valueSource) {
                var $t;
                $t = Bridge.getEnumerator(this.TriggerActions, System.Windows.ITriggerAction);
                try {
                    while ($t.moveNext()) {
                        var action = $t.Current;
                        action.System$Windows$ITriggerAction$Apply(element, valueSource);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }},
            Clean: function (element, valueSource) {
                var $t;
                $t = Bridge.getEnumerator(this.TriggerActions, System.Windows.ITriggerAction);
                try {
                    while ($t.moveNext()) {
                        var action = $t.Current;
                        action.System$Windows$ITriggerAction$Clean(element, valueSource);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }}
        }
    });

    Bridge.define("System.Windows.Media.Transform", {
        inherits: [System.Windows.Media.Animation.Animatable],
        statics: {
            fields: {
                Identity: null
            },
            ctors: {
                init: function () {
                    this.Identity = System.Windows.Media.Transform.CreateIdentityTransform();
                }
            },
            methods: {
                CreateIdentityTransform: function () {
                    var identityTransform = new System.Windows.Media.Transform.IdentityTransform();
                    identityTransform.Freeze();
                    return identityTransform;
                }
            }
        },
        fields: {
            renderResource: null
        },
        methods: {
            GetRenderResource: function (factory) {
                if (this.renderResource == null) {
                    this.renderResource = factory.System$Windows$Media$IRenderElementFactory$CreateTransformRenderResource();
                    this.renderResource.System$Windows$Media$ITransformRenderResource$Matrix = this.Value;
                }

                return this.renderResource;
            },
            InvalidateRenderResource: function () {
                if (this.renderResource != null) {
                    this.renderResource.System$Windows$Media$ITransformRenderResource$Matrix = this.Value;
                }
            }
        }
    });

    Bridge.define("System.Windows.Documents.TextElement", {
        inherits: [System.Windows.FrameworkContentElement],
        statics: {
            fields: {
                BackgroundProperty: null,
                ForegroundProperty: null,
                FontFamilyProperty: null,
                FontSizeProperty: null,
                FontStyleProperty: null,
                FontWeightProperty: null,
                FontStretchProperty: null
            },
            ctors: {
                init: function () {
                    this.BackgroundProperty = System.Windows.Controls.Panel.BackgroundProperty.AddOwner(System.Windows.Documents.TextElement);
                    this.ForegroundProperty = System.Windows.DependencyProperty.RegisterAttached("Foreground", System.Windows.Media.Brush, System.Windows.Documents.TextElement, new System.Windows.FrameworkPropertyMetadata.$ctor2(System.Windows.Media.Brushes.Black, System.Windows.FrameworkPropertyMetadataOptions.Inherits));
                    this.FontFamilyProperty = System.Windows.DependencyProperty.RegisterAttached("FontFamily", System.Windows.Media.FontFamily, System.Windows.Documents.TextElement, new System.Windows.FrameworkPropertyMetadata.$ctor2(System.Windows.Media.FontFamily.Default, System.Windows.FrameworkPropertyMetadataOptions.Inherits));
                    this.FontSizeProperty = System.Windows.DependencyProperty.RegisterAttached("FontSize", System.Double, System.Windows.Documents.TextElement, new System.Windows.FrameworkPropertyMetadata.$ctor2(Bridge.box(11.0, System.Double, System.Double.format, System.Double.getHashCode), System.Windows.FrameworkPropertyMetadataOptions.Inherits));
                    this.FontStyleProperty = System.Windows.DependencyProperty.RegisterAttached("FontStyle", System.Windows.FontStyle, System.Windows.Documents.TextElement, new System.Windows.FrameworkPropertyMetadata.$ctor8(System.Windows.FrameworkPropertyMetadataOptions.Inherits));
                    this.FontWeightProperty = System.Windows.DependencyProperty.RegisterAttached("FontWeight", System.Windows.FontWeight, System.Windows.Documents.TextElement, new System.Windows.FrameworkPropertyMetadata.$ctor8(System.Windows.FrameworkPropertyMetadataOptions.Inherits));
                    this.FontStretchProperty = System.Windows.DependencyProperty.RegisterAttached("FontStretch", System.Windows.FontStretch, System.Windows.Documents.TextElement, new System.Windows.FrameworkPropertyMetadata.$ctor8(System.Windows.FrameworkPropertyMetadataOptions.Inherits));
                }
            }
        },
        props: {
            Background: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Documents.TextElement.BackgroundProperty), System.Windows.Media.Brush);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Documents.TextElement.BackgroundProperty, value);
                }
            },
            Foreground: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Documents.TextElement.ForegroundProperty), System.Windows.Media.Brush);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Documents.TextElement.ForegroundProperty, value);
                }
            },
            FontFamily: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Documents.TextElement.FontFamilyProperty), System.Windows.Media.FontFamily);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Documents.TextElement.FontFamilyProperty, value);
                }
            },
            FontSize: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Documents.TextElement.FontSizeProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Documents.TextElement.FontSizeProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            FontStyle: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Documents.TextElement.FontStyleProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Documents.TextElement.FontStyleProperty, Bridge.box(value, System.Windows.FontStyle, System.Enum.toStringFn(System.Windows.FontStyle)));
                }
            },
            FontWeight: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Documents.TextElement.FontWeightProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Documents.TextElement.FontWeightProperty, Bridge.box(value, System.Windows.FontWeight, System.Enum.toStringFn(System.Windows.FontWeight)));
                }
            },
            FontStretch: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Documents.TextElement.FontStretchProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Documents.TextElement.FontStretchProperty, Bridge.box(value, System.Windows.FontStretch, System.Enum.toStringFn(System.Windows.FontStretch)));
                }
            }
        }
    });

    Bridge.define("System.Windows.EventTriggerBase", {
        inherits: [System.Windows.TriggerBase],
        fields: {
            attachedConditions: null
        },
        alias: [
            "Attach", "System$Windows$ITrigger$Attach",
            "Detach", "System$Windows$ITrigger$Detach"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.TriggerBase.ctor.call(this);
                this.attachedConditions = new (System.Collections.Generic.Dictionary$2(System.Windows.FrameworkElement,System.Windows.IEventTriggerCondition))();
            }
        },
        methods: {
            Attach: function (element, valueSource) {
                var condition = this.CreateEventTriggerCondition(element);

                condition.System$Windows$IEventTriggerCondition$addEventRaised(Bridge.fn.bind(this, function (sender, e) {
                    this.Apply(element, valueSource);
                }));

                this.attachedConditions.add(element, condition);
            },
            Detach: function (element, valueSource) {
                var condition = this.attachedConditions.get(element);

                this.Clean(element, valueSource);

                if (Bridge.is(condition, System.IDisposable)) {
                    Bridge.cast(condition, System.IDisposable).System$IDisposable$dispose();
                }

                this.attachedConditions.remove(element);
            },
            Apply: function (element, valueSource) {
                var $t;
                $t = Bridge.getEnumerator(this.TriggerActions, System.Windows.ITriggerAction);
                try {
                    while ($t.moveNext()) {
                        var action = $t.Current;
                        action.System$Windows$ITriggerAction$Apply(element, valueSource);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }},
            Clean: function (element, valueSource) {
                var $t;
                $t = Bridge.getEnumerator(this.TriggerActions, System.Windows.ITriggerAction);
                try {
                    while ($t.moveNext()) {
                        var action = $t.Current;
                        action.System$Windows$ITriggerAction$Clean(element, valueSource);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }}
        }
    });

    Bridge.define("System.Windows.Input.KeyboardFocusChangedEventArgs", {
        inherits: [System.Windows.Input.KeyboardEventArgs],
        props: {
            OldFocus: null,
            NewFocus: null
        },
        ctors: {
            ctor: function (routedEvent, originalSource, keyboardDevice, timestamp, oldFocus, newFocus) {
                this.$initialize();
                System.Windows.Input.KeyboardEventArgs.ctor.call(this, routedEvent, originalSource, keyboardDevice, timestamp);
                this.OldFocus = oldFocus;
                this.NewFocus = newFocus;
            }
        },
        methods: {
            InvokeEventHandler: function (handler, target) {
                if (Bridge.is(handler, Function)) {
                    handler(target, this);
                } else {
                    System.Windows.Input.KeyboardEventArgs.prototype.InvokeEventHandler.call(this, handler, target);
                }
            }
        }
    });

    Bridge.define("System.Windows.Input.KeyEventArgs", {
        inherits: [System.Windows.Input.KeyboardEventArgs],
        props: {
            Key: 0,
            KeyStates: 0,
            IsUp: {
                get: function () {
                    return this.KeyStates === System.Windows.Input.KeyStates.None;
                }
            },
            IsDown: {
                get: function () {
                    return this.KeyStates === System.Windows.Input.KeyStates.Down;
                }
            },
            IsRepeat: false,
            ForceHostHandling: false
        },
        ctors: {
            ctor: function (routedEvent, originalSource, keyboardDevice, timestamp, key, keyStates, isRepeat) {
                this.$initialize();
                System.Windows.Input.KeyboardEventArgs.ctor.call(this, routedEvent, originalSource, keyboardDevice, timestamp);
                this.Key = key;
                this.KeyStates = keyStates;
                this.IsRepeat = isRepeat;
            }
        },
        methods: {
            InvokeEventHandler: function (handler, target) {
                if (Bridge.is(handler, Function)) {
                    handler(target, this);
                } else {
                    System.Windows.Input.KeyboardEventArgs.prototype.InvokeEventHandler.call(this, handler, target);
                }
            }
        }
    });

    Bridge.define("System.Windows.Input.MouseButtonEventArgs", {
        inherits: [System.Windows.Input.MouseEventArgs],
        props: {
            ChangedButton: 0,
            ButtonState: 0,
            ClickCount: 0
        },
        ctors: {
            ctor: function (routedEvent, originalSource, mouseDevice, timestamp, absolutePosition, changedButton, buttonState, clickCount) {
                this.$initialize();
                System.Windows.Input.MouseEventArgs.ctor.call(this, routedEvent, originalSource, mouseDevice, timestamp, absolutePosition);
                this.ChangedButton = changedButton;
                this.ButtonState = buttonState;
                this.ClickCount = clickCount;
            }
        },
        methods: {
            InvokeEventHandler: function (handler, target) {
                if (Bridge.is(handler, Function)) {
                    handler(target, this);
                } else {
                    System.Windows.Input.MouseEventArgs.prototype.InvokeEventHandler.call(this, handler, target);
                }
            }
        }
    });

    Bridge.define("System.Windows.Input.MouseWheelEventArgs", {
        inherits: [System.Windows.Input.MouseEventArgs],
        props: {
            Delta: 0
        },
        ctors: {
            ctor: function (routedEvent, originalSource, mouseDevice, timestamp, absolutePosition, delta) {
                this.$initialize();
                System.Windows.Input.MouseEventArgs.ctor.call(this, routedEvent, originalSource, mouseDevice, timestamp, absolutePosition);
                this.Delta = delta;
            }
        },
        methods: {
            InvokeEventHandler: function (handler, target) {
                if (Bridge.is(handler, Function)) {
                    handler(target, this);
                } else {
                    System.Windows.Input.MouseEventArgs.prototype.InvokeEventHandler.call(this, handler, target);
                }
            }
        }
    });

    Bridge.define("System.Windows.Input.QueryCursorEventArgs", {
        inherits: [System.Windows.Input.MouseEventArgs],
        props: {
            Cursor: null
        },
        ctors: {
            ctor: function (routedEvent, originalSource, mouseDevice, timestamp, absolutePosition) {
                this.$initialize();
                System.Windows.Input.MouseEventArgs.ctor.call(this, routedEvent, originalSource, mouseDevice, timestamp, absolutePosition);
                //
            }
        },
        methods: {
            InvokeEventHandler: function (handler, target) {
                if (Bridge.is(handler, Function)) {
                    handler(target, this);
                } else {
                    System.Windows.Input.MouseEventArgs.prototype.InvokeEventHandler.call(this, handler, target);
                }
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.AnimationTimeline", {
        inherits: [System.Windows.Media.Animation.Timeline],
        statics: {
            fields: {
                IsAdditiveProperty: null,
                IsCumulativeProperty: null
            },
            ctors: {
                init: function () {
                    this.IsAdditiveProperty = System.Windows.DependencyProperty.Register("IsAdditive", System.Boolean, System.Windows.Media.Animation.AnimationTimeline, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.IsCumulativeProperty = System.Windows.DependencyProperty.Register("IsCumulative", System.Boolean, System.Windows.Media.Animation.AnimationTimeline, new System.Windows.FrameworkPropertyMetadata.ctor());
                }
            }
        },
        props: {
            IsAdditive: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.Animation.AnimationTimeline.IsAdditiveProperty)), System.Boolean));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Animation.AnimationTimeline.IsAdditiveProperty, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            },
            IsCumulative: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.Animation.AnimationTimeline.IsCumulativeProperty)), System.Boolean));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Animation.AnimationTimeline.IsCumulativeProperty, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            }
        },
        methods: {
            CreateClock: function () {
                return new System.Windows.Media.Animation.AnimationTimelineClock(this);
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.BackEase", {
        inherits: [System.Windows.Media.Animation.EasingFunctionBase],
        statics: {
            fields: {
                AmplitudeProperty: null
            },
            ctors: {
                init: function () {
                    this.AmplitudeProperty = System.Windows.DependencyProperty.Register("Amplitude", System.Double, System.Windows.Media.Animation.BackEase, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(1.0, System.Double, System.Double.format, System.Double.getHashCode)));
                }
            }
        },
        props: {
            Amplitude: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.Animation.BackEase.AmplitudeProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Animation.BackEase.AmplitudeProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            }
        },
        methods: {
            EaseOverride: function (normalizedTime) {
                return Math.pow(normalizedTime, 3.0) - normalizedTime * Granular.Extensions.DoubleExtensions.Max(this.Amplitude, 0) * Math.sin(Math.PI * normalizedTime);
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.CircleEase", {
        inherits: [System.Windows.Media.Animation.EasingFunctionBase],
        methods: {
            EaseOverride: function (normalizedTime) {
                normalizedTime = Granular.Extensions.DoubleExtensions.Bounds(normalizedTime, 0, 1);
                return 1.0 - Math.sqrt(1.0 - normalizedTime * normalizedTime);
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.CubicEase", {
        inherits: [System.Windows.Media.Animation.EasingFunctionBase],
        methods: {
            EaseOverride: function (normalizedTime) {
                return normalizedTime * normalizedTime * normalizedTime;
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.DiscreteKeyFrame$1", function (T) { return {
        inherits: [System.Windows.Media.Animation.KeyFrame$1(T)],
        fields: {
            animationOperations: null
        },
        ctors: {
            ctor: function (animationOperations) {
                this.$initialize();
                System.Windows.Media.Animation.KeyFrame$1(T).ctor.call(this);
                this.animationOperations = animationOperations;
            }
        },
        methods: {
            InterpolateValue: function (baseValue, keyFrameProgress) {
                return keyFrameProgress < 1 ? baseValue : this.Value;
            }
        }
    }; });

    Bridge.define("System.Windows.Rect", {
        statics: {
            fields: {
                Empty: null,
                Zero: null
            },
            ctors: {
                init: function () {
                    this.Empty = new System.Windows.Rect.$ctor2(System.Windows.Point.Empty, System.Windows.Size.Empty);
                    this.Zero = new System.Windows.Rect.$ctor3(System.Windows.Size.Zero);
                }
            },
            methods: {
                IsNullOrEmpty: function (rect) {
                    return Bridge.referenceEquals(rect, null) || rect.IsEmpty;
                },
                Parse: function (value) {
                    var values = System.Linq.Enumerable.from(System.String.split(value, [44].map(function(i) {{ return String.fromCharCode(i); }}))).select($asm.$.System.Windows.Rect.f1).toArray(System.Double);

                    if (values.length === 2) {
                        return new System.Windows.Rect.ctor(values[System.Array.index(0, values)], values[System.Array.index(1, values)]);
                    }

                    if (values.length === 4) {
                        return new System.Windows.Rect.$ctor1(values[System.Array.index(0, values)], values[System.Array.index(1, values)], values[System.Array.index(2, values)], values[System.Array.index(3, values)]);
                    }

                    throw new Granular.Exception("Can't parse Rect value \"{0}\"", [value]);
                },
                op_Equality: function (rect1, rect2) {
                    return Bridge.equals(rect1, rect2);
                },
                op_Inequality: function (rect1, rect2) {
                    return !(System.Windows.Rect.op_Equality(rect1, rect2));
                }
            }
        },
        props: {
            Location: null,
            Size: null,
            Left: 0,
            Top: 0,
            Right: 0,
            Bottom: 0,
            Width: 0,
            Height: 0,
            IsEmpty: false
        },
        ctors: {
            ctor: function (width, height) {
                System.Windows.Rect.$ctor2.call(this, System.Windows.Point.Zero, new System.Windows.Size(width, height));
                //
            },
            $ctor1: function (left, top, width, height) {
                System.Windows.Rect.$ctor2.call(this, new System.Windows.Point.$ctor1(left, top), new System.Windows.Size(width, height));
                //
            },
            $ctor3: function (size) {
                System.Windows.Rect.$ctor2.call(this, System.Windows.Point.Zero, size);
                //
            },
            $ctor2: function (location, size) {
                this.$initialize();
                if (System.Windows.PointExtensions.IsNullOrEmpty(location) || System.Windows.SizeExtensions.IsNullOrEmpty(size)) {
                    this.IsEmpty = true;

                    this.Location = System.Windows.Point.Empty;
                    this.Size = System.Windows.Size.Empty;

                    this.Left = Number.NaN;
                    this.Top = Number.NaN;
                    this.Right = Number.NaN;
                    this.Bottom = Number.NaN;
                    this.Width = Number.NaN;
                    this.Height = Number.NaN;
                } else {
                    if (size.IsPartiallyEmpty) {
                        throw new Granular.Exception("Can't create Rect with a size with an empty dimension");
                    }

                    this.IsEmpty = false;

                    this.Location = location;
                    this.Size = size;

                    this.Left = this.Location.X;
                    this.Top = this.Location.Y;
                    this.Right = this.Size.Width + this.Location.X;
                    this.Bottom = this.Size.Height + this.Location.Y;
                    this.Width = this.Size.Width;
                    this.Height = this.Size.Height;
                }
            }
        },
        methods: {
            toString: function () {
                return System.String.format("Rect({0}, {1}, {2}, {3})", Bridge.box(this.Left, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(this.Top, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(this.Width, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(this.Height, System.Double, System.Double.format, System.Double.getHashCode));
            },
            equals: function (obj) {
                var other = Bridge.as(obj, System.Windows.Rect);

                return Bridge.referenceEquals(this, other) || !Bridge.referenceEquals(other, null) && Bridge.equals(this.Location, other.Location) && Bridge.equals(this.Size, other.Size);
            },
            getHashCode: function () {
                return this.Location.getHashCode() ^ this.Size.getHashCode();
            }
        }
    });

    Bridge.ns("System.Windows.Rect", $asm.$);

    Bridge.apply($asm.$.System.Windows.Rect, {
        f1: function (v) {
            return System.Double.parse(v);
        }
    });

    Bridge.define("System.Windows.Thickness", {
        statics: {
            fields: {
                Zero: null
            },
            ctors: {
                init: function () {
                    this.Zero = new System.Windows.Thickness.ctor();
                }
            },
            methods: {
                Parse: function (value) {
                    var values = System.Linq.Enumerable.from(System.String.split(value, [44].map(function(i) {{ return String.fromCharCode(i); }}))).select($asm.$.System.Windows.Thickness.f1).toArray(System.Double);

                    if (values.length === 1) {
                        return new System.Windows.Thickness.$ctor1(values[System.Array.index(0, values)]);
                    }

                    if (values.length === 2) {
                        return new System.Windows.Thickness.$ctor2(values[System.Array.index(0, values)], values[System.Array.index(1, values)]);
                    }

                    if (values.length === 4) {
                        return new System.Windows.Thickness.$ctor3(values[System.Array.index(0, values)], values[System.Array.index(1, values)], values[System.Array.index(2, values)], values[System.Array.index(3, values)]);
                    }

                    throw new Granular.Exception("Can't parse Thickness value \"{0}\"", [value]);
                },
                op_Equality: function (thickness1, thickness2) {
                    return Bridge.equals(thickness1, thickness2);
                },
                op_Inequality: function (thickness1, thickness2) {
                    return !(System.Windows.Thickness.op_Equality(thickness1, thickness2));
                },
                op_UnaryNegation: function (thickness) {
                    if (System.Windows.Thickness.op_Equality(thickness, System.Windows.Thickness.Zero)) {
                        return thickness;
                    }

                    return new System.Windows.Thickness.$ctor3(-thickness.Left, -thickness.Top, -thickness.Right, -thickness.Bottom);
                },
                op_Addition: function (thickness1, thickness2) {
                    if (System.Windows.Thickness.op_Equality(thickness1, System.Windows.Thickness.Zero)) {
                        return thickness2;
                    }

                    if (System.Windows.Thickness.op_Equality(thickness2, System.Windows.Thickness.Zero)) {
                        return thickness1;
                    }

                    return new System.Windows.Thickness.$ctor3(thickness1.Left + thickness2.Left, thickness1.Top + thickness2.Top, thickness1.Right + thickness2.Right, thickness1.Bottom + thickness2.Bottom);
                },
                op_Subtraction: function (thickness1, thickness2) {
                    if (System.Windows.Thickness.op_Equality(thickness1, System.Windows.Thickness.Zero)) {
                        return System.Windows.Thickness.op_UnaryNegation(thickness2);
                    }

                    if (System.Windows.Thickness.op_Equality(thickness2, System.Windows.Thickness.Zero)) {
                        return thickness1;
                    }

                    return new System.Windows.Thickness.$ctor3(thickness1.Left - thickness2.Left, thickness1.Top - thickness2.Top, thickness1.Right - thickness2.Right, thickness1.Bottom - thickness2.Bottom);
                },
                op_Multiply$1: function (thickness, scalar) {
                    if (scalar === 1 || Bridge.referenceEquals(thickness, System.Windows.Thickness.Zero)) {
                        return thickness;
                    }

                    return new System.Windows.Thickness.$ctor3(thickness.Left * scalar, thickness.Top * scalar, thickness.Right * scalar, thickness.Bottom * scalar);
                },
                op_Multiply: function (scalar, thickness) {
                    return System.Windows.Thickness.op_Multiply$1(thickness, scalar);
                },
                op_Implicit: function (uniformLength) {
                    return new System.Windows.Thickness.$ctor1(uniformLength);
                }
            }
        },
        props: {
            Left: 0,
            Top: 0,
            Right: 0,
            Bottom: 0,
            Location: null,
            Size: null,
            IsUniform: {
                get: function () {
                    return this.Left === this.Top && this.Left === this.Right && this.Left === this.Bottom;
                }
            }
        },
        ctors: {
            ctor: function () {
                System.Windows.Thickness.$ctor3.call(this, 0, 0, 0, 0);
                //
            },
            $ctor1: function (uniformLength) {
                System.Windows.Thickness.$ctor3.call(this, uniformLength, uniformLength, uniformLength, uniformLength);
                //
            },
            $ctor2: function (leftRight, topBottom) {
                System.Windows.Thickness.$ctor3.call(this, leftRight, topBottom, leftRight, topBottom);
                //
            },
            $ctor3: function (left, top, right, bottom) {
                this.$initialize();
                this.Left = left;
                this.Top = top;
                this.Right = right;
                this.Bottom = bottom;

                this.Location = left === 0 && top === 0 ? System.Windows.Point.Zero : new System.Windows.Point.$ctor1(left, top);
                this.Size = left + right === 0 && top + bottom === 0 ? System.Windows.Size.Zero : new System.Windows.Size(left + right, top + bottom);
            }
        },
        methods: {
            toString: function () {
                return this.IsUniform ? System.String.format("Thickness({0})", Bridge.box(this.Left, System.Double, System.Double.format, System.Double.getHashCode)) : System.String.format("Thickness({0}, {1}, {2}, {3})", Bridge.box(this.Top, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(this.Right, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(this.Bottom, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(this.Left, System.Double, System.Double.format, System.Double.getHashCode));
            },
            equals: function (obj) {
                var other = Bridge.as(obj, System.Windows.Thickness);

                return Bridge.referenceEquals(this, other) || !Bridge.referenceEquals(other, null) && Granular.Compatibility.EqualityComparer.Double.equals2(this.Left, other.Left) && Granular.Compatibility.EqualityComparer.Double.equals2(this.Top, other.Top) && Granular.Compatibility.EqualityComparer.Double.equals2(this.Right, other.Right) && Granular.Compatibility.EqualityComparer.Double.equals2(this.Bottom, other.Bottom);
            },
            getHashCode: function () {
                return System.Double.getHashCode(this.Left) ^ System.Double.getHashCode(this.Top) ^ System.Double.getHashCode(this.Right) ^ System.Double.getHashCode(this.Bottom);
            }
        }
    });

    Bridge.ns("System.Windows.Thickness", $asm.$);

    Bridge.apply($asm.$.System.Windows.Thickness, {
        f1: function (v) {
            return System.Double.parse(v);
        }
    });

    Bridge.define("System.Windows.Media.Animation.DoubleAnimationOperations", {
        inherits: [System.Windows.Media.Animation.IAnimationOperations$1(System.Nullable$1(System.Double))],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Media.Animation.DoubleAnimationOperations();
                }
            }
        },
        props: {
            Zero: {
                get: function () {
                    return 0;
                }
            }
        },
        alias: [
            "Zero", "System$Windows$Media$Animation$IAnimationOperations$1$System$Nullable$1$System$Double$Zero",
            "Add", "System$Windows$Media$Animation$IAnimationOperations$1$System$Nullable$1$System$Double$Add",
            "Subtract", "System$Windows$Media$Animation$IAnimationOperations$1$System$Nullable$1$System$Double$Subtract",
            "Scale", "System$Windows$Media$Animation$IAnimationOperations$1$System$Nullable$1$System$Double$Scale",
            "Interpolate", "System$Windows$Media$Animation$IAnimationOperations$1$System$Nullable$1$System$Double$Interpolate"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                //
            }
        },
        methods: {
            Add: function (value1, value2) {
                return System.Nullable.getValue(value1) + System.Nullable.getValue(value2);
            },
            Subtract: function (value1, value2) {
                return System.Nullable.getValue(value1) - System.Nullable.getValue(value2);
            },
            Scale: function (value, factor) {
                return factor * System.Nullable.getValue(value);
            },
            Interpolate: function (value1, value2, progress) {
                return System.Nullable.add(System.Nullable.mul((1 - progress), value1), System.Nullable.mul(progress, value2));
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.EasingKeyFrame$1", function (T) { return {
        inherits: [System.Windows.Media.Animation.KeyFrame$1(T)],
        statics: {
            fields: {
                EasingFunctionProperty: null
            },
            ctors: {
                init: function () {
                    this.EasingFunctionProperty = System.Windows.Media.Animation.KeyFrame$1(T).DependencyPropertyRegisterNonGeneric("EasingFunction", System.Windows.Media.Animation.IEasingFunction, System.Windows.Media.Animation.EasingKeyFrame$1(T), new System.Windows.FrameworkPropertyMetadata.ctor());
                }
            }
        },
        fields: {
            animationOperations: null
        },
        props: {
            EasingFunction: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Media.Animation.EasingKeyFrame$1(T).EasingFunctionProperty), System.Windows.Media.Animation.IEasingFunction);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Animation.EasingKeyFrame$1(T).EasingFunctionProperty, value);
                }
            }
        },
        ctors: {
            ctor: function (animationOperations) {
                this.$initialize();
                System.Windows.Media.Animation.KeyFrame$1(T).ctor.call(this);
                this.animationOperations = animationOperations;
            }
        },
        methods: {
            InterpolateValue: function (baseValue, keyFrameProgress) {
                if (this.EasingFunction != null) {
                    keyFrameProgress = this.EasingFunction.System$Windows$Media$Animation$IEasingFunction$Ease(keyFrameProgress);
                }

                return this.animationOperations["System$Windows$Media$Animation$IAnimationOperations$1$" + Bridge.getTypeAlias(T) + "$Interpolate"](baseValue, this.Value, keyFrameProgress);
            }
        }
    }; });

    Bridge.define("System.Windows.Media.Animation.ElasticEase", {
        inherits: [System.Windows.Media.Animation.EasingFunctionBase],
        statics: {
            fields: {
                OscillationsProperty: null,
                SpringinessProperty: null
            },
            ctors: {
                init: function () {
                    this.OscillationsProperty = System.Windows.DependencyProperty.Register("Oscillations", System.Double, System.Windows.Media.Animation.ElasticEase, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(3.0, System.Double, System.Double.format, System.Double.getHashCode)));
                    this.SpringinessProperty = System.Windows.DependencyProperty.Register("Springiness", System.Double, System.Windows.Media.Animation.ElasticEase, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(3.0, System.Double, System.Double.format, System.Double.getHashCode)));
                }
            }
        },
        props: {
            Oscillations: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.Animation.ElasticEase.OscillationsProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Animation.ElasticEase.OscillationsProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            Springiness: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.Animation.ElasticEase.SpringinessProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Animation.ElasticEase.SpringinessProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            }
        },
        methods: {
            EaseOverride: function (normalizedTime) {
                var springiness = Granular.Extensions.DoubleExtensions.Max(this.Springiness, 0);
                return (Granular.Extensions.DoubleExtensions.IsClose(springiness, 0) ? normalizedTime : (Math.exp(springiness * normalizedTime) - 1.0) / (Math.exp(springiness) - 1.0)) * (Math.sin((6.2831853071795862 * Granular.Extensions.DoubleExtensions.Max(this.Oscillations, 0) + 1.5707963267948966) * normalizedTime));
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.ExponentialEase", {
        inherits: [System.Windows.Media.Animation.EasingFunctionBase],
        statics: {
            fields: {
                ExponentProperty: null
            },
            ctors: {
                init: function () {
                    this.ExponentProperty = System.Windows.DependencyProperty.Register("Exponent", System.Double, System.Windows.Media.Animation.ExponentialEase, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(2.0, System.Double, System.Double.format, System.Double.getHashCode)));
                }
            }
        },
        props: {
            Exponent: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.Animation.ExponentialEase.ExponentProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Animation.ExponentialEase.ExponentProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            }
        },
        methods: {
            EaseOverride: function (normalizedTime) {
                return Granular.Extensions.DoubleExtensions.IsClose(this.Exponent, 0) ? normalizedTime : (Math.exp(this.Exponent * normalizedTime) - 1.0) / (Math.exp(this.Exponent) - 1.0);
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.LinearKeyFrame$1", function (T) { return {
        inherits: [System.Windows.Media.Animation.KeyFrame$1(T)],
        fields: {
            animationOperations: null
        },
        ctors: {
            ctor: function (animationOperations) {
                this.$initialize();
                System.Windows.Media.Animation.KeyFrame$1(T).ctor.call(this);
                this.animationOperations = animationOperations;
            }
        },
        methods: {
            InterpolateValue: function (baseValue, keyFrameProgress) {
                return this.animationOperations["System$Windows$Media$Animation$IAnimationOperations$1$" + Bridge.getTypeAlias(T) + "$Interpolate"](baseValue, this.Value, keyFrameProgress);
            }
        }
    }; });

    Bridge.define("System.Windows.Media.Animation.TimelineGroup", {
        inherits: [System.Windows.Media.Animation.Timeline],
        statics: {
            ctors: {
                ctor: function () {
                    System.Windows.Media.Animation.Timeline.DurationProperty.OverrideMetadata(System.Windows.Media.Animation.TimelineGroup, new System.Windows.FrameworkPropertyMetadata.$ctor1(System.Windows.Duration.Automatic));
                }
            }
        },
        props: {
            Children: null
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Animation.Timeline.ctor.call(this);
                this.Children = new (Granular.Collections.ObservableCollection$1(System.Windows.Media.Animation.Timeline)).ctor();
                this.Children.addCollectionChanged(Bridge.fn.cacheBind(this, this.OnChildrenCollectionChanged));
            }
        },
        methods: {
            CreateClock: function () {
                return this.CreateGroupClock(System.Linq.Enumerable.from(this.Children).select($asm.$.System.Windows.Media.Animation.TimelineGroup.f1).toArray(System.Windows.Media.Animation.TimelineClock));
            },
            OnChildrenCollectionChanged: function (sender, e) {
                var $t, $t1;
                $t = Bridge.getEnumerator(e.OldItems, System.Object);
                try {
                    while ($t.moveNext()) {
                        var timeline = Bridge.cast($t.Current, System.Windows.Media.Animation.Timeline);
                        timeline.Parent = null;
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                $t1 = Bridge.getEnumerator(e.NewItems, System.Object);
                try {
                    while ($t1.moveNext()) {
                        var timeline1 = Bridge.cast($t1.Current, System.Windows.Media.Animation.Timeline);
                        timeline1.Parent = this;
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$dispose();
                    }
                }}
        }
    });

    Bridge.ns("System.Windows.Media.Animation.TimelineGroup", $asm.$);

    Bridge.apply($asm.$.System.Windows.Media.Animation.TimelineGroup, {
        f1: function (child) {
            return child.CreateClock();
        }
    });

    Bridge.define("System.Windows.Media.Animation.ParallelTimelineClock", {
        inherits: [System.Windows.Media.Animation.TimelineGroupClock],
        ctors: {
            ctor: function (parallelTimeline, children) {
                this.$initialize();
                System.Windows.Media.Animation.TimelineGroupClock.ctor.call(this, new System.Windows.Media.Animation.ParallelClock(children), parallelTimeline, children);
                //
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.PauseStoryboard", {
        inherits: [System.Windows.Media.Animation.StoryboardAction],
        alias: ["Apply", "System$Windows$ITriggerAction$Apply"],
        methods: {
            Apply: function (target, valueSource) {
                var beginStoryboard = this.GetBeginStoryboard(target);

                if (beginStoryboard != null) {
                    beginStoryboard.Pause(target);
                }
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.PowerEase", {
        inherits: [System.Windows.Media.Animation.EasingFunctionBase],
        statics: {
            fields: {
                PowerProperty: null
            },
            ctors: {
                init: function () {
                    this.PowerProperty = System.Windows.DependencyProperty.Register("Power", System.Double, System.Windows.Media.Animation.PowerEase, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(2.0, System.Double, System.Double.format, System.Double.getHashCode)));
                }
            }
        },
        props: {
            Power: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.Animation.PowerEase.PowerProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Animation.PowerEase.PowerProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            }
        },
        methods: {
            EaseOverride: function (normalizedTime) {
                return Math.pow(normalizedTime, Granular.Extensions.DoubleExtensions.Max(this.Power, 0));
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.QuadraticEase", {
        inherits: [System.Windows.Media.Animation.EasingFunctionBase],
        methods: {
            EaseOverride: function (normalizedTime) {
                return normalizedTime * normalizedTime;
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.QuarticEase", {
        inherits: [System.Windows.Media.Animation.EasingFunctionBase],
        methods: {
            EaseOverride: function (normalizedTime) {
                return normalizedTime * normalizedTime * normalizedTime * normalizedTime;
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.QuinticEase", {
        inherits: [System.Windows.Media.Animation.EasingFunctionBase],
        methods: {
            EaseOverride: function (normalizedTime) {
                return normalizedTime * normalizedTime * normalizedTime * normalizedTime * normalizedTime;
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.RemoveStoryboard", {
        inherits: [System.Windows.Media.Animation.StoryboardAction],
        alias: ["Apply", "System$Windows$ITriggerAction$Apply"],
        methods: {
            Apply: function (target, valueSource) {
                var beginStoryboard = this.GetBeginStoryboard(target);

                if (beginStoryboard != null) {
                    var nameScope = valueSource === System.Windows.BaseValueSource.Local ? System.Windows.NameScope.GetContainingNameScope(target) : System.Windows.NameScope.GetTemplateNameScope(target);
                    var layerOwner = valueSource === System.Windows.BaseValueSource.Local ? null : target.TemplatedParent;
                    beginStoryboard.Remove(target, nameScope, layerOwner);
                }
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.ResumeStoryboard", {
        inherits: [System.Windows.Media.Animation.StoryboardAction],
        alias: ["Apply", "System$Windows$ITriggerAction$Apply"],
        methods: {
            Apply: function (target, valueSource) {
                var beginStoryboard = this.GetBeginStoryboard(target);

                if (beginStoryboard != null) {
                    beginStoryboard.Resume(target);
                }
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.SequentialTimelineClock", {
        inherits: [System.Windows.Media.Animation.TimelineGroupClock],
        ctors: {
            ctor: function (SequentialTimeline, children) {
                this.$initialize();
                System.Windows.Media.Animation.TimelineGroupClock.ctor.call(this, new System.Windows.Media.Animation.SequentialClock(children), SequentialTimeline, children);
                //
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.SineEase", {
        inherits: [System.Windows.Media.Animation.EasingFunctionBase],
        methods: {
            EaseOverride: function (normalizedTime) {
                return 1.0 - Math.sin(1.5707963267948966 * (1 - normalizedTime));
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.SkipToFillStoryboard", {
        inherits: [System.Windows.Media.Animation.StoryboardAction],
        alias: ["Apply", "System$Windows$ITriggerAction$Apply"],
        methods: {
            Apply: function (target, valueSource) {
                var beginStoryboard = this.GetBeginStoryboard(target);

                if (beginStoryboard != null) {
                    beginStoryboard.SkipToFill(target);
                }
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.StopStoryboard", {
        inherits: [System.Windows.Media.Animation.StoryboardAction],
        alias: ["Apply", "System$Windows$ITriggerAction$Apply"],
        methods: {
            Apply: function (target, valueSource) {
                var beginStoryboard = this.GetBeginStoryboard(target);

                if (beginStoryboard != null) {
                    beginStoryboard.Stop(target);
                }
            }
        }
    });

    Bridge.define("System.Windows.Media.Brush", {
        inherits: [System.Windows.Media.Animation.Animatable],
        statics: {
            fields: {
                OpacityProperty: null
            },
            ctors: {
                init: function () {
                    this.OpacityProperty = System.Windows.DependencyProperty.Register("Opacity", System.Double, System.Windows.Media.Brush, new System.Windows.FrameworkPropertyMetadata.$ctor6(Bridge.box(1.0, System.Double, System.Double.format, System.Double.getHashCode), $asm.$.System.Windows.Media.Brush.f1));
                }
            }
        },
        fields: {
            renderResource: null
        },
        props: {
            Opacity: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.Brush.OpacityProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Brush.OpacityProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            }
        },
        methods: {
            GetRenderResource: function (factory) {
                if (this.renderResource == null) {
                    var resource = this.CreateRenderResource(factory);
                    this.OnRenderResourceCreated(resource);

                    if (this.renderResource == null) {
                        throw new Granular.Exception("base.OnRenderResourceCreated was not called for \"{0}\"", [Bridge.Reflection.getTypeName(Bridge.getType(this))]);
                    }
                }

                return this.renderResource;
            },
            OnRenderResourceCreated: function (renderResource) {
                this.renderResource = Bridge.cast(renderResource, System.Windows.Media.IBrushRenderResource);
                this.renderResource.System$Windows$Media$IBrushRenderResource$Opacity = this.Opacity;
            },
            OnOpacityChanged: function (e) {
                if (this.renderResource != null) {
                    this.renderResource.System$Windows$Media$IBrushRenderResource$Opacity = this.Opacity;
                }
            }
        }
    });

    Bridge.ns("System.Windows.Media.Brush", $asm.$);

    Bridge.apply($asm.$.System.Windows.Media.Brush, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Media.Brush).OnOpacityChanged(e);
        }
    });

    Bridge.define("System.Windows.Media.DashStyle", {
        inherits: [System.Windows.Media.Animation.Animatable],
        statics: {
            fields: {
                DashesProperty: null,
                OffsetProperty: null
            },
            ctors: {
                init: function () {
                    this.DashesProperty = System.Windows.DependencyProperty.Register("Dashes", System.Collections.Generic.IEnumerable$1(System.Double), System.Windows.Media.DashStyle, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.OffsetProperty = System.Windows.DependencyProperty.Register("Offset", System.Double, System.Windows.Media.DashStyle, new System.Windows.FrameworkPropertyMetadata.$ctor8(0.0));
                }
            }
        },
        props: {
            Dashes: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Media.DashStyle.DashesProperty), System.Collections.Generic.IEnumerable$1(System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.DashStyle.DashesProperty, value);
                }
            },
            Offset: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.DashStyle.OffsetProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.DashStyle.OffsetProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Animation.Animatable.ctor.call(this);
                //
            },
            $ctor1: function (dashes, offset) {
                System.Windows.Media.DashStyle.ctor.call(this);
                this.Dashes = dashes;
                this.Offset = offset;
            }
        }
    });

    Bridge.define("System.Windows.Media.Geometry", {
        inherits: [System.Windows.Media.Animation.Animatable],
        statics: {
            fields: {
                TransformProperty: null
            },
            ctors: {
                init: function () {
                    this.TransformProperty = System.Windows.DependencyProperty.Register("Transform", System.Windows.Media.Transform, System.Windows.Media.Geometry, new System.Windows.FrameworkPropertyMetadata.$ctor6(System.Windows.Media.Transform.Identity, $asm.$.System.Windows.Media.Geometry.f1));
                }
            },
            methods: {
                Parse: function (source) {
                    return new System.Windows.Media.StreamGeometry(source);
                }
            }
        },
        fields: {
            renderResource: null
        },
        props: {
            Transform: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Media.Geometry.TransformProperty), System.Windows.Media.Transform);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Geometry.TransformProperty, value);
                }
            }
        },
        methods: {
            GetRenderResource: function (factory) {
                if (this.renderResource == null) {
                    this.renderResource = factory.System$Windows$Media$IRenderElementFactory$CreateGeometryRenderResource();
                    this.renderResource.System$Windows$Media$IGeometryRenderResource$Transform = this.Transform;
                    this.renderResource.System$Windows$Media$IGeometryRenderResource$Data = this.GetRenderResourceData();
                }

                return this.renderResource;
            },
            InvalidateRenderResource: function () {
                if (this.renderResource != null) {
                    this.renderResource.System$Windows$Media$IGeometryRenderResource$Data = this.GetRenderResourceData();
                }
            },
            OnTransformChanged: function (e) {
                if (this.renderResource != null) {
                    this.renderResource.System$Windows$Media$IGeometryRenderResource$Transform = this.Transform;
                }
            }
        }
    });

    Bridge.ns("System.Windows.Media.Geometry", $asm.$);

    Bridge.apply($asm.$.System.Windows.Media.Geometry, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Media.Geometry).OnTransformChanged(e);
        }
    });

    Bridge.define("System.Windows.Media.GradientStop", {
        inherits: [System.Windows.Media.Animation.Animatable],
        statics: {
            fields: {
                ColorProperty: null,
                OffsetProperty: null
            },
            ctors: {
                init: function () {
                    this.ColorProperty = System.Windows.DependencyProperty.Register("Color", System.Windows.Media.Color, System.Windows.Media.GradientStop, new System.Windows.FrameworkPropertyMetadata.$ctor1(System.Windows.Media.Colors.Transparent));
                    this.OffsetProperty = System.Windows.DependencyProperty.Register("Offset", System.Double, System.Windows.Media.GradientStop, new System.Windows.FrameworkPropertyMetadata.ctor());
                }
            }
        },
        props: {
            Color: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Media.GradientStop.ColorProperty), System.Windows.Media.Color);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.GradientStop.ColorProperty, value);
                }
            },
            Offset: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.GradientStop.OffsetProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.GradientStop.OffsetProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Animation.Animatable.ctor.call(this);
                //
            },
            $ctor1: function (color, offset) {
                this.$initialize();
                System.Windows.Media.Animation.Animatable.ctor.call(this);
                this.Color = color;
                this.Offset = offset;
            }
        }
    });

    Bridge.define("System.Windows.Media.ImageSource", {
        inherits: [System.Windows.Media.Animation.Animatable],
        fields: {
            renderResource: null
        },
        props: {
            Size: {
                get: function () {
                    return this.renderResource != null ? this.renderResource.System$Windows$Media$IImageSourceRenderResource$Size : System.Windows.Size.Empty;
                }
            },
            Width: {
                get: function () {
                    return this.Size.Width;
                }
            },
            Height: {
                get: function () {
                    return this.Size.Width;
                }
            }
        },
        methods: {
            GetRenderResource: function (factory) {
                if (this.renderResource == null) {
                    var resource = this.CreateRenderResource(factory);
                    this.OnRenderResourceCreated(resource);

                    if (this.renderResource == null) {
                        throw new Granular.Exception("base.OnRenderResourceCreated was not called for \"{0}\"", [Bridge.Reflection.getTypeName(Bridge.getType(this))]);
                    }
                }

                return this.renderResource;
            },
            OnRenderResourceCreated: function (renderResource) {
                this.renderResource = Bridge.cast(renderResource, System.Windows.Media.IImageSourceRenderResource);
            }
        }
    });

    Bridge.define("System.Windows.Media.Pen", {
        inherits: [System.Windows.Media.Animation.Animatable],
        statics: {
            fields: {
                BrushProperty: null,
                DashCapProperty: null,
                DashStyleProperty: null,
                StartLineCapProperty: null,
                EndLineCapProperty: null,
                LineJoinProperty: null,
                MiterLimitProperty: null,
                ThicknessProperty: null
            },
            ctors: {
                init: function () {
                    this.BrushProperty = System.Windows.DependencyProperty.Register("Brush", System.Windows.Media.Brush, System.Windows.Media.Pen, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.DashCapProperty = System.Windows.DependencyProperty.Register("DashCap", System.Windows.Media.PenLineCap, System.Windows.Media.Pen, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(System.Windows.Media.PenLineCap.Square, System.Windows.Media.PenLineCap, System.Enum.toStringFn(System.Windows.Media.PenLineCap))));
                    this.DashStyleProperty = System.Windows.DependencyProperty.Register("DashStyle", System.Windows.Media.DashStyle, System.Windows.Media.Pen, new System.Windows.FrameworkPropertyMetadata.$ctor1(System.Windows.Media.DashStyles.Solid));
                    this.StartLineCapProperty = System.Windows.DependencyProperty.Register("StartLineCap", System.Windows.Media.PenLineCap, System.Windows.Media.Pen, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(System.Windows.Media.PenLineCap.Flat, System.Windows.Media.PenLineCap, System.Enum.toStringFn(System.Windows.Media.PenLineCap))));
                    this.EndLineCapProperty = System.Windows.DependencyProperty.Register("EndLineCap", System.Windows.Media.PenLineCap, System.Windows.Media.Pen, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(System.Windows.Media.PenLineCap.Flat, System.Windows.Media.PenLineCap, System.Enum.toStringFn(System.Windows.Media.PenLineCap))));
                    this.LineJoinProperty = System.Windows.DependencyProperty.Register("LineJoin", System.Windows.Media.PenLineJoin, System.Windows.Media.Pen, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(System.Windows.Media.PenLineJoin.Miter, System.Windows.Media.PenLineJoin, System.Enum.toStringFn(System.Windows.Media.PenLineJoin))));
                    this.MiterLimitProperty = System.Windows.DependencyProperty.Register("MiterLimit", System.Double, System.Windows.Media.Pen, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(10.0, System.Double, System.Double.format, System.Double.getHashCode)));
                    this.ThicknessProperty = System.Windows.DependencyProperty.Register("Thickness", System.Double, System.Windows.Media.Pen, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(1.0, System.Double, System.Double.format, System.Double.getHashCode)));
                }
            }
        },
        props: {
            Brush: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Media.Pen.BrushProperty), System.Windows.Media.Brush);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Pen.BrushProperty, value);
                }
            },
            DashCap: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.Pen.DashCapProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Pen.DashCapProperty, Bridge.box(value, System.Windows.Media.PenLineCap, System.Enum.toStringFn(System.Windows.Media.PenLineCap)));
                }
            },
            DashStyle: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Media.Pen.DashStyleProperty), System.Windows.Media.DashStyle);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Pen.DashStyleProperty, value);
                }
            },
            StartLineCap: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.Pen.StartLineCapProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Pen.StartLineCapProperty, Bridge.box(value, System.Windows.Media.PenLineCap, System.Enum.toStringFn(System.Windows.Media.PenLineCap)));
                }
            },
            EndLineCap: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.Pen.EndLineCapProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Pen.EndLineCapProperty, Bridge.box(value, System.Windows.Media.PenLineCap, System.Enum.toStringFn(System.Windows.Media.PenLineCap)));
                }
            },
            LineJoin: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.Pen.LineJoinProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Pen.LineJoinProperty, Bridge.box(value, System.Windows.Media.PenLineJoin, System.Enum.toStringFn(System.Windows.Media.PenLineJoin)));
                }
            },
            MiterLimit: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.Pen.MiterLimitProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Pen.MiterLimitProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            Thickness: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.Pen.ThicknessProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Pen.ThicknessProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Animation.Animatable.ctor.call(this);
                //
            },
            $ctor1: function (brush, thickness) {
                System.Windows.Media.Pen.ctor.call(this);
                this.Brush = brush;
                this.Thickness = thickness;
            }
        }
    });

    Bridge.define("System.Windows.Controls.Decorator", {
        inherits: [System.Windows.FrameworkElement],
        fields: {
            child: null
        },
        props: {
            Child: {
                get: function () {
                    return this.child;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.child, value)) {
                        return;
                    }

                    if (this.child != null) {
                        this.RemoveLogicalChild(this.child);
                        this.RemoveVisualChild(this.child);
                    }

                    this.child = value;

                    if (this.child != null) {
                        this.AddLogicalChild(this.child);
                        this.AddVisualChild(this.child);
                    }

                    this.InvalidateMeasure();
                    this.InvalidateArrange();
                }
            }
        },
        methods: {
            MeasureOverride: function (availableSize) {
                if (this.Child == null) {
                    return System.Windows.Size.Zero;
                }

                this.Child.Measure(availableSize);
                return this.Child.DesiredSize;
            },
            ArrangeOverride: function (finalSize) {
                if (this.Child != null) {
                    this.Child.Arrange(new System.Windows.Rect.$ctor3(finalSize));
                }

                return finalSize;
            }
        }
    });

    Bridge.define("System.Windows.Controls.Control", {
        inherits: [System.Windows.FrameworkElement],
        statics: {
            fields: {
                PreviewMouseDoubleClickEvent: null,
                MouseDoubleClickEvent: null,
                TemplateProperty: null,
                BackgroundProperty: null,
                ForegroundProperty: null,
                FontFamilyProperty: null,
                FontSizeProperty: null,
                FontStyleProperty: null,
                FontWeightProperty: null,
                FontStretchProperty: null,
                BorderBrushProperty: null,
                BorderThicknessProperty: null,
                HorizontalContentAlignmentProperty: null,
                VerticalContentAlignmentProperty: null,
                PaddingProperty: null,
                IsTabStopProperty: null,
                TabIndexProperty: null
            },
            ctors: {
                init: function () {
                    this.PreviewMouseDoubleClickEvent = System.Windows.EventManager.RegisterRoutedEvent("PreviewMouseDoubleClick", System.Windows.RoutingStrategy.Tunnel, Function, System.Windows.Controls.Control);
                    this.MouseDoubleClickEvent = System.Windows.EventManager.RegisterRoutedEvent("MouseDoubleClick", System.Windows.RoutingStrategy.Bubble, Function, System.Windows.Controls.Control);
                    this.TemplateProperty = System.Windows.DependencyProperty.Register("Template", System.Windows.Controls.ControlTemplate, System.Windows.Controls.Control, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.Control.f1));
                    this.BackgroundProperty = System.Windows.Controls.Panel.BackgroundProperty.AddOwner(System.Windows.Controls.Control);
                    this.ForegroundProperty = System.Windows.Documents.TextElement.ForegroundProperty.AddOwner(System.Windows.Controls.Control);
                    this.FontFamilyProperty = System.Windows.Documents.TextElement.FontFamilyProperty.AddOwner(System.Windows.Controls.Control);
                    this.FontSizeProperty = System.Windows.Documents.TextElement.FontSizeProperty.AddOwner(System.Windows.Controls.Control, new System.Windows.FrameworkPropertyMetadata.$ctor8(33));
                    this.FontStyleProperty = System.Windows.Documents.TextElement.FontStyleProperty.AddOwner(System.Windows.Controls.Control, new System.Windows.FrameworkPropertyMetadata.$ctor8(33));
                    this.FontWeightProperty = System.Windows.Documents.TextElement.FontWeightProperty.AddOwner(System.Windows.Controls.Control, new System.Windows.FrameworkPropertyMetadata.$ctor8(33));
                    this.FontStretchProperty = System.Windows.Documents.TextElement.FontStretchProperty.AddOwner(System.Windows.Controls.Control, new System.Windows.FrameworkPropertyMetadata.$ctor8(33));
                    this.BorderBrushProperty = System.Windows.Controls.Border.BorderBrushProperty.AddOwner(System.Windows.Controls.Control);
                    this.BorderThicknessProperty = System.Windows.Controls.Border.BorderThicknessProperty.AddOwner(System.Windows.Controls.Control);
                    this.HorizontalContentAlignmentProperty = System.Windows.DependencyProperty.Register("HorizontalContentAlignment", System.Windows.HorizontalAlignment, System.Windows.Controls.Control, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(System.Windows.HorizontalAlignment.Left, System.Windows.HorizontalAlignment, System.Enum.toStringFn(System.Windows.HorizontalAlignment))));
                    this.VerticalContentAlignmentProperty = System.Windows.DependencyProperty.Register("VerticalContentAlignment", System.Windows.VerticalAlignment, System.Windows.Controls.Control, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(System.Windows.VerticalAlignment.Top, System.Windows.VerticalAlignment, System.Enum.toStringFn(System.Windows.VerticalAlignment))));
                    this.PaddingProperty = System.Windows.Controls.Border.PaddingProperty.AddOwner(System.Windows.Controls.Control);
                    this.IsTabStopProperty = System.Windows.Input.KeyboardNavigation.IsTabStopProperty.AddOwner(System.Windows.Controls.Control);
                    this.TabIndexProperty = System.Windows.Input.KeyboardNavigation.TabIndexProperty.AddOwner(System.Windows.Controls.Control);
                },
                ctor: function () {
                    System.Windows.UIElement.FocusableProperty.OverrideMetadata(System.Windows.Controls.Control, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(true, System.Boolean, System.Boolean.toString)));

                    System.Windows.EventManager.RegisterClassHandler(System.Windows.Controls.Control, System.Windows.UIElement.PreviewMouseDownEvent, System.Windows.Controls.Control.OnPreviewMouseDown, true);
                    System.Windows.EventManager.RegisterClassHandler(System.Windows.Controls.Control, System.Windows.UIElement.MouseDownEvent, System.Windows.Controls.Control.OnMouseDown, true);
                }
            },
            methods: {
                OnPreviewMouseDown: function (sender, e) {
                    if (e.ClickCount === 2 && Bridge.cast(sender, System.Windows.Controls.Control).RaiseMouseButtonEvent(e, System.Windows.Controls.Control.PreviewMouseDoubleClickEvent)) {
                        e.Handled = true;
                    }
                },
                OnMouseDown: function (sender, e) {
                    if (e.ClickCount === 2 && Bridge.cast(sender, System.Windows.Controls.Control).RaiseMouseButtonEvent(e, System.Windows.Controls.Control.MouseDoubleClickEvent)) {
                        e.Handled = true;
                    }
                }
            }
        },
        props: {
            Template: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.Control.TemplateProperty), System.Windows.Controls.ControlTemplate);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Control.TemplateProperty, value);
                }
            },
            Background: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.Control.BackgroundProperty), System.Windows.Media.Brush);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Control.BackgroundProperty, value);
                }
            },
            Foreground: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.Control.ForegroundProperty), System.Windows.Media.Brush);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Control.ForegroundProperty, value);
                }
            },
            FontFamily: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.Control.FontFamilyProperty), System.Windows.Media.FontFamily);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Control.FontFamilyProperty, value);
                }
            },
            FontSize: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Control.FontSizeProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Control.FontSizeProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            FontStyle: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Control.FontStyleProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Control.FontStyleProperty, Bridge.box(value, System.Windows.FontStyle, System.Enum.toStringFn(System.Windows.FontStyle)));
                }
            },
            FontWeight: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Control.FontWeightProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Control.FontWeightProperty, Bridge.box(value, System.Windows.FontWeight, System.Enum.toStringFn(System.Windows.FontWeight)));
                }
            },
            FontStretch: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Control.FontStretchProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Control.FontStretchProperty, Bridge.box(value, System.Windows.FontStretch, System.Enum.toStringFn(System.Windows.FontStretch)));
                }
            },
            BorderBrush: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.Control.BorderBrushProperty), System.Windows.Media.Brush);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Control.BorderBrushProperty, value);
                }
            },
            BorderThickness: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.Control.BorderThicknessProperty), System.Windows.Thickness);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Control.BorderThicknessProperty, value);
                }
            },
            HorizontalContentAlignment: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Control.HorizontalContentAlignmentProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Control.HorizontalContentAlignmentProperty, Bridge.box(value, System.Windows.HorizontalAlignment, System.Enum.toStringFn(System.Windows.HorizontalAlignment)));
                }
            },
            VerticalContentAlignment: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Control.VerticalContentAlignmentProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Control.VerticalContentAlignmentProperty, Bridge.box(value, System.Windows.VerticalAlignment, System.Enum.toStringFn(System.Windows.VerticalAlignment)));
                }
            },
            Padding: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.Control.PaddingProperty), System.Windows.Thickness);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Control.PaddingProperty, value);
                }
            },
            IsTabStop: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Control.IsTabStopProperty)), System.Boolean));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Control.IsTabStopProperty, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            },
            TabIndex: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Control.TabIndexProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Control.TabIndexProperty, Bridge.box(value, System.Int32));
                }
            }
        },
        methods: {
            addPreviewMouseDoubleClick: function (value) {
                this.AddHandler(System.Windows.Controls.Control.PreviewMouseDoubleClickEvent, value);
            },
            removePreviewMouseDoubleClick: function (value) {
                this.RemoveHandler(System.Windows.Controls.Control.PreviewMouseDoubleClickEvent, value);
            },
            addMouseDoubleClick: function (value) {
                this.AddHandler(System.Windows.Controls.Control.MouseDoubleClickEvent, value);
            },
            removeMouseDoubleClick: function (value) {
                this.RemoveHandler(System.Windows.Controls.Control.MouseDoubleClickEvent, value);
            },
            OnPropertyChanged: function (e) {
                System.Windows.FrameworkElement.prototype.OnPropertyChanged.call(this, e);

                var metadata = Bridge.as(e.Property.GetMetadata(Bridge.getType(this)), System.Windows.FrameworkPropertyMetadata);

                if (metadata != null && metadata.AffectsVisualState) {
                    this.UpdateVisualState(true);
                }
            },
            MeasureOverride: function (availableSize) {
                if (this.TemplateChild == null) {
                    return System.Windows.Size.Zero;
                }

                this.TemplateChild.Measure(availableSize);
                return this.TemplateChild.DesiredSize;
            },
            ArrangeOverride: function (finalSize) {
                if (this.TemplateChild != null) {
                    this.TemplateChild.Arrange(new System.Windows.Rect.$ctor3(finalSize));
                }

                return finalSize;
            },
            UpdateVisualState: function (useTransitions) {
                //
            },
            OnApplyTemplate: function () {
                this.UpdateVisualState(false);
            },
            GetTemplate: function () {
                return this.Template;
            },
            RaiseMouseButtonEvent: function (e, routedEvent) {
                var eventArgs = new System.Windows.Input.MouseButtonEventArgs(routedEvent, e.OriginalSource, e.MouseDevice, e.Timestamp, e.AbsolutePosition, e.ChangedButton, e.ButtonState, e.ClickCount);
                this.RaiseEvent(eventArgs);
                return eventArgs.Handled;
            }
        }
    });

    Bridge.ns("System.Windows.Controls.Control", $asm.$);

    Bridge.apply($asm.$.System.Windows.Controls.Control, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.Control).ApplyTemplate();
        }
    });

    Bridge.define("System.Windows.Controls.Panel", {
        inherits: [System.Windows.FrameworkElement],
        statics: {
            fields: {
                IsItemsHostProperty: null,
                BackgroundProperty: null,
                ZIndexProperty: null
            },
            ctors: {
                init: function () {
                    this.IsItemsHostProperty = System.Windows.DependencyProperty.Register("IsItemsHost", System.Boolean, System.Windows.Controls.Panel, new System.Windows.FrameworkPropertyMetadata.$ctor6(Bridge.box(false, System.Boolean, System.Boolean.toString), $asm.$.System.Windows.Controls.Panel.f1));
                    this.BackgroundProperty = System.Windows.DependencyProperty.Register("Background", System.Windows.Media.Brush, System.Windows.Controls.Panel, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.Panel.f2));
                    this.ZIndexProperty = System.Windows.DependencyProperty.RegisterAttached("ZIndex", System.Int32, System.Windows.Controls.Panel, new System.Windows.FrameworkPropertyMetadata.$ctor11(System.Windows.Controls.Panel.OnZIndexPropertyChanged));
                }
            },
            methods: {
                GetZIndex: function (obj) {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj.GetValue(System.Windows.Controls.Panel.ZIndexProperty)), System.Int32));
                },
                SetZIndex: function (obj, value) {
                    obj.SetValue(System.Windows.Controls.Panel.ZIndexProperty, Bridge.box(value, System.Int32));
                },
                OnZIndexPropertyChanged: function (dependencyObject, e) {
                    if (Bridge.is(dependencyObject, System.Windows.Media.Visual) && Bridge.is(Bridge.cast(dependencyObject, System.Windows.Media.Visual).VisualParent, System.Windows.Controls.Panel)) {
                        System.Windows.Controls.Panel.MoveVisualChild(Bridge.cast(dependencyObject, System.Windows.Media.Visual), System.Nullable.getValue(Bridge.cast(Bridge.unbox(e.NewValue), System.Int32)));
                    }
                },
                MoveVisualChild: function (child, childZIndex) {
                    var childVisualIndex = Granular.Compatibility.Linq.Enumerable.Count$1(Bridge.global.System.Windows.Media.Visual, child.VisualParent.VisualChildren, function (visual) {
                        return !Bridge.referenceEquals(visual, child) && System.Windows.Controls.Panel.GetZIndex(visual) <= childZIndex;
                    });
                    child.VisualParent.SetVisualChildIndex(child, childVisualIndex);
                }
            }
        },
        fields: {
            itemContainerGenerator: null
        },
        props: {
            Children: null,
            IsItemsHost: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Panel.IsItemsHostProperty)), System.Boolean));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Panel.IsItemsHostProperty, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            },
            ItemContainerGenerator: {
                get: function () {
                    return this.itemContainerGenerator;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.itemContainerGenerator, value)) {
                        return;
                    }

                    if (this.itemContainerGenerator != null) {
                        this.itemContainerGenerator.System$Windows$Controls$Primitives$IItemContainerGenerator$removeItemsChanged(Bridge.fn.cacheBind(this, this.OnGeneratorItemsChanged));
                        this.Children.clear();
                    }

                    this.itemContainerGenerator = value;

                    if (this.itemContainerGenerator != null) {
                        this.itemContainerGenerator.System$Windows$Controls$Primitives$IItemContainerGenerator$addItemsChanged(Bridge.fn.cacheBind(this, this.OnGeneratorItemsChanged));
                        this.AddChildren();
                    }
                }
            },
            Background: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.Panel.BackgroundProperty), System.Windows.Media.Brush);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Panel.BackgroundProperty, value);
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.FrameworkElement.ctor.call(this);
                this.Children = new System.Windows.Controls.UIElementCollection(this);
                this.Children.addCollectionChanged(Bridge.fn.cacheBind(this, this.OnChildrenCollectionChanged));
            }
        },
        methods: {
            OnChildrenCollectionChanged: function (sender, e) {
                var $t;
                $t = Bridge.getEnumerator(e.NewItems, System.Object);
                try {
                    while ($t.moveNext()) {
                        var child = Bridge.cast($t.Current, System.Windows.UIElement);
                        System.Windows.Controls.Panel.MoveVisualChild(child, System.Windows.Controls.Panel.GetZIndex(child));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }},
            HitTestOverride: function (position) {
                return this.Background != null && System.Windows.SizeExtensions.Contains(this.VisualSize, position);
            },
            OnGeneratorItemsChanged: function (sender, e) {
                if (e.Action === Granular.Collections.NotifyCollectionChangedAction.Add) {
                    for (var i = 0; i < e.ItemsCount; i = (i + 1) | 0) {
                        this.Children.insert(((i + e.NewStartingIndex) | 0), this.ItemContainerGenerator.System$Windows$Controls$Primitives$IItemContainerGenerator$Generate(((i + e.NewStartingIndex) | 0)));
                    }
                }

                if (e.Action === Granular.Collections.NotifyCollectionChangedAction.Remove) {
                    Granular.Extensions.ListExtensions.RemoveRange(Bridge.global.System.Windows.UIElement, this.Children, e.OldStartingIndex, e.ContainersCount);
                }

                if (e.Action === Granular.Collections.NotifyCollectionChangedAction.Move) {
                    var movedChildren = Granular.Compatibility.Linq.Enumerable.Take(Bridge.global.System.Windows.UIElement, Granular.Compatibility.Linq.Enumerable.Skip(Bridge.global.System.Windows.UIElement, this.Children, e.OldStartingIndex), e.ContainersCount);
                    Granular.Extensions.ListExtensions.RemoveRange(Bridge.global.System.Windows.UIElement, this.Children, e.OldStartingIndex, e.ContainersCount);
                    Granular.Extensions.ListExtensions.InsertRange(Bridge.global.System.Windows.UIElement, this.Children, e.NewStartingIndex, movedChildren);
                }

                if (e.Action === Granular.Collections.NotifyCollectionChangedAction.Replace) {
                    this.Children.setItem(e.NewStartingIndex, this.ItemContainerGenerator.System$Windows$Controls$Primitives$IItemContainerGenerator$Generate(e.NewStartingIndex));
                }

                if (e.Action === Granular.Collections.NotifyCollectionChangedAction.Reset) {
                    this.Children.clear();
                    this.AddChildren();
                }
            },
            AddChildren: function () {
                for (var i = 0; i < this.ItemContainerGenerator.System$Windows$Controls$Primitives$IItemContainerGenerator$ItemsCount; i = (i + 1) | 0) {
                    this.Children.add(this.ItemContainerGenerator.System$Windows$Controls$Primitives$IItemContainerGenerator$Generate(i));
                }
            },
            OnIsItemsHostChanged: function (e) {
                this.ItemContainerGenerator = this.IsItemsHost && Bridge.is(this.TemplatedParent, System.Windows.Controls.ItemsControl) ? Bridge.cast(this.TemplatedParent, System.Windows.Controls.ItemsControl).ItemContainerGenerator : null;
            },
            OnBackgroundChanged: function (e) {
                this.VisualBackground = this.Background;
            }
        }
    });

    Bridge.ns("System.Windows.Controls.Panel", $asm.$);

    Bridge.apply($asm.$.System.Windows.Controls.Panel, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.Panel).OnIsItemsHostChanged(e);
        },
        f2: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.Panel).OnBackgroundChanged(e);
        }
    });

    Bridge.define("System.Windows.Controls.ContentPresenter", {
        inherits: [System.Windows.FrameworkElement,System.Windows.Controls.IItemContainer],
        statics: {
            fields: {
                ContentProperty: null,
                ContentTemplateProperty: null,
                ContentTemplateSelectorProperty: null
            },
            ctors: {
                init: function () {
                    this.ContentProperty = System.Windows.Controls.ContentControl.ContentProperty.AddOwner(System.Windows.Controls.ContentPresenter, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.ContentPresenter.f1));
                    this.ContentTemplateProperty = System.Windows.Controls.ContentControl.ContentTemplateProperty.AddOwner(System.Windows.Controls.ContentPresenter, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.ContentPresenter.f2));
                    this.ContentTemplateSelectorProperty = System.Windows.Controls.ContentControl.ContentTemplateSelectorProperty.AddOwner(System.Windows.Controls.ContentPresenter, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.ContentPresenter.f2));
                }
            }
        },
        fields: {
            template: null,
            itemTemplate: null,
            itemContainerStyle: null
        },
        props: {
            Content: {
                get: function () {
                    return this.GetValue(System.Windows.Controls.ContentPresenter.ContentProperty);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.ContentPresenter.ContentProperty, value);
                }
            },
            ContentTemplate: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.ContentPresenter.ContentTemplateProperty), System.Windows.DataTemplate);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.ContentPresenter.ContentTemplateProperty, value);
                }
            },
            ContentTemplateSelector: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.ContentPresenter.ContentTemplateSelectorProperty), System.Windows.Controls.IDataTemplateSelector);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.ContentPresenter.ContentTemplateSelectorProperty, value);
                }
            },
            Template: {
                get: function () {
                    return this.template;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.template, value)) {
                        return;
                    }

                    this.template = value;

                    this.ApplyTemplate();
                }
            }
        },
        alias: [
            "PrepareContainerForItem", "System$Windows$Controls$IItemContainer$PrepareContainerForItem",
            "ClearContainerForItem", "System$Windows$Controls$IItemContainer$ClearContainerForItem"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.FrameworkElement.ctor.call(this);
                //
            }
        },
        methods: {
            MeasureOverride: function (availableSize) {
                if (this.TemplateChild == null) {
                    return System.Windows.Size.Zero;
                }

                this.TemplateChild.Measure(availableSize);
                return this.TemplateChild.DesiredSize;
            },
            ArrangeOverride: function (finalSize) {
                if (this.TemplateChild != null) {
                    this.TemplateChild.Arrange(new System.Windows.Rect.$ctor3(finalSize));
                }

                return finalSize;
            },
            GetTemplate: function () {
                return this.Template;
            },
            OnApplyTemplate: function () {
                this.SetDataContext();
            },
            OnResourcesChanged: function (e) {
                System.Windows.FrameworkElement.prototype.OnResourcesChanged.call(this, e);
                this.SetTemplate();
            },
            OnContentChanged: function (e) {
                this.SetTemplate();
            },
            SetTemplate: function () {
                this.Template = this.FindTemplate();
            },
            SetDataContext: function () {
                if (Bridge.is(this.Content, System.Windows.Media.Visual)) {
                    this.ClearValue(System.Windows.FrameworkElement.DataContextProperty);
                } else {
                    this.DataContext = this.Content;
                }
            },
            FindTemplate: function () {
                if (this.Content == null) {
                    return null;
                }

                if (Bridge.is(this.Content, System.Windows.UIElement)) {
                    return Bridge.is(this.Template, System.Windows.Controls.ContentPresenter.UIElementTemplate) && Bridge.referenceEquals(Bridge.cast(this.Template, System.Windows.Controls.ContentPresenter.UIElementTemplate).Content, this.Content) ? this.Template : new System.Windows.Controls.ContentPresenter.UIElementTemplate(Bridge.cast(this.Content, System.Windows.UIElement));
                }

                if (this.ContentTemplate != null) {
                    return this.ContentTemplate;
                }

                if (this.ContentTemplateSelector != null) {
                    this.ContentTemplateSelector.System$Windows$Controls$IDataTemplateSelector$SelectTemplate(this.Content, this);
                }

                var dataTemplate = { };
                if (this.TryFindDataTemplate(Bridge.getType(this.Content), dataTemplate)) {
                    return dataTemplate.v;
                }

                return System.Windows.Controls.ContentPresenter.DefaultContentTemplate.Default;
            },
            TryFindDataTemplate: function (type, dataTemplate) {
                var value = { };

                if (this.TryGetResource(new System.Windows.TemplateKey(type), value)) {
                    dataTemplate.v = Bridge.as(value.v, System.Windows.DataTemplate);
                    return dataTemplate.v != null;
                }

                if (Bridge.Reflection.getBaseType(type) != null) {
                    return this.TryFindDataTemplate(Bridge.Reflection.getBaseType(type), dataTemplate);
                }

                dataTemplate.v = null;
                return false;
            },
            PrepareContainerForItem: function (item, itemTemplate, itemContainerStyle) {
                if (!this.ContainsValue(System.Windows.Controls.ContentPresenter.ContentTemplateProperty) && !this.ContainsValue(System.Windows.Controls.ContentPresenter.ContentTemplateSelectorProperty)) {
                    this.ContentTemplate = itemTemplate;
                    this.itemTemplate = itemTemplate;
                }

                if (!this.ContainsValue(System.Windows.FrameworkElement.StyleProperty)) {
                    this.Style = itemContainerStyle;
                    this.itemContainerStyle = itemContainerStyle;
                }

                this.Content = item;
            },
            ClearContainerForItem: function (item) {
                if (Bridge.referenceEquals(this.itemTemplate, this.ContentTemplate)) {
                    this.ClearValue(System.Windows.Controls.ContentPresenter.ContentTemplateProperty);
                    this.itemTemplate = null;
                }

                if (Bridge.referenceEquals(this.itemContainerStyle, this.Style)) {
                    this.ClearValue(System.Windows.FrameworkElement.StyleProperty);
                    this.itemContainerStyle = null;
                }

                this.ClearValue(System.Windows.Controls.ContentPresenter.ContentProperty);
            }
        }
    });

    Bridge.ns("System.Windows.Controls.ContentPresenter", $asm.$);

    Bridge.apply($asm.$.System.Windows.Controls.ContentPresenter, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.ContentPresenter).OnContentChanged(e);
        },
        f2: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.ContentPresenter).SetTemplate();
        }
    });

    Bridge.define("System.Windows.Controls.Image", {
        inherits: [System.Windows.FrameworkElement],
        statics: {
            fields: {
                ImageFailedEvent: null,
                SourceProperty: null,
                StretchProperty: null,
                StretchDirectionProperty: null
            },
            ctors: {
                init: function () {
                    this.ImageFailedEvent = System.Windows.EventManager.RegisterRoutedEvent("ImageFailed", System.Windows.RoutingStrategy.Bubble, Function, System.Windows.Controls.Image);
                    this.SourceProperty = System.Windows.DependencyProperty.Register("Source", System.Windows.Media.ImageSource, System.Windows.Controls.Image, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.Image.f1));
                    this.StretchProperty = System.Windows.DependencyProperty.Register("Stretch", System.Windows.Media.Stretch, System.Windows.Controls.Image, new System.Windows.FrameworkPropertyMetadata.$ctor2(Bridge.box(System.Windows.Media.Stretch.Uniform, System.Windows.Media.Stretch, System.Enum.toStringFn(System.Windows.Media.Stretch)), 3));
                    this.StretchDirectionProperty = System.Windows.DependencyProperty.Register("StretchDirection", System.Windows.Controls.StretchDirection, System.Windows.Controls.Image, new System.Windows.FrameworkPropertyMetadata.$ctor2(Bridge.box(System.Windows.Controls.StretchDirection.Both, System.Windows.Controls.StretchDirection, System.Enum.toStringFn(System.Windows.Controls.StretchDirection)), 3));
                },
                ctor: function () {
                    System.Windows.UIElement.ClipToBoundsProperty.OverrideMetadata(System.Windows.Controls.Image, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(true, System.Boolean, System.Boolean.toString)));
                }
            },
            methods: {
                GetStretchRect: function (size, availableSize, stretch, stretchDirection) {
                    if (System.Windows.SizeExtensions.IsNullOrEmpty(size) || System.Windows.Size.op_Equality(size, System.Windows.Size.Zero) || System.Windows.Size.op_Equality(availableSize, System.Windows.Size.Zero)) {
                        return System.Windows.Rect.Zero;
                    }

                    var stretchSize = System.Windows.Controls.Image.GetStretchSize(size, availableSize, stretch);

                    if (stretchDirection === System.Windows.Controls.StretchDirection.DownOnly) {
                        stretchSize = System.Windows.SizeExtensions.Min(stretchSize, size);
                    }

                    if (stretchDirection === System.Windows.Controls.StretchDirection.UpOnly) {
                        stretchSize = System.Windows.SizeExtensions.Max(stretchSize, size);
                    }

                    return new System.Windows.Rect.$ctor2(System.Windows.Point.op_Division((System.Windows.Point.op_Subtraction(System.Windows.SizeExtensions.ToPoint(availableSize), System.Windows.SizeExtensions.ToPoint(stretchSize))), 2), stretchSize);
                },
                GetStretchSize: function (imageSize, availableSize, stretch) {
                    switch (stretch) {
                        case System.Windows.Media.Stretch.None: 
                            return imageSize;
                        case System.Windows.Media.Stretch.Fill: 
                            return availableSize;
                        case System.Windows.Media.Stretch.Uniform: 
                            return imageSize.Height * availableSize.Width < imageSize.Width * availableSize.Height ? new System.Windows.Size(availableSize.Width, imageSize.Height * availableSize.Width / imageSize.Width) : new System.Windows.Size(imageSize.Width * availableSize.Height / imageSize.Height, availableSize.Height);
                        case System.Windows.Media.Stretch.UniformToFill: 
                            return imageSize.Height * availableSize.Width > imageSize.Width * availableSize.Height ? new System.Windows.Size(availableSize.Width, imageSize.Height * availableSize.Width / imageSize.Width) : new System.Windows.Size(imageSize.Width * availableSize.Height / imageSize.Height, availableSize.Height);
                        default: 
                            throw new Granular.Exception("Unexpected Stretch \"{0}\"", [Bridge.box(stretch, System.Windows.Media.Stretch, System.Enum.toStringFn(System.Windows.Media.Stretch))]);
                    }
                }
            }
        },
        fields: {
            bitmapSource: null,
            imageRenderElement: null
        },
        props: {
            Source: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.Image.SourceProperty), System.Windows.Media.ImageSource);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Image.SourceProperty, value);
                }
            },
            Stretch: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Image.StretchProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Image.StretchProperty, Bridge.box(value, System.Windows.Media.Stretch, System.Enum.toStringFn(System.Windows.Media.Stretch)));
                }
            },
            StretchDirection: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Image.StretchDirectionProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Image.StretchDirectionProperty, Bridge.box(value, System.Windows.Controls.StretchDirection, System.Enum.toStringFn(System.Windows.Controls.StretchDirection)));
                }
            },
            BitmapSource: {
                get: function () {
                    return this.bitmapSource;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.bitmapSource, value)) {
                        return;
                    }

                    if (this.bitmapSource != null) {
                        this.bitmapSource.removeDownloadCompleted(Bridge.fn.cacheBind(this, this.OnBitmapSourceDownloadCompleted));
                        this.bitmapSource.removeDownloadFailed(Bridge.fn.cacheBind(this, this.OnBitmapSourceDownloadFailed));
                    }

                    this.bitmapSource = value;

                    if (this.bitmapSource != null) {
                        this.bitmapSource.addDownloadCompleted(Bridge.fn.cacheBind(this, this.OnBitmapSourceDownloadCompleted));
                        this.bitmapSource.addDownloadFailed(Bridge.fn.cacheBind(this, this.OnBitmapSourceDownloadFailed));
                    }
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.FrameworkElement.ctor.call(this);
                //
            }
        },
        methods: {
            addImageFailed: function (value) {
                this.AddHandler(System.Windows.Controls.Image.ImageFailedEvent, value);
            },
            removeImageFailed: function (value) {
                this.RemoveHandler(System.Windows.Controls.Image.ImageFailedEvent, value);
            },
            CreateRenderElementContentOverride: function (factory) {
                if (this.imageRenderElement == null) {
                    this.imageRenderElement = factory.System$Windows$Media$IRenderElementFactory$CreateImageRenderElement(this);

                    if (this.Source != null) {
                        this.imageRenderElement.System$Windows$Media$IImageRenderElement$Bounds = System.Windows.Controls.Image.GetStretchRect(this.Source.Size, this.VisualBounds.Size, this.Stretch, this.StretchDirection);
                        this.imageRenderElement.System$Windows$Media$IImageRenderElement$Source = this.Source;
                    }
                }

                return this.imageRenderElement;
            },
            MeasureOverride: function (availableSize) {
                if ((this.Stretch === System.Windows.Media.Stretch.None || this.StretchDirection === System.Windows.Controls.StretchDirection.UpOnly) && this.Source != null) {
                    return System.Windows.SizeExtensions.DefaultIfNullOrEmpty(this.Source.Size);
                }

                return System.Windows.Size.Zero;
            },
            ArrangeOverride: function (finalSize) {
                this.SetRenderElements(this.Source, finalSize);

                return finalSize;
            },
            OnSourceChanged: function (e) {
                this.BitmapSource = Bridge.as(this.Source, System.Windows.Media.Imaging.BitmapSource);

                this.SetRenderElements(this.Source, this.RenderSize);

                this.InvalidateMeasure();
            },
            OnBitmapSourceDownloadCompleted: function (sender, e) {
                this.SetRenderElements(this.Source, this.RenderSize);

                this.InvalidateMeasure();
            },
            OnBitmapSourceDownloadFailed: function (sender, e) {
                this.RaiseEvent(new System.Windows.RoutedEventArgs(System.Windows.Controls.Image.ImageFailedEvent, this));
            },
            SetRenderElements: function (source, availableSize) {
                var bounds = source != null ? System.Windows.Controls.Image.GetStretchRect(source.Size, availableSize, this.Stretch, this.StretchDirection) : System.Windows.Rect.Zero;

                if (this.imageRenderElement != null) {
                    this.imageRenderElement.System$Windows$Media$IImageRenderElement$Bounds = bounds;
                    this.imageRenderElement.System$Windows$Media$IImageRenderElement$Source = source;
                }
            }
        }
    });

    Bridge.ns("System.Windows.Controls.Image", $asm.$);

    Bridge.apply($asm.$.System.Windows.Controls.Image, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.Image).OnSourceChanged(e);
        }
    });

    Bridge.define("System.Windows.Controls.ItemsPresenter", {
        inherits: [System.Windows.FrameworkElement],
        statics: {
            fields: {
                ItemContainerGeneratorProperty: null,
                TemplateProperty: null
            },
            ctors: {
                init: function () {
                    this.ItemContainerGeneratorProperty = System.Windows.DependencyProperty.Register("ItemContainerGenerator", System.Windows.Controls.Primitives.IItemContainerGenerator, System.Windows.Controls.ItemsPresenter, new System.Windows.FrameworkPropertyMetadata.$ctor6(null, $asm.$.System.Windows.Controls.ItemsPresenter.f1));
                    this.TemplateProperty = System.Windows.DependencyProperty.Register("Template", System.Windows.IFrameworkTemplate, System.Windows.Controls.ItemsPresenter, new System.Windows.FrameworkPropertyMetadata.$ctor6(null, $asm.$.System.Windows.Controls.ItemsPresenter.f2));
                }
            }
        },
        fields: {
            panel: null
        },
        props: {
            ItemContainerGenerator: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.ItemsPresenter.ItemContainerGeneratorProperty), System.Windows.Controls.Primitives.IItemContainerGenerator);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.ItemsPresenter.ItemContainerGeneratorProperty, value);
                }
            },
            Template: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.ItemsPresenter.TemplateProperty), System.Windows.IFrameworkTemplate);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.ItemsPresenter.TemplateProperty, value);
                }
            },
            Panel: {
                get: function () {
                    return this.panel;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.panel, value)) {
                        return;
                    }

                    if (this.panel != null) {
                        this.panel.ItemContainerGenerator = null;
                    }

                    this.panel = value;

                    if (this.panel != null) {
                        this.panel.ItemContainerGenerator = this.ItemContainerGenerator;
                    }
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.FrameworkElement.ctor.call(this);
                //
            }
        },
        methods: {
            MeasureOverride: function (availableSize) {
                if (this.Panel == null) {
                    return System.Windows.Size.Zero;
                }

                this.Panel.Measure(availableSize);
                return this.Panel.DesiredSize;
            },
            ArrangeOverride: function (finalSize) {
                if (this.Panel != null) {
                    this.Panel.Arrange(new System.Windows.Rect.$ctor3(finalSize));
                }

                return finalSize;
            },
            GetTemplate: function () {
                return this.Template;
            },
            OnItemContainerGeneratorChanged: function (e) {
                if (this.Panel != null) {
                    this.Panel.ItemContainerGenerator = this.ItemContainerGenerator;
                }
            },
            OnTemplateChanged: function (e) {
                if (this.ItemContainerGenerator != null) {
                    this.ItemContainerGenerator.System$Windows$Controls$Primitives$IItemContainerGenerator$RemoveRange(0, this.ItemContainerGenerator.System$Windows$Controls$Primitives$IItemContainerGenerator$ItemsCount);
                }

                this.ApplyTemplate();

                this.Panel = Bridge.as(System.Linq.Enumerable.from(this.VisualChildren).firstOrDefault(null, null), System.Windows.Controls.Panel);
            }
        }
    });

    Bridge.ns("System.Windows.Controls.ItemsPresenter", $asm.$);

    Bridge.apply($asm.$.System.Windows.Controls.ItemsPresenter, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.ItemsPresenter).OnItemContainerGeneratorChanged(e);
        },
        f2: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.ItemsPresenter).OnTemplateChanged(e);
        }
    });

    Bridge.define("System.Windows.Controls.PopupLayer", {
        inherits: [System.Windows.FrameworkElement],
        statics: {
            fields: {
                PositionProperty: null,
                IsOpenProperty: null,
                StaysOpenProperty: null
            },
            ctors: {
                init: function () {
                    this.PositionProperty = System.Windows.DependencyProperty.RegisterAttached("Position", System.Windows.Point, System.Windows.Controls.PopupLayer, new System.Windows.FrameworkPropertyMetadata.$ctor6(System.Windows.Point.Zero, System.Windows.Controls.PopupLayer.OnPositionChanged));
                    this.IsOpenProperty = System.Windows.DependencyProperty.RegisterAttached("IsOpen", System.Boolean, System.Windows.Controls.PopupLayer, new System.Windows.FrameworkPropertyMetadata.$ctor11(System.Windows.Controls.PopupLayer.OnIsOpenChanged));
                    this.StaysOpenProperty = System.Windows.DependencyProperty.RegisterAttached("StaysOpen", System.Boolean, System.Windows.Controls.PopupLayer, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(true, System.Boolean, System.Boolean.toString)));
                }
            },
            methods: {
                GetPosition: function (obj) {
                    return Bridge.cast(obj.GetValue(System.Windows.Controls.PopupLayer.PositionProperty), System.Windows.Point);
                },
                SetPosition: function (obj, value) {
                    obj.SetValue(System.Windows.Controls.PopupLayer.PositionProperty, value);
                },
                GetIsOpen: function (obj) {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj.GetValue(System.Windows.Controls.PopupLayer.IsOpenProperty)), System.Boolean));
                },
                SetIsOpen: function (obj, value) {
                    obj.SetValue(System.Windows.Controls.PopupLayer.IsOpenProperty, Bridge.box(value, System.Boolean, System.Boolean.toString));
                },
                GetStaysOpen: function (obj) {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj.GetValue(System.Windows.Controls.PopupLayer.StaysOpenProperty)), System.Boolean));
                },
                SetStaysOpen: function (obj, value) {
                    obj.SetValue(System.Windows.Controls.PopupLayer.StaysOpenProperty, Bridge.box(value, System.Boolean, System.Boolean.toString));
                },
                GetPopupLayer: function (target) {
                    if (target == null) {
                        return null;
                    }

                    return Bridge.is(target, System.Windows.Controls.IPopupLayerHost) ? Bridge.cast(target, System.Windows.Controls.IPopupLayerHost).System$Windows$Controls$IPopupLayerHost$PopupLayer : System.Windows.Controls.PopupLayer.GetPopupLayer(target.VisualParent);
                },
                OnIsOpenChanged: function (dependencyObject, e) {
                    if (System.Nullable.getValue(Bridge.cast(Bridge.unbox(e.NewValue), System.Boolean)) && Bridge.is(dependencyObject, System.Windows.Media.Visual) && Bridge.is(Bridge.cast(dependencyObject, System.Windows.Media.Visual).VisualParent, System.Windows.Controls.PopupLayer)) {
                        Bridge.cast(Bridge.cast(dependencyObject, System.Windows.Media.Visual).VisualParent, System.Windows.Controls.PopupLayer).BringToFront(Bridge.cast(dependencyObject, System.Windows.Media.Visual));
                    }
                },
                OnPositionChanged: function (dependencyObject, e) {
                    if (Bridge.is(dependencyObject, System.Windows.Media.Visual) && Bridge.is(Bridge.cast(dependencyObject, System.Windows.Media.Visual).VisualParent, System.Windows.Controls.PopupLayer)) {
                        Bridge.cast(Bridge.cast(dependencyObject, System.Windows.Media.Visual).VisualParent, System.Windows.Controls.PopupLayer).InvalidateArrange();
                    }
                }
            }
        },
        events: {
            ClosePopupRequest: null
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.FrameworkElement.ctor.call(this);
                //
            }
        },
        methods: {
            MeasureOverride: function (availableSize) {
                var $t;
                $t = Bridge.getEnumerator(this.VisualChildren);
                try {
                    while ($t.moveNext()) {
                        var child = Bridge.cast($t.Current, System.Windows.UIElement);
                        child.Measure(availableSize);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                return System.Windows.Size.Zero;
            },
            ArrangeOverride: function (finalSize) {
                var $t;
                $t = Bridge.getEnumerator(this.VisualChildren);
                try {
                    while ($t.moveNext()) {
                        var child = Bridge.cast($t.Current, System.Windows.UIElement);
                        child.Arrange(new System.Windows.Rect.$ctor2(System.Windows.Controls.PopupLayer.GetPosition(child), child.DesiredSize));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                return finalSize;
            },
            AddChild: function (child) {
                this.AddVisualChild(child);
                this.BringToFront(child);

                this.InvalidateMeasure();
            },
            RemoveChild: function (child) {
                this.RemoveVisualChild(child);

                this.InvalidateMeasure();
            },
            OnMouseDown: function (e) {
                if (Bridge.referenceEquals(e.OriginalSource, this)) {
                    Granular.Extensions.EventHandlerExtensions.Raise$2(this.ClosePopupRequest, this);
                    e.Handled = e.MouseDevice.ProcessRawEvent(new System.Windows.Input.RawMouseButtonEventArgs(e.ChangedButton, e.ButtonState, e.AbsolutePosition, e.Timestamp));
                }
            },
            HitTestOverride: function (position) {
                // receive a click if there is a non "StaysOpen" child opened
                return System.Linq.Enumerable.from(this.VisualChildren).any($asm.$.System.Windows.Controls.PopupLayer.f1);
            },
            BringToFront: function (child) {
                this.SetVisualChildIndex(child, ((System.Linq.Enumerable.from(this.VisualChildren).count() - 1) | 0));
            }
        }
    });

    Bridge.ns("System.Windows.Controls.PopupLayer", $asm.$);

    Bridge.apply($asm.$.System.Windows.Controls.PopupLayer, {
        f1: function (child) {
            return System.Windows.Controls.PopupLayer.GetIsOpen(child) && !System.Windows.Controls.PopupLayer.GetStaysOpen(child);
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.Popup", {
        inherits: [System.Windows.FrameworkElement],
        statics: {
            fields: {
                HorizontalOffsetProperty: null,
                VerticalOffsetProperty: null,
                PlacementProperty: null,
                PlacementRectangleProperty: null,
                PlacementTargetProperty: null,
                IsOpenProperty: null,
                StaysOpenProperty: null
            },
            ctors: {
                init: function () {
                    this.HorizontalOffsetProperty = System.Windows.DependencyProperty.Register("HorizontalOffset", System.Double, System.Windows.Controls.Primitives.Popup, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.Primitives.Popup.f1));
                    this.VerticalOffsetProperty = System.Windows.DependencyProperty.Register("VerticalOffset", System.Double, System.Windows.Controls.Primitives.Popup, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.Primitives.Popup.f1));
                    this.PlacementProperty = System.Windows.DependencyProperty.Register("Placement", System.Windows.Controls.Primitives.PlacementMode, System.Windows.Controls.Primitives.Popup, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.Primitives.Popup.f1));
                    this.PlacementRectangleProperty = System.Windows.DependencyProperty.Register("PlacementRectangle", System.Windows.Rect, System.Windows.Controls.Primitives.Popup, new System.Windows.FrameworkPropertyMetadata.$ctor6(System.Windows.Rect.Empty, $asm.$.System.Windows.Controls.Primitives.Popup.f1));
                    this.PlacementTargetProperty = System.Windows.DependencyProperty.Register("PlacementTarget", System.Windows.Media.Visual, System.Windows.Controls.Primitives.Popup, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.Primitives.Popup.f1));
                    this.IsOpenProperty = System.Windows.DependencyProperty.Register("IsOpen", System.Boolean, System.Windows.Controls.Primitives.Popup, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.Primitives.Popup.f2));
                    this.StaysOpenProperty = System.Windows.DependencyProperty.Register("StaysOpen", System.Boolean, System.Windows.Controls.Primitives.Popup, new System.Windows.FrameworkPropertyMetadata.$ctor6(Bridge.box(true, System.Boolean, System.Boolean.toString), $asm.$.System.Windows.Controls.Primitives.Popup.f3));
                }
            }
        },
        fields: {
            child: null,
            popupLayer: null,
            popupContainer: null
        },
        events: {
            Opened: null,
            Closed: null
        },
        props: {
            HorizontalOffset: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.Popup.HorizontalOffsetProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.Popup.HorizontalOffsetProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            VerticalOffset: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.Popup.VerticalOffsetProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.Popup.VerticalOffsetProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            Placement: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.Popup.PlacementProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.Popup.PlacementProperty, Bridge.box(value, System.Windows.Controls.Primitives.PlacementMode, System.Enum.toStringFn(System.Windows.Controls.Primitives.PlacementMode)));
                }
            },
            PlacementRectangle: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.Primitives.Popup.PlacementRectangleProperty), System.Windows.Rect);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.Popup.PlacementRectangleProperty, value);
                }
            },
            PlacementTarget: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.Primitives.Popup.PlacementTargetProperty), System.Windows.Media.Visual);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.Popup.PlacementTargetProperty, value);
                }
            },
            IsOpen: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.Popup.IsOpenProperty)), System.Boolean));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.Popup.IsOpenProperty, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            },
            StaysOpen: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.Popup.StaysOpenProperty)), System.Boolean));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.Popup.StaysOpenProperty, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            },
            Child: {
                get: function () {
                    return this.child;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.child, value)) {
                        return;
                    }

                    if (this.child != null) {
                        this.RemoveLogicalChild(this.child);
                    }

                    this.child = value;
                    this.popupContainer.Child = this.child;

                    if (this.child != null) {
                        this.AddLogicalChild(this.child);
                    }
                }
            },
            PopupLayer: {
                get: function () {
                    return this.popupLayer;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.popupLayer, value)) {
                        return;
                    }

                    if (this.popupLayer != null) {
                        this.popupLayer.RemoveChild(this.popupContainer);
                        this.popupLayer.removeClosePopupRequest(Bridge.fn.cacheBind(this, this.OnClosePopupRequest));
                    }

                    this.popupLayer = value;

                    if (this.popupLayer != null) {
                        this.popupLayer.AddChild(this.popupContainer);
                        this.popupLayer.addClosePopupRequest(Bridge.fn.cacheBind(this, this.OnClosePopupRequest));
                    }

                    this.SetPosition();
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.FrameworkElement.ctor.call(this);
                this.popupContainer = new System.Windows.Controls.Primitives.Popup.PopupContainer();
            }
        },
        methods: {
            OnOpened: function () {
                //
            },
            OnClosed: function () {
                //
            },
            OnVisualAncestorChanged: function () {
                System.Windows.FrameworkElement.prototype.OnVisualAncestorChanged.call(this);
                this.PopupLayer = System.Windows.Controls.PopupLayer.GetPopupLayer(this);
            },
            OnStaysOpenChanged: function (e) {
                System.Windows.Controls.PopupLayer.SetStaysOpen(this.popupContainer, System.Nullable.getValue(Bridge.cast(Bridge.unbox(e.NewValue), System.Boolean)));
            },
            OnIsOpenChanged: function (e) {
                var isOpen = System.Nullable.getValue(Bridge.cast(Bridge.unbox(e.NewValue), System.Boolean));

                this.popupContainer.IsOpen = isOpen;

                if (isOpen) {
                    this.SetPosition();

                    this.OnOpened();
                    Granular.Extensions.EventHandlerExtensions.Raise$2(this.Opened, this);
                } else {
                    this.OnClosed();
                    Granular.Extensions.EventHandlerExtensions.Raise$2(this.Closed, this);
                }
            },
            OnClosePopupRequest: function (sender, e) {
                if (!this.StaysOpen) {
                    this.IsOpen = false;
                }
            },
            SetPosition: function () {
                if (this.PopupLayer != null && this.IsOpen) {
                    this.popupContainer.Measure(this.PopupLayer.VisualSize);
                    var popupSize = this.popupContainer.DesiredSize;
                    var placementTargetRect = this.PlacementTarget != null ? new System.Windows.Rect.$ctor2(this.PopupLayer.PointFromRoot(this.PlacementTarget.PointToRoot(System.Windows.Point.Zero)), this.PlacementTarget.VisualSize) : System.Windows.Rect.Zero;
                    var position = System.Windows.Controls.Primitives.Placement.GetPosition(this.Placement, placementTargetRect, this.PlacementRectangle, this.GetMouseBounds(), new System.Windows.Point.$ctor1(this.HorizontalOffset, this.VerticalOffset), popupSize, new System.Windows.Rect.$ctor3(this.PopupLayer.VisualSize));

                    this.popupContainer.Position = position;
                    this.PopupLayer.UpdateLayout();
                }
            },
            GetMouseBounds: function () {
                if (this.Placement !== System.Windows.Controls.Primitives.PlacementMode.Mouse && this.Placement !== System.Windows.Controls.Primitives.PlacementMode.MousePoint) {
                    return System.Windows.Rect.Zero;
                }

                return new System.Windows.Rect.$ctor2(this.PopupLayer.PointFromRoot(System.Windows.ApplicationHostExtensions.GetMouseDeviceFromElement(System.Windows.ApplicationHost.Current, this.PopupLayer).Position), new System.Windows.Size(12, 19));
            }
        }
    });

    Bridge.ns("System.Windows.Controls.Primitives.Popup", $asm.$);

    Bridge.apply($asm.$.System.Windows.Controls.Primitives.Popup, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.Primitives.Popup).SetPosition();
        },
        f2: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.Primitives.Popup).OnIsOpenChanged(e);
        },
        f3: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.Primitives.Popup).OnStaysOpenChanged(e);
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.Popup.PopupContainer", {
        inherits: [System.Windows.FrameworkElement,System.Windows.Documents.IAdornerLayerHost],
        fields: {
            child: null,
            position: null,
            isOpen: false
        },
        props: {
            AdornerLayer: null,
            Child: {
                get: function () {
                    return this.child;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.child, value)) {
                        return;
                    }

                    if (this.child != null) {
                        this.RemoveVisualChild(this.child);
                    }

                    this.child = value;

                    if (this.child != null) {
                        this.AddVisualChild(this.child);
                        this.SetVisualChildIndex(this.child, 0);
                    }

                    this.InvalidateMeasure();
                }
            },
            Position: {
                get: function () {
                    return this.position;
                },
                set: function (value) {
                    this.position = value;
                    System.Windows.Controls.PopupLayer.SetPosition(this, this.position);
                }
            },
            IsOpen: {
                get: function () {
                    return this.isOpen;
                },
                set: function (value) {
                    this.isOpen = value;
                    this.Visibility = this.isOpen ? System.Windows.Visibility.Visible : System.Windows.Visibility.Collapsed;
                    System.Windows.Controls.PopupLayer.SetIsOpen(this, this.isOpen);
                }
            }
        },
        alias: ["AdornerLayer", "System$Windows$Documents$IAdornerLayerHost$AdornerLayer"],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.FrameworkElement.ctor.call(this);
                this.Visibility = System.Windows.Visibility.Collapsed;

                this.AdornerLayer = new System.Windows.Documents.AdornerLayer();
                this.AddVisualChild(this.AdornerLayer);
            }
        },
        methods: {
            MeasureOverride: function (availableSize) {
                this.AdornerLayer.Measure(availableSize);

                if (this.Child == null) {
                    return System.Windows.Size.Zero;
                }

                this.Child.Measure(availableSize);
                return this.Child.DesiredSize;
            },
            ArrangeOverride: function (finalSize) {
                this.AdornerLayer.Arrange(new System.Windows.Rect.$ctor3(finalSize));

                if (this.Child != null) {
                    this.Child.Arrange(new System.Windows.Rect.$ctor3(finalSize));
                }

                return finalSize;
            }
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.Track", {
        inherits: [System.Windows.FrameworkElement],
        statics: {
            fields: {
                OrientationProperty: null,
                MinimumProperty: null,
                MaximumProperty: null,
                ValueProperty: null,
                ViewportSizeProperty: null
            },
            ctors: {
                init: function () {
                    this.OrientationProperty = System.Windows.DependencyProperty.Register("Orientation", System.Windows.Controls.Orientation, System.Windows.Controls.Primitives.Track, new System.Windows.FrameworkPropertyMetadata.$ctor8(System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure));
                    this.MinimumProperty = System.Windows.DependencyProperty.Register("Minimum", System.Double, System.Windows.Controls.Primitives.Track, new System.Windows.FrameworkPropertyMetadata.$ctor8(System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange));
                    this.MaximumProperty = System.Windows.DependencyProperty.Register("Maximum", System.Double, System.Windows.Controls.Primitives.Track, new System.Windows.FrameworkPropertyMetadata.$ctor2(Bridge.box(1.0, System.Double, System.Double.format, System.Double.getHashCode), System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange));
                    this.ValueProperty = System.Windows.DependencyProperty.Register("Value", System.Double, System.Windows.Controls.Primitives.Track, new System.Windows.FrameworkPropertyMetadata.$ctor8(258));
                    this.ViewportSizeProperty = System.Windows.DependencyProperty.Register("ViewportSize", System.Double, System.Windows.Controls.Primitives.Track, new System.Windows.FrameworkPropertyMetadata.$ctor2(Bridge.box(Number.NaN, System.Double, System.Double.format, System.Double.getHashCode), System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange));
                }
            }
        },
        fields: {
            decreaseRepeatButton: null,
            increaseRepeatButton: null,
            thumb: null
        },
        props: {
            Orientation: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.Track.OrientationProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.Track.OrientationProperty, Bridge.box(value, System.Windows.Controls.Orientation, System.Enum.toStringFn(System.Windows.Controls.Orientation)));
                }
            },
            Minimum: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.Track.MinimumProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.Track.MinimumProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            Maximum: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.Track.MaximumProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.Track.MaximumProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            Value: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.Track.ValueProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.Track.ValueProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            ViewportSize: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.Track.ViewportSizeProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.Track.ViewportSizeProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            DecreaseRepeatButton: {
                get: function () {
                    return this.decreaseRepeatButton;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.decreaseRepeatButton, value)) {
                        return;
                    }

                    if (this.decreaseRepeatButton != null) {
                        this.RemoveVisualChild(this.decreaseRepeatButton);
                    }

                    this.decreaseRepeatButton = value;

                    if (this.decreaseRepeatButton != null) {
                        this.AddVisualChild(this.decreaseRepeatButton);
                    }
                }
            },
            IncreaseRepeatButton: {
                get: function () {
                    return this.increaseRepeatButton;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.increaseRepeatButton, value)) {
                        return;
                    }

                    if (this.increaseRepeatButton != null) {
                        this.RemoveVisualChild(this.increaseRepeatButton);
                    }

                    this.increaseRepeatButton = value;

                    if (this.increaseRepeatButton != null) {
                        this.AddVisualChild(this.increaseRepeatButton);
                    }
                }
            },
            Thumb: {
                get: function () {
                    return this.thumb;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.thumb, value)) {
                        return;
                    }

                    if (this.thumb != null) {
                        this.RemoveVisualChild(this.thumb);
                    }

                    this.thumb = value;

                    if (this.thumb != null) {
                        this.AddVisualChild(this.thumb);
                    }
                }
            },
            ThumbMinLength: 0
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.FrameworkElement.ctor.call(this);
                this.ThumbMinLength = 24;
            }
        },
        methods: {
            MeasureOverride: function (availableSize) {
                if (this.Thumb != null) {
                    this.Thumb.Measure(availableSize);
                    return System.Windows.SizeExtensions.Combine(this.GetMainSize(0), this.Thumb.DesiredSize);
                }

                return System.Windows.Size.Zero;
            },
            ArrangeOverride: function (finalSize) {
                var mainLength = this.GetMainLength(finalSize);
                var crossLength = this.GetCrossLength(finalSize);

                // the scrollable range (Maximum - Minimum) equals to (ExtentSize - ViewportSize)
                // the thumb ratio should be (ViewportSize / ExtentSize) = (ViewportSize / (ViewportSize + Maximum - Minimum))
                var thumbMainLength = Granular.Extensions.DoubleExtensions.Bounds((isNaN(this.ViewportSize) ? (this.Thumb == null ? 0 : this.GetMainLength(this.Thumb.DesiredSize)) : (mainLength * this.ViewportSize / (this.ViewportSize + this.Maximum - this.Minimum))), this.ThumbMinLength, Granular.Extensions.DoubleExtensions.Max(this.ThumbMinLength, mainLength));

                // the decrease and increase buttons fill the remaining area (these buttons are usually transparent)
                var decreaseButtonMainLength = this.Maximum === this.Minimum ? 0 : (mainLength - thumbMainLength) * (Granular.Extensions.DoubleExtensions.Min(this.Value, this.Maximum) - this.Minimum) / (this.Maximum - this.Minimum);
                var increaseButtonMainLength = mainLength - thumbMainLength - decreaseButtonMainLength;

                if (this.DecreaseRepeatButton != null && this.IncreaseRepeatButton != null) {
                    this.ArrangeChild(this.DecreaseRepeatButton, 0, 0, decreaseButtonMainLength, crossLength);
                    this.ArrangeChild(this.IncreaseRepeatButton, decreaseButtonMainLength + thumbMainLength, 0, increaseButtonMainLength, crossLength);
                }

                if (this.Thumb != null) {
                    this.ArrangeChild(this.Thumb, decreaseButtonMainLength, 0, thumbMainLength, crossLength);
                }

                return finalSize;
            },
            GetMainLength: function (size) {
                return this.Orientation === System.Windows.Controls.Orientation.Horizontal ? size.Width : size.Height;
            },
            GetCrossLength: function (size) {
                return this.Orientation === System.Windows.Controls.Orientation.Horizontal ? size.Height : size.Width;
            },
            GetMainSize: function (length) {
                return this.Orientation === System.Windows.Controls.Orientation.Horizontal ? System.Windows.Size.FromWidth(length) : System.Windows.Size.FromHeight(length);
            },
            ArrangeChild: function (child, finalMainStart, finalCrossStart, finalMainLength, finalCrossLength) {
                child.Arrange(this.Orientation === System.Windows.Controls.Orientation.Horizontal ? new System.Windows.Rect.$ctor1(finalMainStart, finalCrossStart, Granular.Extensions.DoubleExtensions.Max(finalMainLength, 0), Granular.Extensions.DoubleExtensions.Max(finalCrossLength, 0)) : new System.Windows.Rect.$ctor1(finalCrossStart, finalMainStart, Granular.Extensions.DoubleExtensions.Max(finalCrossLength, 0), Granular.Extensions.DoubleExtensions.Max(finalMainLength, 0)));
            }
        }
    });

    Bridge.define("System.Windows.Controls.TextBlock", {
        inherits: [System.Windows.FrameworkElement],
        statics: {
            fields: {
                TextProperty: null,
                ForegroundProperty: null,
                FontFamilyProperty: null,
                FontSizeProperty: null,
                FontStyleProperty: null,
                FontWeightProperty: null,
                FontStretchProperty: null,
                TextAlignmentProperty: null,
                TextTrimmingProperty: null,
                TextWrappingProperty: null
            },
            ctors: {
                init: function () {
                    this.TextProperty = System.Windows.DependencyProperty.Register("Text", System.String, System.Windows.Controls.TextBlock, new System.Windows.FrameworkPropertyMetadata.$ctor9(System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure, $asm.$.System.Windows.Controls.TextBlock.f1));
                    this.ForegroundProperty = System.Windows.Documents.TextElement.ForegroundProperty.AddOwner(System.Windows.Controls.TextBlock, new System.Windows.FrameworkPropertyMetadata.$ctor3(System.Windows.Media.Brushes.Black, System.Windows.FrameworkPropertyMetadataOptions.Inherits, $asm.$.System.Windows.Controls.TextBlock.f2));
                    this.FontFamilyProperty = System.Windows.Documents.TextElement.FontFamilyProperty.AddOwner(System.Windows.Controls.TextBlock, new System.Windows.FrameworkPropertyMetadata.$ctor9(33, $asm.$.System.Windows.Controls.TextBlock.f3));
                    this.FontSizeProperty = System.Windows.Documents.TextElement.FontSizeProperty.AddOwner(System.Windows.Controls.TextBlock, new System.Windows.FrameworkPropertyMetadata.$ctor9(33, $asm.$.System.Windows.Controls.TextBlock.f4));
                    this.FontStyleProperty = System.Windows.Documents.TextElement.FontStyleProperty.AddOwner(System.Windows.Controls.TextBlock, new System.Windows.FrameworkPropertyMetadata.$ctor9(33, $asm.$.System.Windows.Controls.TextBlock.f5));
                    this.FontWeightProperty = System.Windows.Documents.TextElement.FontWeightProperty.AddOwner(System.Windows.Controls.TextBlock, new System.Windows.FrameworkPropertyMetadata.$ctor9(33, $asm.$.System.Windows.Controls.TextBlock.f6));
                    this.FontStretchProperty = System.Windows.Documents.TextElement.FontStretchProperty.AddOwner(System.Windows.Controls.TextBlock, new System.Windows.FrameworkPropertyMetadata.$ctor9(33, $asm.$.System.Windows.Controls.TextBlock.f7));
                    this.TextAlignmentProperty = System.Windows.Documents.Block.TextAlignmentProperty.AddOwner(System.Windows.Controls.TextBlock, new System.Windows.FrameworkPropertyMetadata.$ctor9(System.Windows.FrameworkPropertyMetadataOptions.Inherits, $asm.$.System.Windows.Controls.TextBlock.f8));
                    this.TextTrimmingProperty = System.Windows.DependencyProperty.Register("TextTrimming", System.Windows.TextTrimming, System.Windows.Controls.TextBlock, new System.Windows.FrameworkPropertyMetadata.$ctor9(33, $asm.$.System.Windows.Controls.TextBlock.f9));
                    this.TextWrappingProperty = System.Windows.DependencyProperty.Register("TextWrapping", System.Windows.TextWrapping, System.Windows.Controls.TextBlock, new System.Windows.FrameworkPropertyMetadata.$ctor3(Bridge.box(System.Windows.TextWrapping.NoWrap, System.Windows.TextWrapping, System.Enum.toStringFn(System.Windows.TextWrapping)), 33, $asm.$.System.Windows.Controls.TextBlock.f10));
                }
            }
        },
        fields: {
            textBlockRenderElement: null,
            noWrapSize: null
        },
        props: {
            Text: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.TextBlock.TextProperty), System.String);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.TextBlock.TextProperty, value);
                }
            },
            Foreground: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.TextBlock.ForegroundProperty), System.Windows.Media.Brush);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.TextBlock.ForegroundProperty, value);
                }
            },
            FontFamily: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.TextBlock.FontFamilyProperty), System.Windows.Media.FontFamily);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.TextBlock.FontFamilyProperty, value);
                }
            },
            FontSize: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.TextBlock.FontSizeProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.TextBlock.FontSizeProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            FontStyle: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.TextBlock.FontStyleProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.TextBlock.FontStyleProperty, Bridge.box(value, System.Windows.FontStyle, System.Enum.toStringFn(System.Windows.FontStyle)));
                }
            },
            FontWeight: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.TextBlock.FontWeightProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.TextBlock.FontWeightProperty, Bridge.box(value, System.Windows.FontWeight, System.Enum.toStringFn(System.Windows.FontWeight)));
                }
            },
            FontStretch: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.TextBlock.FontStretchProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.TextBlock.FontStretchProperty, Bridge.box(value, System.Windows.FontStretch, System.Enum.toStringFn(System.Windows.FontStretch)));
                }
            },
            TextAlignment: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.TextBlock.TextAlignmentProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.TextBlock.TextAlignmentProperty, Bridge.box(value, System.Windows.TextAlignment, System.Enum.toStringFn(System.Windows.TextAlignment)));
                }
            },
            TextTrimming: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.TextBlock.TextTrimmingProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.TextBlock.TextTrimmingProperty, Bridge.box(value, System.Windows.TextTrimming, System.Enum.toStringFn(System.Windows.TextTrimming)));
                }
            },
            TextWrapping: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.TextBlock.TextWrappingProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.TextBlock.TextWrappingProperty, Bridge.box(value, System.Windows.TextWrapping, System.Enum.toStringFn(System.Windows.TextWrapping)));
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.FrameworkElement.ctor.call(this);
                //
            }
        },
        methods: {
            CreateRenderElementContentOverride: function (factory) {
                if (this.textBlockRenderElement == null) {
                    this.textBlockRenderElement = factory.System$Windows$Media$IRenderElementFactory$CreateTextBlockRenderElement(this);

                    this.textBlockRenderElement.System$Windows$Media$ITextBlockRenderElement$Bounds = new System.Windows.Rect.$ctor3(this.VisualBounds.Size);
                    this.textBlockRenderElement.System$Windows$Media$ITextBlockRenderElement$FontFamily = this.FontFamily;
                    this.textBlockRenderElement.System$Windows$Media$ITextBlockRenderElement$Foreground = this.Foreground;
                    this.textBlockRenderElement.System$Windows$Media$ITextBlockRenderElement$FontSize = this.FontSize;
                    this.textBlockRenderElement.System$Windows$Media$ITextBlockRenderElement$FontStyle = this.FontStyle;
                    this.textBlockRenderElement.System$Windows$Media$ITextBlockRenderElement$FontStretch = this.FontStretch;
                    this.textBlockRenderElement.System$Windows$Media$ITextBlockRenderElement$FontWeight = this.FontWeight;
                    this.textBlockRenderElement.System$Windows$Media$ITextBlockRenderElement$Text = this.Text;
                    this.textBlockRenderElement.System$Windows$Media$ITextBlockRenderElement$TextAlignment = this.TextAlignment;
                    this.textBlockRenderElement.System$Windows$Media$ITextBlockRenderElement$TextTrimming = this.TextTrimming;
                    this.textBlockRenderElement.System$Windows$Media$ITextBlockRenderElement$TextWrapping = this.TextWrapping;
                }

                return this.textBlockRenderElement;
            },
            MeasureOverride: function (availableSize) {
                var $t, $t1;
                if (System.Windows.Size.op_Equality(this.noWrapSize, null)) {
                    this.noWrapSize = System.Windows.ApplicationHost.Current.System$Windows$IApplicationHost$TextMeasurementService.System$Windows$ITextMeasurementService$Measure(($t = this.Text, $t != null ? $t : ""), this.FontSize, new System.Windows.Media.Typeface.$ctor1(this.FontFamily, this.FontStyle, this.FontWeight, this.FontStretch), Number.POSITIVE_INFINITY);
                }

                if (this.TextWrapping === System.Windows.TextWrapping.NoWrap || this.noWrapSize.Width <= availableSize.Width) {
                    return this.noWrapSize;
                }

                return System.Windows.ApplicationHost.Current.System$Windows$IApplicationHost$TextMeasurementService.System$Windows$ITextMeasurementService$Measure(($t1 = this.Text, $t1 != null ? $t1 : ""), this.FontSize, new System.Windows.Media.Typeface.$ctor1(this.FontFamily, this.FontStyle, this.FontWeight, this.FontStretch), availableSize.Width);
            },
            ArrangeOverride: function (finalSize) {
                if (this.textBlockRenderElement != null) {
                    this.textBlockRenderElement.System$Windows$Media$ITextBlockRenderElement$Bounds = new System.Windows.Rect.$ctor3(finalSize);
                }

                return finalSize;
            },
            OnTextChanged: function (e) {
                if (this.textBlockRenderElement != null) {
                    this.textBlockRenderElement.System$Windows$Media$ITextBlockRenderElement$Text = this.Text;
                }

                this.noWrapSize = null;
            },
            OnFontFamilyChanged: function (e) {
                if (this.textBlockRenderElement != null) {
                    this.textBlockRenderElement.System$Windows$Media$ITextBlockRenderElement$FontFamily = this.FontFamily;
                }

                this.noWrapSize = null;
            },
            OnFontSizeChanged: function (e) {
                if (this.textBlockRenderElement != null) {
                    this.textBlockRenderElement.System$Windows$Media$ITextBlockRenderElement$FontSize = this.FontSize;
                }

                this.noWrapSize = null;
            },
            OnFontStyleChanged: function (e) {
                if (this.textBlockRenderElement != null) {
                    this.textBlockRenderElement.System$Windows$Media$ITextBlockRenderElement$FontStyle = this.FontStyle;
                }

                this.noWrapSize = null;
            },
            OnFontWeightChanged: function (e) {
                if (this.textBlockRenderElement != null) {
                    this.textBlockRenderElement.System$Windows$Media$ITextBlockRenderElement$FontWeight = this.FontWeight;
                }

                this.noWrapSize = null;
            },
            OnFontStretchChanged: function (e) {
                if (this.textBlockRenderElement != null) {
                    this.textBlockRenderElement.System$Windows$Media$ITextBlockRenderElement$FontStretch = this.FontStretch;
                }

                this.noWrapSize = null;
            },
            OnForegroundChanged: function (e) {
                if (this.textBlockRenderElement != null) {
                    this.textBlockRenderElement.System$Windows$Media$ITextBlockRenderElement$Foreground = Bridge.cast(e.NewValue, System.Windows.Media.Brush);
                }
            },
            OnTextAlignmentChanged: function (e) {
                if (this.textBlockRenderElement != null) {
                    this.textBlockRenderElement.System$Windows$Media$ITextBlockRenderElement$TextAlignment = System.Nullable.getValue(Bridge.cast(Bridge.unbox(e.NewValue), System.Int32));
                }
            },
            OnTextTrimmingChanged: function (e) {
                if (this.textBlockRenderElement != null) {
                    this.textBlockRenderElement.System$Windows$Media$ITextBlockRenderElement$TextTrimming = System.Nullable.getValue(Bridge.cast(Bridge.unbox(e.NewValue), System.Int32));
                }
            },
            OnTextWrappingChanged: function (e) {
                if (this.textBlockRenderElement != null) {
                    this.textBlockRenderElement.System$Windows$Media$ITextBlockRenderElement$TextWrapping = System.Nullable.getValue(Bridge.cast(Bridge.unbox(e.NewValue), System.Int32));
                }
            }
        }
    });

    Bridge.ns("System.Windows.Controls.TextBlock", $asm.$);

    Bridge.apply($asm.$.System.Windows.Controls.TextBlock, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.TextBlock).OnTextChanged(e);
        },
        f2: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.TextBlock).OnForegroundChanged(e);
        },
        f3: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.TextBlock).OnFontFamilyChanged(e);
        },
        f4: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.TextBlock).OnFontSizeChanged(e);
        },
        f5: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.TextBlock).OnFontStyleChanged(e);
        },
        f6: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.TextBlock).OnFontWeightChanged(e);
        },
        f7: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.TextBlock).OnFontStretchChanged(e);
        },
        f8: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.TextBlock).OnTextAlignmentChanged(e);
        },
        f9: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.TextBlock).OnTextTrimmingChanged(e);
        },
        f10: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.TextBlock).OnTextWrappingChanged(e);
        }
    });

    Bridge.define("System.Windows.Controls.TextBoxView", {
        inherits: [System.Windows.FrameworkElement],
        statics: {
            ctors: {
                ctor: function () {
                    System.Windows.UIElement.IsHitTestVisibleProperty.OverrideMetadata(System.Windows.Controls.TextBoxView, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.TextBoxView.f1));
                    System.Windows.UIElement.IsEnabledProperty.OverrideMetadata(System.Windows.Controls.TextBoxView, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.TextBoxView.f2));
                    System.Windows.Controls.Control.ForegroundProperty.OverrideMetadata(System.Windows.Controls.TextBoxView, new System.Windows.FrameworkPropertyMetadata.$ctor9(System.Windows.FrameworkPropertyMetadataOptions.Inherits, $asm.$.System.Windows.Controls.TextBoxView.f3));
                    System.Windows.Controls.Control.FontFamilyProperty.OverrideMetadata(System.Windows.Controls.TextBoxView, new System.Windows.FrameworkPropertyMetadata.$ctor9(System.Windows.FrameworkPropertyMetadataOptions.Inherits, $asm.$.System.Windows.Controls.TextBoxView.f4));
                    System.Windows.Controls.Control.FontSizeProperty.OverrideMetadata(System.Windows.Controls.TextBoxView, new System.Windows.FrameworkPropertyMetadata.$ctor9(System.Windows.FrameworkPropertyMetadataOptions.Inherits, $asm.$.System.Windows.Controls.TextBoxView.f5));
                    System.Windows.Controls.Control.FontStyleProperty.OverrideMetadata(System.Windows.Controls.TextBoxView, new System.Windows.FrameworkPropertyMetadata.$ctor9(System.Windows.FrameworkPropertyMetadataOptions.Inherits, $asm.$.System.Windows.Controls.TextBoxView.f6));
                    System.Windows.Controls.Control.FontStretchProperty.OverrideMetadata(System.Windows.Controls.TextBoxView, new System.Windows.FrameworkPropertyMetadata.$ctor9(System.Windows.FrameworkPropertyMetadataOptions.Inherits, $asm.$.System.Windows.Controls.TextBoxView.f7));
                    System.Windows.Controls.Control.FontWeightProperty.OverrideMetadata(System.Windows.Controls.TextBoxView, new System.Windows.FrameworkPropertyMetadata.$ctor9(System.Windows.FrameworkPropertyMetadataOptions.Inherits, $asm.$.System.Windows.Controls.TextBoxView.f8));
                    System.Windows.Controls.TextBox.TextAlignmentProperty.OverrideMetadata(System.Windows.Controls.TextBoxView, new System.Windows.FrameworkPropertyMetadata.$ctor9(System.Windows.FrameworkPropertyMetadataOptions.Inherits, $asm.$.System.Windows.Controls.TextBoxView.f9));
                    System.Windows.Controls.TextBox.TextWrappingProperty.OverrideMetadata(System.Windows.Controls.TextBoxView, new System.Windows.FrameworkPropertyMetadata.$ctor9(System.Windows.FrameworkPropertyMetadataOptions.Inherits, $asm.$.System.Windows.Controls.TextBoxView.f10));
                }
            }
        },
        fields: {
            text: null,
            maxLength: 0,
            caretIndex: 0,
            selectionStart: 0,
            selectionLength: 0,
            acceptsReturn: false,
            acceptsTab: false,
            isReadOnly: false,
            horizontalScrollBarVisibility: 0,
            verticalScrollBarVisibility: 0,
            spellCheck: false,
            isPassword: false,
            textBoxRenderElement: null,
            measuredFontSize: 0,
            measuredFontFamily: null,
            measuredLineHeight: 0
        },
        events: {
            TextChanged: null,
            CaretIndexChanged: null,
            SelectionStartChanged: null,
            SelectionLengthChanged: null
        },
        props: {
            Text: {
                get: function () {
                    return this.text;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.text, value)) {
                        return;
                    }

                    this.text = value;

                    if (this.textBoxRenderElement != null) {
                        this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$Text = this.text;
                    }

                    Granular.Extensions.EventHandlerExtensions.Raise$2(this.TextChanged, this);
                }
            },
            MaxLength: {
                get: function () {
                    return this.maxLength;
                },
                set: function (value) {
                    if (this.maxLength === value) {
                        return;
                    }

                    this.maxLength = value;

                    if (this.textBoxRenderElement != null) {
                        this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$MaxLength = this.maxLength;
                    }
                }
            },
            CaretIndex: {
                get: function () {
                    return this.caretIndex;
                },
                set: function (value) {
                    if (this.caretIndex === value) {
                        return;
                    }

                    this.caretIndex = value;

                    if (this.textBoxRenderElement != null) {
                        this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$CaretIndex = this.caretIndex;
                    }

                    Granular.Extensions.EventHandlerExtensions.Raise$2(this.CaretIndexChanged, this);
                }
            },
            SelectionStart: {
                get: function () {
                    return this.selectionStart;
                },
                set: function (value) {
                    if (this.selectionStart === value) {
                        return;
                    }

                    this.selectionStart = value;

                    if (this.textBoxRenderElement != null) {
                        this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$SelectionStart = this.selectionStart;
                    }

                    Granular.Extensions.EventHandlerExtensions.Raise$2(this.SelectionStartChanged, this);
                }
            },
            SelectionLength: {
                get: function () {
                    return this.selectionLength;
                },
                set: function (value) {
                    if (this.selectionLength === value) {
                        return;
                    }

                    this.selectionLength = value;

                    if (this.textBoxRenderElement != null) {
                        this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$SelectionLength = this.selectionLength;
                    }

                    Granular.Extensions.EventHandlerExtensions.Raise$2(this.SelectionLengthChanged, this);
                }
            },
            AcceptsReturn: {
                get: function () {
                    return this.acceptsReturn;
                },
                set: function (value) {
                    if (this.acceptsReturn === value) {
                        return;
                    }

                    this.acceptsReturn = value;

                    if (this.textBoxRenderElement != null) {
                        this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$AcceptsReturn = this.acceptsReturn;
                    }
                }
            },
            AcceptsTab: {
                get: function () {
                    return this.acceptsTab;
                },
                set: function (value) {
                    if (this.acceptsTab === value) {
                        return;
                    }

                    this.acceptsTab = value;

                    if (this.textBoxRenderElement != null) {
                        this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$AcceptsTab = this.acceptsTab;
                    }
                }
            },
            IsReadOnly: {
                get: function () {
                    return this.isReadOnly;
                },
                set: function (value) {
                    if (this.isReadOnly === value) {
                        return;
                    }

                    this.isReadOnly = value;
                    this.SetRenderElementsIsReadOnly();
                }
            },
            HorizontalScrollBarVisibility: {
                get: function () {
                    return this.horizontalScrollBarVisibility;
                },
                set: function (value) {
                    if (this.horizontalScrollBarVisibility === value) {
                        return;
                    }

                    this.horizontalScrollBarVisibility = value;

                    if (this.textBoxRenderElement != null) {
                        this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$HorizontalScrollBarVisibility = this.horizontalScrollBarVisibility;
                    }
                }
            },
            VerticalScrollBarVisibility: {
                get: function () {
                    return this.verticalScrollBarVisibility;
                },
                set: function (value) {
                    if (this.verticalScrollBarVisibility === value) {
                        return;
                    }

                    this.verticalScrollBarVisibility = value;

                    if (this.textBoxRenderElement != null) {
                        this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$VerticalScrollBarVisibility = this.verticalScrollBarVisibility;
                    }
                }
            },
            SpellCheck: {
                get: function () {
                    return this.spellCheck;
                },
                set: function (value) {
                    if (this.spellCheck === value) {
                        return;
                    }

                    this.spellCheck = value;

                    if (this.textBoxRenderElement != null) {
                        this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$SpellCheck = this.spellCheck;
                    }
                }
            },
            IsPassword: {
                get: function () {
                    return this.isPassword;
                },
                set: function (value) {
                    if (this.isPassword === value) {
                        return;
                    }

                    if (this.textBoxRenderElement != null) {
                        throw new Granular.Exception("Can't set TextBoxView.IsPassword after render elements have been created");
                    }

                    this.isPassword = value;
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.FrameworkElement.ctor.call(this);
                this.measuredLineHeight = Number.NaN;
            }
        },
        methods: {
            CreateRenderElementContentOverride: function (factory) {
                if (this.textBoxRenderElement == null) {
                    this.textBoxRenderElement = factory.System$Windows$Media$IRenderElementFactory$CreateTextBoxRenderElement(this);

                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$CaretIndex = this.CaretIndex;
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$SelectionLength = this.SelectionLength;
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$SelectionStart = this.SelectionStart;
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$Text = this.Text;
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$MaxLength = this.MaxLength;
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$Bounds = new System.Windows.Rect.$ctor3(this.VisualSize);
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$AcceptsReturn = this.AcceptsReturn;
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$AcceptsTab = this.AcceptsTab;
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$IsPassword = this.isPassword;
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$IsReadOnly = this.IsReadOnly || !this.IsEnabled;
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$IsHitTestVisible = this.IsHitTestVisible && this.IsEnabled;
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$SpellCheck = this.spellCheck;
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$HorizontalScrollBarVisibility = this.HorizontalScrollBarVisibility;
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$VerticalScrollBarVisibility = this.VerticalScrollBarVisibility;

                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$Foreground = Bridge.cast(this.GetValue(System.Windows.Controls.Control.ForegroundProperty), System.Windows.Media.Brush);
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$FontSize = System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Control.FontSizeProperty)), System.Double));
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$FontFamily = Bridge.cast(this.GetValue(System.Windows.Controls.Control.FontFamilyProperty), System.Windows.Media.FontFamily);
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$FontStretch = System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Control.FontStretchProperty)), System.Int32));
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$FontStyle = System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Control.FontStyleProperty)), System.Int32));
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$FontWeight = System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Control.FontWeightProperty)), System.Int32));
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$TextAlignment = System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.TextBox.TextAlignmentProperty)), System.Int32));
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$TextWrapping = System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.TextBox.TextWrappingProperty)), System.Int32));

                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$addTextChanged(Bridge.fn.bind(this, $asm.$.System.Windows.Controls.TextBoxView.f11));
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$addCaretIndexChanged(Bridge.fn.bind(this, $asm.$.System.Windows.Controls.TextBoxView.f12));
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$addSelectionStartChanged(Bridge.fn.bind(this, $asm.$.System.Windows.Controls.TextBoxView.f13));
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$addSelectionLengthChanged(Bridge.fn.bind(this, $asm.$.System.Windows.Controls.TextBoxView.f14));

                    this.InvalidateMeasure();
                }

                return this.textBoxRenderElement;
            },
            MeasureOverride: function (availableSize) {
                return new System.Windows.Size(0, this.GetLineHeight());
            },
            ArrangeOverride: function (finalSize) {
                var bounds = new System.Windows.Rect.$ctor3(finalSize);

                if (this.textBoxRenderElement != null) {
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$Bounds = bounds;
                }

                return finalSize;
            },
            FocusRenderElement: function () {
                if (this.textBoxRenderElement != null) {
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$Focus();
                }
            },
            ClearFocusRenderElement: function () {
                if (this.textBoxRenderElement != null) {
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$ClearFocus();
                }
            },
            ProcessRenderElementKeyEvent: function (e) {
                if (this.textBoxRenderElement != null) {
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$ProcessKeyEvent(e);
                }
            },
            OnIsEnabledChanged$1: function () {
                this.SetRenderElementsIsHitTestVisible();
                this.SetRenderElementsIsReadOnly();
            },
            OnForegroundChanged: function (e) {
                if (this.textBoxRenderElement != null) {
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$Foreground = Bridge.cast(e.NewValue, System.Windows.Media.Brush);
                }
            },
            OnFontFamilyChanged: function (e) {
                if (this.textBoxRenderElement != null) {
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$FontFamily = Bridge.cast(e.NewValue, System.Windows.Media.FontFamily);
                }
            },
            OnFontSizeChanged: function (e) {
                if (this.textBoxRenderElement != null) {
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$FontSize = System.Nullable.getValue(Bridge.cast(Bridge.unbox(e.NewValue), System.Double));
                }
            },
            OnFontStyleChanged: function (e) {
                if (this.textBoxRenderElement != null) {
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$FontStyle = System.Nullable.getValue(Bridge.cast(Bridge.unbox(e.NewValue), System.Int32));
                }
            },
            OnFontStretchChanged: function (e) {
                if (this.textBoxRenderElement != null) {
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$FontStretch = System.Nullable.getValue(Bridge.cast(Bridge.unbox(e.NewValue), System.Int32));
                }
            },
            OnFontWeightChanged: function (e) {
                if (this.textBoxRenderElement != null) {
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$FontWeight = System.Nullable.getValue(Bridge.cast(Bridge.unbox(e.NewValue), System.Int32));
                }
            },
            OnTextAlignmentChanged: function (e) {
                if (this.textBoxRenderElement != null) {
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$TextAlignment = System.Nullable.getValue(Bridge.cast(Bridge.unbox(e.NewValue), System.Int32));
                }
            },
            OnTextWrappingChanged: function (e) {
                if (this.textBoxRenderElement != null) {
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$TextWrapping = System.Nullable.getValue(Bridge.cast(Bridge.unbox(e.NewValue), System.Int32));
                }
            },
            SetRenderElementsIsHitTestVisible: function () {
                this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$IsHitTestVisible = this.IsHitTestVisible && this.IsEnabled;
            },
            SetRenderElementsIsReadOnly: function () {
                if (this.textBoxRenderElement != null) {
                    this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$IsReadOnly = this.IsReadOnly || !this.IsEnabled;
                }
            },
            GetLineHeight: function () {
                var fontSize = System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Control.FontSizeProperty)), System.Double));
                var fontFamily = Bridge.cast(this.GetValue(System.Windows.Controls.Control.FontFamilyProperty), System.Windows.Media.FontFamily);

                if (!Granular.Extensions.DoubleExtensions.IsNaN(this.measuredLineHeight) && Granular.Extensions.DoubleExtensions.IsClose(this.measuredFontSize, fontSize) && Bridge.referenceEquals(this.measuredFontFamily, fontFamily)) {
                    return this.measuredLineHeight;
                }

                this.measuredFontSize = fontSize;
                this.measuredFontFamily = fontFamily;
                this.measuredLineHeight = System.Windows.ApplicationHost.Current.System$Windows$IApplicationHost$TextMeasurementService.System$Windows$ITextMeasurementService$Measure("", fontSize, new System.Windows.Media.Typeface.$ctor1(fontFamily), Number.POSITIVE_INFINITY).Height;

                return this.measuredLineHeight;
            }
        }
    });

    Bridge.ns("System.Windows.Controls.TextBoxView", $asm.$);

    Bridge.apply($asm.$.System.Windows.Controls.TextBoxView, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.TextBoxView).SetRenderElementsIsHitTestVisible();
        },
        f2: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.TextBoxView).OnIsEnabledChanged$1();
        },
        f3: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.TextBoxView).OnForegroundChanged(e);
        },
        f4: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.TextBoxView).OnFontFamilyChanged(e);
        },
        f5: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.TextBoxView).OnFontSizeChanged(e);
        },
        f6: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.TextBoxView).OnFontStyleChanged(e);
        },
        f7: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.TextBoxView).OnFontStretchChanged(e);
        },
        f8: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.TextBoxView).OnFontWeightChanged(e);
        },
        f9: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.TextBoxView).OnTextAlignmentChanged(e);
        },
        f10: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.TextBoxView).OnTextWrappingChanged(e);
        },
        f11: function (sender, e) {
            this.Text = this.textBoxRenderElement.System$Windows$Media$ITextBoxRenderElement$Text;
        },
        f12: function (sender, e) {
            this.CaretIndex = Bridge.cast(sender, System.Windows.Media.ITextBoxRenderElement).System$Windows$Media$ITextBoxRenderElement$CaretIndex;
        },
        f13: function (sender, e) {
            this.SelectionStart = Bridge.cast(sender, System.Windows.Media.ITextBoxRenderElement).System$Windows$Media$ITextBoxRenderElement$SelectionStart;
        },
        f14: function (sender, e) {
            this.SelectionLength = Bridge.cast(sender, System.Windows.Media.ITextBoxRenderElement).System$Windows$Media$ITextBoxRenderElement$SelectionLength;
        }
    });

    Bridge.define("System.Windows.DataTrigger", {
        inherits: [System.Windows.DataTriggerBase],
        props: {
            Binding: null,
            Value: null,
            Setters: null,
            TriggerActions: {
                get: function () {
                    return this.Setters;
                }
            }
        },
        alias: ["CreateDataTriggerCondition", "System$Windows$IDataTriggerConditionProvider$CreateDataTriggerCondition"],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.DataTriggerBase.ctor.call(this);
                this.Setters = new (Granular.Collections.ObservableCollection$1(System.Windows.ITriggerAction)).ctor();
            }
        },
        methods: {
            CreateDataTriggerCondition: function (element) {
                if (this.Binding == null) {
                    throw new Granular.Exception("DataTrigger.Binding cannot be null");
                }

                return System.Windows.DataTriggerCondition.Register(element, this.Binding, this.Value);
            }
        }
    });

    Bridge.define("System.Windows.Documents.Adorner", {
        inherits: [System.Windows.FrameworkElement],
        fields: {
            child: null,
            visualPathTransform: null
        },
        props: {
            Child: {
                get: function () {
                    return this.child;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.child, value)) {
                        return;
                    }

                    if (this.child != null) {
                        this.RemoveLogicalChild(this.child);
                        this.RemoveVisualChild(this.child);
                    }

                    this.child = value;

                    if (this.child != null) {
                        this.AddLogicalChild(this.child);
                        this.AddVisualChild(this.child);
                    }

                    this.InvalidateMeasure();
                }
            },
            AdornedElement: null
        },
        ctors: {
            ctor: function (adornedElement) {
                this.$initialize();
                System.Windows.FrameworkElement.ctor.call(this);
                this.AdornedElement = adornedElement;
            }
        },
        methods: {
            MeasureOverride: function (availableSize) {
                if (this.Child == null) {
                    return System.Windows.Size.Zero;
                }

                this.Child.Measure(this.AdornedElement.RenderSize);
                return this.AdornedElement.RenderSize;
            },
            ArrangeOverride: function (finalSize) {
                if (this.Child != null) {
                    this.Child.Arrange(new System.Windows.Rect.$ctor3(finalSize));
                }

                this.visualPathTransform.SetValue$3();

                return finalSize;
            },
            OnVisualParentChanged: function (oldVisualParent, newVisualParent) {
                System.Windows.FrameworkElement.prototype.OnVisualParentChanged.call(this, oldVisualParent, newVisualParent);

                if (oldVisualParent != null) {
                    this.visualPathTransform.dispose();
                    this.RenderTransform = System.Windows.Media.Transform.Identity;
                }

                if (newVisualParent != null) {
                    this.visualPathTransform = new System.Windows.Documents.Adorner.VisualPathTransform(this.AdornedElement, newVisualParent.VisualParent);
                    this.RenderTransform = this.visualPathTransform;
                }
            },
            Arrange$1: function () {
                this.Arrange(new System.Windows.Rect.$ctor3(this.AdornedElement.RenderSize));
                this.visualPathTransform.SetValue$3();
            }
        }
    });

    Bridge.define("System.Windows.Documents.Adorner.VisualPathTransform", {
        inherits: [System.Windows.Media.Transform,System.IDisposable],
        fields: {
            value: null,
            visual: null,
            ancestor: null,
            visualPath: null
        },
        props: {
            Value: {
                get: function () {
                    return this.value;
                }
            }
        },
        alias: ["dispose", "System$IDisposable$dispose"],
        ctors: {
            ctor: function (visual, ancestor) {
                var $t;
                this.$initialize();
                System.Windows.Media.Transform.ctor.call(this);
                this.visual = visual;
                this.ancestor = ancestor;

                this.visualPath = System.Linq.Enumerable.from(System.Windows.Media.VisualExtensions.GetVisualPath(visual, ancestor)).toArray();

                $t = Bridge.getEnumerator(this.visualPath, System.Windows.Media.Visual);
                try {
                    while ($t.moveNext()) {
                        var element = $t.Current;
                        element.addVisualTransformChanged(Bridge.fn.cacheBind(this, this.OnVisualTransformChanged));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                this.SetValue$3();
            }
        },
        methods: {
            dispose: function () {
                var $t;
                $t = Bridge.getEnumerator(this.visualPath, System.Windows.Media.Visual);
                try {
                    while ($t.moveNext()) {
                        var element = $t.Current;
                        element.removeVisualTransformChanged(Bridge.fn.cacheBind(this, this.OnVisualTransformChanged));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }},
            OnVisualTransformChanged: function (sender, e) {
                this.SetValue$3();
            },
            SetValue$3: function () {
                var newValue = this.visual.TransformToAncestor(this.ancestor);

                if (System.Windows.Media.Matrix.op_Equality(this.value, newValue)) {
                    return;
                }

                this.value = newValue;
                this.InvalidateRenderResource();
                this.RaiseChanged();
            }
        }
    });

    Bridge.define("System.Windows.Documents.AdornerLayer", {
        inherits: [System.Windows.FrameworkElement],
        statics: {
            methods: {
                GetAdornerLayer: function (visual) {
                    while (visual != null) {
                        if (Bridge.is(visual, System.Windows.Documents.IAdornerLayerHost)) {
                            return Bridge.cast(visual, System.Windows.Documents.IAdornerLayerHost).System$Windows$Documents$IAdornerLayerHost$AdornerLayer;
                        }

                        visual = visual.VisualParent;
                    }

                    return null;
                }
            }
        },
        methods: {
            OnVisualParentChanged: function (oldVisualParent, newVisualParent) {
                System.Windows.FrameworkElement.prototype.OnVisualParentChanged.call(this, oldVisualParent, newVisualParent);

                if (oldVisualParent != null) {
                    Bridge.cast(oldVisualParent, System.Windows.UIElement).removeLayoutUpdated(Bridge.fn.cacheBind(this, this.OnParentLayoutUpdated));
                }

                if (newVisualParent != null) {
                    Bridge.cast(newVisualParent, System.Windows.UIElement).addLayoutUpdated(Bridge.fn.cacheBind(this, this.OnParentLayoutUpdated));
                }
            },
            OnParentLayoutUpdated: function (sender, e) {
                var $t;
                $t = Bridge.getEnumerator(this.VisualChildren);
                try {
                    while ($t.moveNext()) {
                        var adorner = Bridge.cast($t.Current, System.Windows.Documents.Adorner);
                        adorner.Arrange$1();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }},
            Add: function (adorner) {
                this.AddLogicalChild(adorner);
                this.AddVisualChild(adorner);

                this.InvalidateArrange();
            },
            Remove: function (adorner) {
                this.RemoveVisualChild(adorner);
                this.RemoveLogicalChild(adorner);
            }
        }
    });

    Bridge.define("System.Windows.Documents.Block", {
        inherits: [System.Windows.Documents.TextElement],
        statics: {
            fields: {
                BorderBrushProperty: null,
                BorderThicknessProperty: null,
                LineHeightProperty: null,
                PaddingProperty: null,
                TextAlignmentProperty: null
            },
            ctors: {
                init: function () {
                    this.BorderBrushProperty = System.Windows.Controls.Border.BorderBrushProperty.AddOwner(System.Windows.Documents.Block);
                    this.BorderThicknessProperty = System.Windows.Controls.Border.BorderThicknessProperty.AddOwner(System.Windows.Documents.Block);
                    this.LineHeightProperty = System.Windows.DependencyProperty.Register("LineHeight", System.Double, System.Windows.Documents.Block, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.PaddingProperty = System.Windows.Controls.Border.PaddingProperty.AddOwner(System.Windows.Documents.Block);
                    this.TextAlignmentProperty = System.Windows.DependencyProperty.RegisterAttached("TextAlignment", System.Windows.TextAlignment, System.Windows.Documents.Block, new System.Windows.FrameworkPropertyMetadata.$ctor2(Bridge.box(System.Windows.TextAlignment.Left, System.Windows.TextAlignment, System.Enum.toStringFn(System.Windows.TextAlignment)), System.Windows.FrameworkPropertyMetadataOptions.Inherits));
                }
            }
        },
        props: {
            BorderBrush: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Documents.Block.BorderBrushProperty), System.Windows.Media.Brush);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Documents.Block.BorderBrushProperty, value);
                }
            },
            BorderThickness: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Documents.Block.BorderThicknessProperty), System.Windows.Thickness);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Documents.Block.BorderThicknessProperty, value);
                }
            },
            LineHeight: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Documents.Block.LineHeightProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Documents.Block.LineHeightProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            Padding: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Documents.Block.PaddingProperty), System.Windows.Thickness);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Documents.Block.PaddingProperty, value);
                }
            },
            TextAlignment: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Documents.Block.TextAlignmentProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Documents.Block.TextAlignmentProperty, Bridge.box(value, System.Windows.TextAlignment, System.Enum.toStringFn(System.Windows.TextAlignment)));
                }
            },
            SiblingBlocks: null
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Documents.TextElement.ctor.call(this);
                //FrameworkElement.MarginProperty.OverrideMetadata(typeof(Block), ...
            }
        },
        methods: {
            GetRenderElement: function (factory) {
                return null;
            },
            RemoveRenderElement: function (factory) {
                //
            }
        }
    });

    Bridge.define("System.Windows.Documents.Inline", {
        inherits: [System.Windows.Documents.TextElement],
        props: {
            SiblingInlines: null
        }
    });

    Bridge.define("System.Windows.EventTrigger", {
        inherits: [System.Windows.EventTriggerBase],
        props: {
            RoutedEvent: null,
            SourceName: null,
            Actions: null,
            TriggerActions: {
                get: function () {
                    return this.Actions;
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.EventTriggerBase.ctor.call(this);
                this.Actions = new (Granular.Collections.ObservableCollection$1(System.Windows.ITriggerAction)).ctor();
            }
        },
        methods: {
            CreateEventTriggerCondition: function (element) {
                if (this.RoutedEvent == null) {
                    throw new Granular.Exception("EventTrigger.RoutedEvent cannot be null");
                }

                return System.Windows.EventTrigger.EventTriggerCondition.Register(element, this.RoutedEvent);
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.TransitionAnimationTimeline$1", function (T) { return {
        inherits: [System.Windows.Media.Animation.AnimationTimeline],
        statics: {
            fields: {
                ToProperty: null,
                FromProperty: null,
                ByProperty: null,
                EasingFunctionProperty: null
            },
            ctors: {
                init: function () {
                    this.ToProperty = System.Windows.DependencyProperty.Register("To", T, System.Windows.Media.Animation.TransitionAnimationTimeline$1(T), new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.FromProperty = System.Windows.DependencyProperty.Register("From", T, System.Windows.Media.Animation.TransitionAnimationTimeline$1(T), new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.ByProperty = System.Windows.DependencyProperty.Register("By", T, System.Windows.Media.Animation.TransitionAnimationTimeline$1(T), new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.EasingFunctionProperty = System.Windows.DependencyProperty.Register("EasingFunction", System.Windows.Media.Animation.IEasingFunction, System.Windows.Media.Animation.TransitionAnimationTimeline$1(T), new System.Windows.FrameworkPropertyMetadata.ctor());
                }
            }
        },
        fields: {
            animationOperations: null,
            isAccumulable: false
        },
        props: {
            To: {
                get: function () {
                    return Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.Animation.TransitionAnimationTimeline$1(T).ToProperty)), T);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Animation.TransitionAnimationTimeline$1(T).ToProperty, value);
                }
            },
            From: {
                get: function () {
                    return Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.Animation.TransitionAnimationTimeline$1(T).FromProperty)), T);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Animation.TransitionAnimationTimeline$1(T).FromProperty, value);
                }
            },
            By: {
                get: function () {
                    return Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.Animation.TransitionAnimationTimeline$1(T).ByProperty)), T);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Animation.TransitionAnimationTimeline$1(T).ByProperty, value);
                }
            },
            EasingFunction: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Media.Animation.TransitionAnimationTimeline$1(T).EasingFunctionProperty), System.Windows.Media.Animation.IEasingFunction);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Animation.TransitionAnimationTimeline$1(T).EasingFunctionProperty, value);
                }
            }
        },
        ctors: {
            ctor: function (animationOperations, isAccumulable) {
                this.$initialize();
                System.Windows.Media.Animation.AnimationTimeline.ctor.call(this);
                this.animationOperations = animationOperations;
                this.isAccumulable = isAccumulable;
            }
        },
        methods: {
            GetCurrentValue: function (defaultOriginValue, defaultDestinationValue, animationClock) {
                var progress = this.EasingFunction != null ? this.EasingFunction.System$Windows$Media$Animation$IEasingFunction$Ease(animationClock.CurrentState.Progress) : animationClock.CurrentState.Progress;

                var baseValue = this.animationOperations["System$Windows$Media$Animation$IAnimationOperations$1$" + Bridge.getTypeAlias(T) + "$Zero"];
                var from;
                var to;

                if (this.From != null) {
                    if (this.To != null) {
                        if (this.IsAdditive && this.isAccumulable) {
                            baseValue = Bridge.cast(Bridge.unbox(defaultOriginValue), T);
                        }
                        from = this.From;
                        to = this.To;
                    } else if (this.By != null) {
                        if (this.IsAdditive && this.isAccumulable) {
                            baseValue = Bridge.cast(Bridge.unbox(defaultOriginValue), T);
                        }
                        from = this.From;
                        to = this.animationOperations["System$Windows$Media$Animation$IAnimationOperations$1$" + Bridge.getTypeAlias(T) + "$Add"](this.From, this.By);
                    } else {
                        from = this.From;
                        to = Bridge.cast(Bridge.unbox(defaultDestinationValue), T);
                    }
                } else if (this.To != null) {
                    from = Bridge.cast(Bridge.unbox(defaultOriginValue), T);
                    to = this.To;
                } else if (this.By != null) {
                    if (this.isAccumulable) {
                        baseValue = Bridge.cast(Bridge.unbox(defaultOriginValue), T);
                    }
                    from = this.animationOperations["System$Windows$Media$Animation$IAnimationOperations$1$" + Bridge.getTypeAlias(T) + "$Zero"];
                    to = this.By;
                } else {
                    from = Bridge.cast(Bridge.unbox(defaultOriginValue), T);
                    to = Bridge.cast(Bridge.unbox(defaultDestinationValue), T);
                }

                if (this.IsCumulative && this.isAccumulable) {
                    baseValue = this.animationOperations["System$Windows$Media$Animation$IAnimationOperations$1$" + Bridge.getTypeAlias(T) + "$Add"](baseValue, this.animationOperations["System$Windows$Media$Animation$IAnimationOperations$1$" + Bridge.getTypeAlias(T) + "$Scale"](this.animationOperations["System$Windows$Media$Animation$IAnimationOperations$1$" + Bridge.getTypeAlias(T) + "$Subtract"](to, from), Math.floor(animationClock.CurrentState.Iteration)));
                }

                return this.animationOperations["System$Windows$Media$Animation$IAnimationOperations$1$" + Bridge.getTypeAlias(T) + "$Add"](baseValue, this.animationOperations["System$Windows$Media$Animation$IAnimationOperations$1$" + Bridge.getTypeAlias(T) + "$Interpolate"](from, to, progress));
            }
        }
    }; });

    Bridge.define("System.Windows.Media.Animation.KeyFramesAnimationTimeline$1", function (T) { return {
        inherits: [System.Windows.Media.Animation.AnimationTimeline],
        fields: {
            animationOperations: null,
            isAccumulable: false
        },
        props: {
            KeyFrames: null
        },
        ctors: {
            ctor: function (animationOperations, isAccumulable) {
                this.$initialize();
                System.Windows.Media.Animation.AnimationTimeline.ctor.call(this);
                this.animationOperations = animationOperations;
                this.isAccumulable = isAccumulable;

                this.KeyFrames = new (System.Windows.FreezableCollection$1(System.Windows.Media.Animation.KeyFrame$1(T))).ctor();
                this.KeyFrames.TrySetContextParent(this);
            }
        },
        methods: {
            GetCurrentValue: function (defaultOriginValue, defaultDestinationValue, animationClock) {
                if (this.KeyFrames.Count === 0) {
                    return defaultDestinationValue;
                }

                var duration = this.Duration.HasTimeSpan ? this.Duration.TimeSpan : this.GetKeyFramesDuration();

                var time = Granular.Extensions.TimeSpanExtensions.Scale(duration, animationClock.CurrentState.Progress);

                var index = this.GetKeyFrameIndexAtTime(time, duration);

                var value;

                if (index === this.KeyFrames.Count) {
                    value = this.KeyFrames.getItem(((this.KeyFrames.Count - 1) | 0)).Value;
                } else {
                    var baseValue;

                    if (index === 0) {
                        baseValue = this.IsAdditive && this.isAccumulable ? this.animationOperations["System$Windows$Media$Animation$IAnimationOperations$1$" + Bridge.getTypeAlias(T) + "$Zero"] : Bridge.cast(Bridge.unbox(defaultOriginValue), T);
                    } else {
                        baseValue = this.KeyFrames.getItem(((index - 1) | 0)).Value;
                    }

                    var segmentStart = index === 0 ? System.TimeSpan.zero : this.GetKeyFrameTime(this.KeyFrames.getItem(((index - 1) | 0)), duration);
                    var segmentEnd = this.GetKeyFrameTime(this.KeyFrames.getItem(index), duration);

                    var progress = System.TimeSpan.eq(segmentEnd, segmentStart) ? 1 : (System.TimeSpan.sub(time, segmentStart)).getTicks() / System.Int64.toNumber((System.TimeSpan.sub(segmentEnd, segmentStart)).getTicks());

                    value = this.KeyFrames.getItem(index).InterpolateValue(baseValue, progress);
                }

                if (this.IsAdditive && this.isAccumulable) {
                    value = this.animationOperations["System$Windows$Media$Animation$IAnimationOperations$1$" + Bridge.getTypeAlias(T) + "$Add"](value, Bridge.cast(Bridge.unbox(defaultOriginValue), T));
                }

                if (this.IsCumulative && this.isAccumulable) {
                    value = this.animationOperations["System$Windows$Media$Animation$IAnimationOperations$1$" + Bridge.getTypeAlias(T) + "$Add"](value, this.animationOperations["System$Windows$Media$Animation$IAnimationOperations$1$" + Bridge.getTypeAlias(T) + "$Scale"](this.KeyFrames.getItem(((this.KeyFrames.Count - 1) | 0)).Value, Math.floor(animationClock.CurrentState.Iteration)));
                }

                return value;
            },
            GetKeyFrameTime: function (keyFrame, keyFramesDuration) {
                if (keyFrame.KeyTime.HasTimeSpan) {
                    return keyFrame.KeyTime.TimeSpan;
                }

                if (keyFrame.KeyTime.HasPercent) {
                    return Granular.Extensions.TimeSpanExtensions.Scale(keyFramesDuration, keyFrame.KeyTime.Percent);
                }

                throw new Granular.Exception("KeyTime of type \"{0}\" is not supported", [Bridge.box(keyFrame.KeyTime.Type, System.Windows.Media.Animation.KeyTimeType, System.Enum.toStringFn(System.Windows.Media.Animation.KeyTimeType))]);
            },
            GetKeyFrameIndexAtTime: function (time, keyFramesDuration) {
                return ((this.KeyFrames.indexOf(System.Linq.Enumerable.from(this.KeyFrames).lastOrDefault(Bridge.fn.bind(this, function (keyFrame) {
                        return System.TimeSpan.lt(this.GetKeyFrameTime(keyFrame, keyFramesDuration), time);
                    }), null)) + 1) | 0);
            },
            GetKeyFramesDuration: function () {
                return System.Linq.Enumerable.from(System.Linq.Enumerable.from(this.KeyFrames).where($asm.$.System.Windows.Media.Animation.KeyFramesAnimationTimeline$1.f1).select($asm.$.System.Windows.Media.Animation.KeyFramesAnimationTimeline$1.f2).defaultIfEmpty(System.TimeSpan.fromSeconds(1))).max();
            }
        }
    }; });

    Bridge.ns("System.Windows.Media.Animation.KeyFramesAnimationTimeline$1", $asm.$);

    Bridge.apply($asm.$.System.Windows.Media.Animation.KeyFramesAnimationTimeline$1, {
        f1: function (keyFrame) {
            return keyFrame.KeyTime.HasTimeSpan;
        },
        f2: function (keyFrame) {
            return keyFrame.KeyTime.TimeSpan;
        }
    });

    Bridge.define("System.Windows.Media.Animation.DiscreteDoubleKeyFrame", {
        inherits: [System.Windows.Media.Animation.DiscreteKeyFrame$1(System.Nullable$1(System.Double))],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Animation.DiscreteKeyFrame$1(System.Nullable$1(System.Double)).ctor.call(this, System.Windows.Media.Animation.DoubleAnimationOperations.Default);
                //
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.DiscreteRectKeyFrame", {
        inherits: [System.Windows.Media.Animation.DiscreteKeyFrame$1(System.Windows.Rect)],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Animation.DiscreteKeyFrame$1(System.Windows.Rect).ctor.call(this, System.Windows.Media.Animation.RectAnimationOperations.Default);
                //
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.DiscreteThicknessKeyFrame", {
        inherits: [System.Windows.Media.Animation.DiscreteKeyFrame$1(System.Windows.Thickness)],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Animation.DiscreteKeyFrame$1(System.Windows.Thickness).ctor.call(this, System.Windows.Media.Animation.ThicknessAnimationOperations.Default);
                //
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.EasingDoubleKeyFrame", {
        inherits: [System.Windows.Media.Animation.EasingKeyFrame$1(System.Nullable$1(System.Double))],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Animation.EasingKeyFrame$1(System.Nullable$1(System.Double)).ctor.call(this, System.Windows.Media.Animation.DoubleAnimationOperations.Default);
                //
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.EasingRectKeyFrame", {
        inherits: [System.Windows.Media.Animation.EasingKeyFrame$1(System.Windows.Rect)],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Animation.EasingKeyFrame$1(System.Windows.Rect).ctor.call(this, System.Windows.Media.Animation.RectAnimationOperations.Default);
                //
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.EasingThicknessKeyFrame", {
        inherits: [System.Windows.Media.Animation.EasingKeyFrame$1(System.Windows.Thickness)],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Animation.EasingKeyFrame$1(System.Windows.Thickness).ctor.call(this, System.Windows.Media.Animation.ThicknessAnimationOperations.Default);
                //
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.LinearDoubleKeyFrame", {
        inherits: [System.Windows.Media.Animation.LinearKeyFrame$1(System.Nullable$1(System.Double))],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Animation.LinearKeyFrame$1(System.Nullable$1(System.Double)).ctor.call(this, System.Windows.Media.Animation.DoubleAnimationOperations.Default);
                //
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.LinearRectKeyFrame", {
        inherits: [System.Windows.Media.Animation.LinearKeyFrame$1(System.Windows.Rect)],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Animation.LinearKeyFrame$1(System.Windows.Rect).ctor.call(this, System.Windows.Media.Animation.RectAnimationOperations.Default);
                //
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.LinearThicknessKeyFrame", {
        inherits: [System.Windows.Media.Animation.LinearKeyFrame$1(System.Windows.Thickness)],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Animation.LinearKeyFrame$1(System.Windows.Thickness).ctor.call(this, System.Windows.Media.Animation.ThicknessAnimationOperations.Default);
                //
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.ParallelTimeline", {
        inherits: [System.Windows.Media.Animation.TimelineGroup],
        methods: {
            CreateGroupClock: function (children) {
                return new System.Windows.Media.Animation.ParallelTimelineClock(this, children);
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.RectAnimationOperations", {
        inherits: [System.Windows.Media.Animation.IAnimationOperations$1(System.Windows.Rect)],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Media.Animation.RectAnimationOperations();
                }
            }
        },
        props: {
            Zero: {
                get: function () {
                    return System.Windows.Rect.Zero;
                }
            }
        },
        alias: [
            "Zero", "System$Windows$Media$Animation$IAnimationOperations$1$System$Windows$Rect$Zero",
            "Add", "System$Windows$Media$Animation$IAnimationOperations$1$System$Windows$Rect$Add",
            "Subtract", "System$Windows$Media$Animation$IAnimationOperations$1$System$Windows$Rect$Subtract",
            "Scale", "System$Windows$Media$Animation$IAnimationOperations$1$System$Windows$Rect$Scale",
            "Interpolate", "System$Windows$Media$Animation$IAnimationOperations$1$System$Windows$Rect$Interpolate"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                //
            }
        },
        methods: {
            Add: function (value1, value2) {
                return new System.Windows.Rect.$ctor2(System.Windows.Point.op_Addition(value1.Location, value2.Location), System.Windows.Size.op_Addition(value1.Size, value2.Size));
            },
            Subtract: function (value1, value2) {
                return new System.Windows.Rect.$ctor2(System.Windows.Point.op_Subtraction(value1.Location, value2.Location), System.Windows.Size.op_Subtraction(value1.Size, value2.Size));
            },
            Scale: function (value, factor) {
                return new System.Windows.Rect.$ctor2(System.Windows.Point.op_Multiply(factor, value.Location), System.Windows.Size.op_Multiply(factor, value.Size));
            },
            Interpolate: function (value1, value2, progress) {
                return new System.Windows.Rect.$ctor2(System.Windows.Point.op_Addition(System.Windows.Point.op_Multiply((1 - progress), value1.Location), System.Windows.Point.op_Multiply(progress, value2.Location)), System.Windows.Size.op_Addition(System.Windows.Size.op_Multiply((1 - progress), value1.Size), System.Windows.Size.op_Multiply(progress, value2.Size)));
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.SequentialTimeline", {
        inherits: [System.Windows.Media.Animation.TimelineGroup],
        methods: {
            CreateGroupClock: function (children) {
                return new System.Windows.Media.Animation.SequentialTimelineClock(this, children);
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.ThicknessAnimationOperations", {
        inherits: [System.Windows.Media.Animation.IAnimationOperations$1(System.Windows.Thickness)],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Media.Animation.ThicknessAnimationOperations();
                }
            }
        },
        props: {
            Zero: {
                get: function () {
                    return System.Windows.Thickness.Zero;
                }
            }
        },
        alias: [
            "Zero", "System$Windows$Media$Animation$IAnimationOperations$1$System$Windows$Thickness$Zero",
            "Add", "System$Windows$Media$Animation$IAnimationOperations$1$System$Windows$Thickness$Add",
            "Subtract", "System$Windows$Media$Animation$IAnimationOperations$1$System$Windows$Thickness$Subtract",
            "Scale", "System$Windows$Media$Animation$IAnimationOperations$1$System$Windows$Thickness$Scale",
            "Interpolate", "System$Windows$Media$Animation$IAnimationOperations$1$System$Windows$Thickness$Interpolate"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                //
            }
        },
        methods: {
            Add: function (value1, value2) {
                return System.Windows.Thickness.op_Addition(value1, value2);
            },
            Subtract: function (value1, value2) {
                return System.Windows.Thickness.op_Subtraction(value1, value2);
            },
            Scale: function (value, factor) {
                return System.Windows.Thickness.op_Multiply(factor, value);
            },
            Interpolate: function (value1, value2, progress) {
                return System.Windows.Thickness.op_Addition(System.Windows.Thickness.op_Multiply((1 - progress), value1), System.Windows.Thickness.op_Multiply(progress, value2));
            }
        }
    });

    Bridge.define("System.Windows.Media.EllipseGeometry", {
        inherits: [System.Windows.Media.Geometry],
        statics: {
            fields: {
                CenterProperty: null,
                RadiusXProperty: null,
                RadiusYProperty: null
            },
            ctors: {
                init: function () {
                    this.CenterProperty = System.Windows.DependencyProperty.Register("Center", System.Windows.Point, System.Windows.Media.EllipseGeometry, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Media.EllipseGeometry.f1));
                    this.RadiusXProperty = System.Windows.DependencyProperty.Register("RadiusX", System.Double, System.Windows.Media.EllipseGeometry, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Media.EllipseGeometry.f1));
                    this.RadiusYProperty = System.Windows.DependencyProperty.Register("RadiusY", System.Double, System.Windows.Media.EllipseGeometry, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Media.EllipseGeometry.f1));
                }
            }
        },
        props: {
            Center: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Media.EllipseGeometry.CenterProperty), System.Windows.Point);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.EllipseGeometry.CenterProperty, value);
                }
            },
            RadiusX: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.EllipseGeometry.RadiusXProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.EllipseGeometry.RadiusXProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            RadiusY: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.EllipseGeometry.RadiusYProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.EllipseGeometry.RadiusYProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Geometry.ctor.call(this);
                //
            },
            $ctor1: function (center, radiusX, radiusY) {
                System.Windows.Media.EllipseGeometry.ctor.call(this);
                this.Center = center;
                this.RadiusX = radiusX;
                this.RadiusY = radiusY;
            },
            $ctor2: function (center, radiusX, radiusY, transform) {
                System.Windows.Media.EllipseGeometry.$ctor1.call(this, center, radiusX, radiusY);
                this.Transform = transform;
            },
            $ctor3: function (rect) {
                System.Windows.Media.EllipseGeometry.$ctor1.call(this, new System.Windows.Point.$ctor1((rect.Left + rect.Right) / 2, (rect.Top + rect.Bottom) / 2), rect.Width / 2, rect.Height / 2);
                //
            }
        },
        methods: {
            GetRenderResourceData: function () {
                var rx = this.RadiusX;
                var ry = this.RadiusY;

                return System.String.format("M {0},{1} a {2},{3} 0 0,1 {4},0 a {5},{6} 0 0,1 {7},0 z", Bridge.box(this.Center.X - rx, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(this.Center.Y, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(rx, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(ry, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(2 * rx, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(rx, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(ry, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(-2 * rx, System.Double, System.Double.format, System.Double.getHashCode));
            }
        }
    });

    Bridge.ns("System.Windows.Media.EllipseGeometry", $asm.$);

    Bridge.apply($asm.$.System.Windows.Media.EllipseGeometry, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Media.EllipseGeometry).InvalidateRenderResource();
        }
    });

    Bridge.define("System.Windows.Media.GradientBrush", {
        inherits: [System.Windows.Media.Brush],
        statics: {
            fields: {
                SpreadMethodProperty: null,
                MappingModeProperty: null,
                GradientStopsProperty: null
            },
            ctors: {
                init: function () {
                    this.SpreadMethodProperty = System.Windows.DependencyProperty.Register("SpreadMethod", System.Windows.Media.GradientSpreadMethod, System.Windows.Media.GradientBrush, new System.Windows.FrameworkPropertyMetadata.$ctor6(Bridge.box(System.Windows.Media.GradientSpreadMethod.Pad, System.Windows.Media.GradientSpreadMethod, System.Enum.toStringFn(System.Windows.Media.GradientSpreadMethod)), $asm.$.System.Windows.Media.GradientBrush.f1));
                    this.MappingModeProperty = System.Windows.DependencyProperty.Register("MappingMode", System.Windows.Media.BrushMappingMode, System.Windows.Media.GradientBrush, new System.Windows.FrameworkPropertyMetadata.$ctor6(Bridge.box(System.Windows.Media.BrushMappingMode.RelativeToBoundingBox, System.Windows.Media.BrushMappingMode, System.Enum.toStringFn(System.Windows.Media.BrushMappingMode)), $asm.$.System.Windows.Media.GradientBrush.f2));
                    this.GradientStopsProperty = System.Windows.DependencyProperty.Register("GradientStops", System.Windows.Media.GradientStopCollection, System.Windows.Media.GradientBrush, new System.Windows.FrameworkPropertyMetadata.$ctor6(null, $asm.$.System.Windows.Media.GradientBrush.f3));
                }
            }
        },
        fields: {
            renderResource$1: null
        },
        props: {
            SpreadMethod: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.GradientBrush.SpreadMethodProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.GradientBrush.SpreadMethodProperty, Bridge.box(value, System.Windows.Media.GradientSpreadMethod, System.Enum.toStringFn(System.Windows.Media.GradientSpreadMethod)));
                }
            },
            MappingMode: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.GradientBrush.MappingModeProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.GradientBrush.MappingModeProperty, Bridge.box(value, System.Windows.Media.BrushMappingMode, System.Enum.toStringFn(System.Windows.Media.BrushMappingMode)));
                }
            },
            GradientStops: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Media.GradientBrush.GradientStopsProperty), System.Windows.Media.GradientStopCollection);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.GradientBrush.GradientStopsProperty, value);
                }
            }
        },
        ctors: {
            ctor: function () {
                System.Windows.Media.GradientBrush.$ctor2.call(this, new System.Windows.Media.GradientStopCollection.ctor());
                //
            },
            $ctor1: function (gradientStops) {
                System.Windows.Media.GradientBrush.$ctor2.call(this, new System.Windows.Media.GradientStopCollection.$ctor1(gradientStops));
                //
            },
            $ctor2: function (gradientStops) {
                this.$initialize();
                System.Windows.Media.Brush.ctor.call(this);
                this.GradientStops = gradientStops;
            }
        },
        methods: {
            OnRenderResourceCreated: function (renderResource) {
                System.Windows.Media.Brush.prototype.OnRenderResourceCreated.call(this, renderResource);

                this.renderResource$1 = Bridge.cast(renderResource, System.Windows.Media.IGradientBrushRenderResource);
                this.renderResource$1.System$Windows$Media$IGradientBrushRenderResource$SpreadMethod = this.SpreadMethod;
                this.renderResource$1.System$Windows$Media$IGradientBrushRenderResource$MappingMode = this.MappingMode;
                this.renderResource$1.System$Windows$Media$IGradientBrushRenderResource$GradientStops = System.Linq.Enumerable.from(this.GradientStops).select($asm.$.System.Windows.Media.GradientBrush.f4).toArray(System.Windows.Media.RenderGradientStop);
            },
            OnSpreadMethodChanged: function (e) {
                if (this.renderResource$1 != null) {
                    this.renderResource$1.System$Windows$Media$IGradientBrushRenderResource$SpreadMethod = this.SpreadMethod;
                }
            },
            OnMappingModeChanged: function (e) {
                if (this.renderResource$1 != null) {
                    this.renderResource$1.System$Windows$Media$IGradientBrushRenderResource$MappingMode = this.MappingMode;
                }
            },
            OnGradientStopsChanged: function (e) {
                if (e.OldValue != null) {
                    Bridge.cast(e.OldValue, System.Windows.Media.GradientStopCollection).TrySetContextParent(null);
                }

                if (e.NewValue != null) {
                    Bridge.cast(e.NewValue, System.Windows.Media.GradientStopCollection).TrySetContextParent(this);
                }

                if (this.renderResource$1 != null) {
                    this.renderResource$1.System$Windows$Media$IGradientBrushRenderResource$GradientStops = e.NewValue != null ? System.Linq.Enumerable.from(Bridge.cast(e.NewValue, System.Windows.Media.GradientStopCollection)).select($asm.$.System.Windows.Media.GradientBrush.f4).toArray(System.Windows.Media.RenderGradientStop) : null;
                }
            }
        }
    });

    Bridge.ns("System.Windows.Media.GradientBrush", $asm.$);

    Bridge.apply($asm.$.System.Windows.Media.GradientBrush, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Media.GradientBrush).OnSpreadMethodChanged(e);
        },
        f2: function (sender, e) {
            Bridge.cast(sender, System.Windows.Media.GradientBrush).OnMappingModeChanged(e);
        },
        f3: function (sender, e) {
            Bridge.cast(sender, System.Windows.Media.GradientBrush).OnGradientStopsChanged(e);
        },
        f4: function (gradientStop) {
            return new System.Windows.Media.RenderGradientStop(gradientStop.Color, gradientStop.Offset);
        }
    });

    Bridge.define("System.Windows.Media.GradientStopCollection", {
        inherits: [System.Windows.FreezableCollection$1(System.Windows.Media.GradientStop)],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.FreezableCollection$1(System.Windows.Media.GradientStop).ctor.call(this);
                //
            },
            $ctor1: function (collection) {
                this.$initialize();
                System.Windows.FreezableCollection$1(System.Windows.Media.GradientStop).$ctor1.call(this, collection);
                //
            }
        }
    });

    Bridge.define("System.Windows.Media.TileBrush", {
        inherits: [System.Windows.Media.Brush],
        statics: {
            fields: {
                TileModeProperty: null,
                StretchProperty: null,
                ViewportProperty: null,
                ViewportUnitsProperty: null
            },
            ctors: {
                init: function () {
                    this.TileModeProperty = System.Windows.DependencyProperty.Register("TileMode", System.Windows.Media.TileMode, System.Windows.Media.TileBrush, new System.Windows.FrameworkPropertyMetadata.$ctor6(Bridge.box(System.Windows.Media.TileMode.None, System.Windows.Media.TileMode, System.Enum.toStringFn(System.Windows.Media.TileMode)), $asm.$.System.Windows.Media.TileBrush.f1));
                    this.StretchProperty = System.Windows.DependencyProperty.Register("Stretch", System.Windows.Media.Stretch, System.Windows.Media.TileBrush, new System.Windows.FrameworkPropertyMetadata.$ctor6(Bridge.box(System.Windows.Media.Stretch.None, System.Windows.Media.Stretch, System.Enum.toStringFn(System.Windows.Media.Stretch)), $asm.$.System.Windows.Media.TileBrush.f2));
                    this.ViewportProperty = System.Windows.DependencyProperty.Register("Viewport", System.Windows.Rect, System.Windows.Media.TileBrush, new System.Windows.FrameworkPropertyMetadata.$ctor6(null, $asm.$.System.Windows.Media.TileBrush.f3));
                    this.ViewportUnitsProperty = System.Windows.DependencyProperty.Register("ViewportUnits", System.Windows.Media.BrushMappingMode, System.Windows.Media.TileBrush, new System.Windows.FrameworkPropertyMetadata.$ctor6(Bridge.box(System.Windows.Media.BrushMappingMode.Absolute, System.Windows.Media.BrushMappingMode, System.Enum.toStringFn(System.Windows.Media.BrushMappingMode)), $asm.$.System.Windows.Media.TileBrush.f4));
                }
            }
        },
        fields: {
            renderResource$1: null
        },
        props: {
            TileMode: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.TileBrush.TileModeProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.TileBrush.TileModeProperty, Bridge.box(value, System.Windows.Media.TileMode, System.Enum.toStringFn(System.Windows.Media.TileMode)));
                }
            },
            Stretch: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.TileBrush.StretchProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.TileBrush.StretchProperty, Bridge.box(value, System.Windows.Media.Stretch, System.Enum.toStringFn(System.Windows.Media.Stretch)));
                }
            },
            Viewport: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Media.TileBrush.ViewportProperty), System.Windows.Rect);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.TileBrush.ViewportProperty, value);
                }
            },
            ViewportUnits: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.TileBrush.ViewportUnitsProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.TileBrush.ViewportUnitsProperty, Bridge.box(value, System.Windows.Media.BrushMappingMode, System.Enum.toStringFn(System.Windows.Media.BrushMappingMode)));
                }
            }
        },
        methods: {
            OnRenderResourceCreated: function (renderResource) {
                System.Windows.Media.Brush.prototype.OnRenderResourceCreated.call(this, renderResource);

                this.renderResource$1 = Bridge.cast(renderResource, System.Windows.Media.ITileBrushRenderResource);
                this.renderResource$1.System$Windows$Media$ITileBrushRenderResource$TileMode = this.TileMode;
                this.renderResource$1.System$Windows$Media$ITileBrushRenderResource$Stretch = this.Stretch;
                this.renderResource$1.System$Windows$Media$ITileBrushRenderResource$Viewport = this.Viewport;
                this.renderResource$1.System$Windows$Media$ITileBrushRenderResource$ViewportUnits = this.ViewportUnits;
            },
            OnTileModeChanged: function (e) {
                this.renderResource$1.System$Windows$Media$ITileBrushRenderResource$TileMode = this.TileMode;
            },
            OnStretchChanged: function (e) {
                this.renderResource$1.System$Windows$Media$ITileBrushRenderResource$Stretch = this.Stretch;
            },
            OnViewportChanged: function (e) {
                this.renderResource$1.System$Windows$Media$ITileBrushRenderResource$Viewport = this.Viewport;
            },
            OnViewportUnitsChanged: function (e) {
                this.renderResource$1.System$Windows$Media$ITileBrushRenderResource$ViewportUnits = this.ViewportUnits;
            }
        }
    });

    Bridge.ns("System.Windows.Media.TileBrush", $asm.$);

    Bridge.apply($asm.$.System.Windows.Media.TileBrush, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Media.TileBrush).OnTileModeChanged(e);
        },
        f2: function (sender, e) {
            Bridge.cast(sender, System.Windows.Media.TileBrush).OnStretchChanged(e);
        },
        f3: function (sender, e) {
            Bridge.cast(sender, System.Windows.Media.TileBrush).OnViewportChanged(e);
        },
        f4: function (sender, e) {
            Bridge.cast(sender, System.Windows.Media.TileBrush).OnViewportUnitsChanged(e);
        }
    });

    Bridge.define("System.Windows.Media.Imaging.BitmapSource", {
        inherits: [System.Windows.Media.ImageSource],
        fields: {
            renderImageState: 0,
            renderResource$1: null
        },
        events: {
            DownloadProgress: null,
            DownloadCompleted: null,
            DownloadFailed: null
        },
        props: {
            IsDownloading: false
        },
        methods: {
            OnRenderResourceCreated: function (renderResource) {
                System.Windows.Media.ImageSource.prototype.OnRenderResourceCreated.call(this, renderResource);

                this.renderResource$1 = Bridge.cast(renderResource, System.Windows.Media.IImageSourceRenderResource);
                this.renderResource$1.System$Windows$Media$IImageSourceRenderResource$addStateChanged(Bridge.fn.bind(this, $asm.$.System.Windows.Media.Imaging.BitmapSource.f1));

                this.SetRenderImageState();
            },
            SetRenderImageState: function () {
                if (this.renderImageState === this.renderResource$1.System$Windows$Media$IImageSourceRenderResource$State) {
                    return;
                }

                var oldRenderImageState = this.renderImageState;
                this.renderImageState = this.renderResource$1.System$Windows$Media$IImageSourceRenderResource$State;

                if (oldRenderImageState !== System.Windows.Media.RenderImageState.Idle && oldRenderImageState !== System.Windows.Media.RenderImageState.DownloadProgress || this.renderImageState === System.Windows.Media.RenderImageState.Idle) {
                    throw new Granular.Exception("Can't change BitmapSource.RenderImageState from \"{0}\" to \"{1}\"", [Bridge.box(oldRenderImageState, System.Windows.Media.RenderImageState, System.Enum.toStringFn(System.Windows.Media.RenderImageState)), Bridge.box(this.renderImageState, System.Windows.Media.RenderImageState, System.Enum.toStringFn(System.Windows.Media.RenderImageState))]);
                }

                switch (this.renderImageState) {
                    case System.Windows.Media.RenderImageState.DownloadProgress: 
                        this.IsDownloading = true;
                        Granular.Extensions.EventHandlerExtensions.Raise$2(this.DownloadProgress, this);
                        break;
                    case System.Windows.Media.RenderImageState.DownloadCompleted: 
                        this.IsDownloading = false;
                        Granular.Extensions.EventHandlerExtensions.Raise$2(this.DownloadCompleted, this);
                        break;
                    case System.Windows.Media.RenderImageState.DownloadFailed: 
                        this.IsDownloading = false;
                        Granular.Extensions.EventHandlerExtensions.Raise$2(this.DownloadFailed, this);
                        break;
                    default: 
                        throw new Granular.Exception("Unexpected DownloadState \"{0}\"", [Bridge.box(this.renderImageState, System.Windows.Media.RenderImageState, System.Enum.toStringFn(System.Windows.Media.RenderImageState))]);
                }
            }
        }
    });

    Bridge.ns("System.Windows.Media.Imaging.BitmapSource", $asm.$);

    Bridge.apply($asm.$.System.Windows.Media.Imaging.BitmapSource, {
        f1: function (sender, e) {
            this.SetRenderImageState();
        }
    });

    Bridge.define("System.Windows.Media.LineGeometry", {
        inherits: [System.Windows.Media.Geometry],
        statics: {
            fields: {
                StartPointProperty: null,
                EndPointProperty: null
            },
            ctors: {
                init: function () {
                    this.StartPointProperty = System.Windows.DependencyProperty.Register("StartPoint", System.Windows.Point, System.Windows.Media.LineGeometry, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Media.LineGeometry.f1));
                    this.EndPointProperty = System.Windows.DependencyProperty.Register("EndPoint", System.Windows.Point, System.Windows.Media.LineGeometry, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Media.LineGeometry.f1));
                }
            }
        },
        props: {
            StartPoint: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Media.LineGeometry.StartPointProperty), System.Windows.Point);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.LineGeometry.StartPointProperty, value);
                }
            },
            EndPoint: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Media.LineGeometry.EndPointProperty), System.Windows.Point);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.LineGeometry.EndPointProperty, value);
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Geometry.ctor.call(this);
                //
            },
            $ctor1: function (startPoint, endPoint) {
                System.Windows.Media.LineGeometry.ctor.call(this);
                this.StartPoint = startPoint;
                this.EndPoint = endPoint;
            },
            $ctor2: function (startPoint, endPoint, transform) {
                System.Windows.Media.LineGeometry.$ctor1.call(this, startPoint, endPoint);
                this.Transform = transform;
            }
        },
        methods: {
            GetRenderResourceData: function () {
                return System.String.format("M {0}, {1} {2}, {3}", Bridge.box(this.StartPoint.X, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(this.StartPoint.Y, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(this.EndPoint.X, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(this.EndPoint.Y, System.Double, System.Double.format, System.Double.getHashCode));
            }
        }
    });

    Bridge.ns("System.Windows.Media.LineGeometry", $asm.$);

    Bridge.apply($asm.$.System.Windows.Media.LineGeometry, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Media.LineGeometry).InvalidateRenderResource();
        }
    });

    Bridge.define("System.Windows.Media.MatrixTransform", {
        inherits: [System.Windows.Media.Transform],
        statics: {
            fields: {
                MatrixProperty: null
            },
            ctors: {
                init: function () {
                    this.MatrixProperty = System.Windows.DependencyProperty.Register("Matrix", System.Windows.Media.Matrix, System.Windows.Media.MatrixTransform, new System.Windows.FrameworkPropertyMetadata.$ctor6(System.Windows.Media.Matrix.Identity, $asm.$.System.Windows.Media.MatrixTransform.f1));
                }
            }
        },
        props: {
            Value: {
                get: function () {
                    return this.Matrix;
                }
            },
            Matrix: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Media.MatrixTransform.MatrixProperty), System.Windows.Media.Matrix);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.MatrixTransform.MatrixProperty, value);
                }
            }
        },
        ctors: {
            ctor: function () {
                System.Windows.Media.MatrixTransform.$ctor2.call(this, System.Windows.Media.Matrix.Identity);
                //
            },
            $ctor1: function (m11, m12, m21, m22, offsetX, offsetY) {
                System.Windows.Media.MatrixTransform.$ctor2.call(this, new System.Windows.Media.Matrix(m11, m12, m21, m22, offsetX, offsetY));
                //
            },
            $ctor2: function (matrix) {
                this.$initialize();
                System.Windows.Media.Transform.ctor.call(this);
                this.Matrix = matrix;
            }
        },
        methods: {
            OnMatrixChanged: function (e) {
                this.InvalidateRenderResource();
            }
        }
    });

    Bridge.ns("System.Windows.Media.MatrixTransform", $asm.$);

    Bridge.apply($asm.$.System.Windows.Media.MatrixTransform, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Media.MatrixTransform).OnMatrixChanged(e);
        }
    });

    Bridge.define("System.Windows.Media.RectangleGeometry", {
        inherits: [System.Windows.Media.Geometry],
        statics: {
            fields: {
                RectProperty: null,
                RadiusXProperty: null,
                RadiusYProperty: null
            },
            ctors: {
                init: function () {
                    this.RectProperty = System.Windows.DependencyProperty.Register("Rect", System.Windows.Rect, System.Windows.Media.RectangleGeometry, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Media.RectangleGeometry.f1));
                    this.RadiusXProperty = System.Windows.DependencyProperty.Register("RadiusX", System.Double, System.Windows.Media.RectangleGeometry, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Media.RectangleGeometry.f1));
                    this.RadiusYProperty = System.Windows.DependencyProperty.Register("RadiusY", System.Double, System.Windows.Media.RectangleGeometry, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Media.RectangleGeometry.f1));
                }
            }
        },
        props: {
            Rect: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Media.RectangleGeometry.RectProperty), System.Windows.Rect);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.RectangleGeometry.RectProperty, value);
                }
            },
            RadiusX: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.RectangleGeometry.RadiusXProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.RectangleGeometry.RadiusXProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            RadiusY: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.RectangleGeometry.RadiusYProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.RectangleGeometry.RadiusYProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Geometry.ctor.call(this);
                //
            },
            $ctor1: function (rect) {
                System.Windows.Media.RectangleGeometry.ctor.call(this);
                this.Rect = rect;
            },
            $ctor2: function (rect, radiusX, radiusY) {
                System.Windows.Media.RectangleGeometry.$ctor1.call(this, rect);
                this.RadiusX = radiusX;
                this.RadiusY = radiusY;
            },
            $ctor3: function (rect, radiusX, radiusY, transform) {
                System.Windows.Media.RectangleGeometry.$ctor2.call(this, rect, radiusX, radiusY);
                this.Transform = transform;
            }
        },
        methods: {
            GetRenderResourceData: function () {
                var rect = this.Rect;
                var rx = this.RadiusX;
                var ry = this.RadiusY;

                if (rx === 0 && ry === 0) {
                    return System.String.format("M {0},{1} l {2},0 l 0,{3} l {4},0 z", Bridge.box(rect.Left, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(rect.Top, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(rect.Width, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(rect.Height, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(-rect.Width, System.Double, System.Double.format, System.Double.getHashCode));
                }

                return System.String.format("M {0},{1}\r\n                      l {2},0 a {3},{4} 0 0,1 {5},{6}\r\n                      l 0,{7} a {8},{9} 0 0,1 {10},{11}\r\n                      l {12},0 a {13},{14} 0 0,1 {15},{16}\r\n                      l 0,{17} a {18},{19} 0 0,1 {20},{21} z", Bridge.box(rect.Left + rx, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(rect.Top, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(rect.Width - 2 * rx, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(rx, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(ry, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(rx, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(ry, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(rect.Height - 2 * ry, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(rx, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(ry, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(-rx, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(ry, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(-rect.Width + 2 * rx, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(rx, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(ry, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(-rx, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(-ry, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(-rect.Height + 2 * ry, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(rx, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(ry, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(rx, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(-ry, System.Double, System.Double.format, System.Double.getHashCode));
            }
        }
    });

    Bridge.ns("System.Windows.Media.RectangleGeometry", $asm.$);

    Bridge.apply($asm.$.System.Windows.Media.RectangleGeometry, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Media.RectangleGeometry).InvalidateRenderResource();
        }
    });

    Bridge.define("System.Windows.Media.RotateTransform", {
        inherits: [System.Windows.Media.Transform],
        statics: {
            fields: {
                AngleProperty: null,
                CenterXProperty: null,
                CenterYProperty: null
            },
            ctors: {
                init: function () {
                    this.AngleProperty = System.Windows.DependencyProperty.Register("Angle", System.Double, System.Windows.Media.RotateTransform, new System.Windows.FrameworkPropertyMetadata.$ctor9(0.0, System.Windows.Media.RotateTransform.SetMatrix));
                    this.CenterXProperty = System.Windows.DependencyProperty.Register("CenterX", System.Double, System.Windows.Media.RotateTransform, new System.Windows.FrameworkPropertyMetadata.$ctor9(0.0, System.Windows.Media.RotateTransform.SetMatrix));
                    this.CenterYProperty = System.Windows.DependencyProperty.Register("CenterY", System.Double, System.Windows.Media.RotateTransform, new System.Windows.FrameworkPropertyMetadata.$ctor9(0.0, System.Windows.Media.RotateTransform.SetMatrix));
                }
            },
            methods: {
                SetMatrix: function (dependencyObject, e) {
                    (Bridge.as(dependencyObject, System.Windows.Media.RotateTransform)).SetMatrix();
                }
            }
        },
        fields: {
            matrix: null
        },
        props: {
            Value: {
                get: function () {
                    return this.matrix;
                }
            },
            Angle: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.RotateTransform.AngleProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.RotateTransform.AngleProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            CenterX: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.RotateTransform.CenterXProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.RotateTransform.CenterXProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            CenterY: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.RotateTransform.CenterYProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.RotateTransform.CenterYProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Transform.ctor.call(this);
                this.matrix = System.Windows.Media.Matrix.Identity;
            }
        },
        methods: {
            SetMatrix: function () {
                this.matrix = System.Windows.Media.Matrix.RotationMatrix(Math.PI * this.Angle / 180, this.CenterX, this.CenterY);
                this.InvalidateRenderResource();
            }
        }
    });

    Bridge.define("System.Windows.Media.ScaleTransform", {
        inherits: [System.Windows.Media.Transform],
        statics: {
            fields: {
                ScaleXProperty: null,
                ScaleYProperty: null,
                CenterXProperty: null,
                CenterYProperty: null
            },
            ctors: {
                init: function () {
                    this.ScaleXProperty = System.Windows.DependencyProperty.Register("ScaleX", System.Double, System.Windows.Media.ScaleTransform, new System.Windows.FrameworkPropertyMetadata.$ctor6(Bridge.box(1.0, System.Double, System.Double.format, System.Double.getHashCode), System.Windows.Media.ScaleTransform.SetMatrix));
                    this.ScaleYProperty = System.Windows.DependencyProperty.Register("ScaleY", System.Double, System.Windows.Media.ScaleTransform, new System.Windows.FrameworkPropertyMetadata.$ctor6(Bridge.box(1.0, System.Double, System.Double.format, System.Double.getHashCode), System.Windows.Media.ScaleTransform.SetMatrix));
                    this.CenterXProperty = System.Windows.DependencyProperty.Register("CenterX", System.Double, System.Windows.Media.ScaleTransform, new System.Windows.FrameworkPropertyMetadata.$ctor9(0.0, System.Windows.Media.ScaleTransform.SetMatrix));
                    this.CenterYProperty = System.Windows.DependencyProperty.Register("CenterY", System.Double, System.Windows.Media.ScaleTransform, new System.Windows.FrameworkPropertyMetadata.$ctor9(0.0, System.Windows.Media.ScaleTransform.SetMatrix));
                }
            },
            methods: {
                SetMatrix: function (dependencyObject, e) {
                    (Bridge.as(dependencyObject, System.Windows.Media.ScaleTransform)).SetMatrix();
                }
            }
        },
        fields: {
            matrix: null
        },
        props: {
            Value: {
                get: function () {
                    return this.matrix;
                }
            },
            ScaleX: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.ScaleTransform.ScaleXProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.ScaleTransform.ScaleXProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            ScaleY: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.ScaleTransform.ScaleYProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.ScaleTransform.ScaleYProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            CenterX: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.ScaleTransform.CenterXProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.ScaleTransform.CenterXProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            CenterY: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.ScaleTransform.CenterYProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.ScaleTransform.CenterYProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Transform.ctor.call(this);
                this.matrix = System.Windows.Media.Matrix.Identity;
            }
        },
        methods: {
            SetMatrix: function () {
                this.matrix = System.Windows.Media.Matrix.ScalingMatrix(this.ScaleX, this.ScaleY, this.CenterX, this.CenterY);
                this.InvalidateRenderResource();
            }
        }
    });

    Bridge.define("System.Windows.Media.SkewTransform", {
        inherits: [System.Windows.Media.Transform],
        statics: {
            fields: {
                AngleXProperty: null,
                AngleYProperty: null,
                CenterXProperty: null,
                CenterYProperty: null
            },
            ctors: {
                init: function () {
                    this.AngleXProperty = System.Windows.DependencyProperty.Register("AngleX", System.Double, System.Windows.Media.SkewTransform, new System.Windows.FrameworkPropertyMetadata.$ctor9(0.0, System.Windows.Media.SkewTransform.SetMatrix));
                    this.AngleYProperty = System.Windows.DependencyProperty.Register("AngleY", System.Double, System.Windows.Media.SkewTransform, new System.Windows.FrameworkPropertyMetadata.$ctor9(0.0, System.Windows.Media.SkewTransform.SetMatrix));
                    this.CenterXProperty = System.Windows.DependencyProperty.Register("CenterX", System.Double, System.Windows.Media.SkewTransform, new System.Windows.FrameworkPropertyMetadata.$ctor9(0.0, System.Windows.Media.SkewTransform.SetMatrix));
                    this.CenterYProperty = System.Windows.DependencyProperty.Register("CenterY", System.Double, System.Windows.Media.SkewTransform, new System.Windows.FrameworkPropertyMetadata.$ctor9(0.0, System.Windows.Media.SkewTransform.SetMatrix));
                }
            },
            methods: {
                SetMatrix: function (dependencyObject, e) {
                    (Bridge.as(dependencyObject, System.Windows.Media.SkewTransform)).SetMatrix();
                }
            }
        },
        fields: {
            matrix: null
        },
        props: {
            Value: {
                get: function () {
                    return this.matrix;
                }
            },
            AngleX: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.SkewTransform.AngleXProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.SkewTransform.AngleXProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            AngleY: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.SkewTransform.AngleYProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.SkewTransform.AngleYProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            CenterX: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.SkewTransform.CenterXProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.SkewTransform.CenterXProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            CenterY: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.SkewTransform.CenterYProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.SkewTransform.CenterYProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Transform.ctor.call(this);
                this.matrix = System.Windows.Media.Matrix.Identity;
            }
        },
        methods: {
            SetMatrix: function () {
                this.matrix = System.Windows.Media.Matrix.SkewMatrix(Math.PI * this.AngleX / 180, Math.PI * this.AngleY / 180, this.CenterX, this.CenterY);
                this.InvalidateRenderResource();
            }
        }
    });

    Bridge.define("System.Windows.Media.SolidColorBrush", {
        inherits: [System.Windows.Media.Brush],
        statics: {
            fields: {
                ColorProperty: null
            },
            ctors: {
                init: function () {
                    this.ColorProperty = System.Windows.DependencyProperty.Register("Color", System.Windows.Media.Color, System.Windows.Media.SolidColorBrush, new System.Windows.FrameworkPropertyMetadata.$ctor6(System.Windows.Media.Colors.Transparent, $asm.$.System.Windows.Media.SolidColorBrush.f1));
                }
            }
        },
        fields: {
            renderResource$1: null
        },
        props: {
            Color: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Media.SolidColorBrush.ColorProperty), System.Windows.Media.Color);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.SolidColorBrush.ColorProperty, value);
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Brush.ctor.call(this);
                //
            },
            $ctor1: function (color) {
                this.$initialize();
                System.Windows.Media.Brush.ctor.call(this);
                this.Color = color;
            }
        },
        methods: {
            toString: function () {
                return System.String.format("SolidColorBrush({0})", this.Color);
            },
            CreateRenderResource: function (factory) {
                return factory.System$Windows$Media$IRenderElementFactory$CreateSolidColorBrushRenderResource();
            },
            OnRenderResourceCreated: function (renderResource) {
                System.Windows.Media.Brush.prototype.OnRenderResourceCreated.call(this, renderResource);

                this.renderResource$1 = Bridge.cast(renderResource, System.Windows.Media.ISolidColorBrushRenderResource);
                this.renderResource$1.System$Windows$Media$ISolidColorBrushRenderResource$Color = this.Color;
            },
            OnColorChanged: function (e) {
                if (this.renderResource$1 != null) {
                    this.renderResource$1.System$Windows$Media$ISolidColorBrushRenderResource$Color = this.Color;
                }
            }
        }
    });

    Bridge.ns("System.Windows.Media.SolidColorBrush", $asm.$);

    Bridge.apply($asm.$.System.Windows.Media.SolidColorBrush, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Media.SolidColorBrush).OnColorChanged(e);
        }
    });

    Bridge.define("System.Windows.Media.StreamGeometry", {
        inherits: [System.Windows.Media.Geometry],
        fields: {
            source: null
        },
        ctors: {
            ctor: function (source) {
                this.$initialize();
                System.Windows.Media.Geometry.ctor.call(this);
                this.source = source;
            }
        },
        methods: {
            GetRenderResourceData: function () {
                return this.source;
            }
        }
    });

    Bridge.define("System.Windows.Media.Transform.IdentityTransform", {
        inherits: [System.Windows.Media.Transform],
        props: {
            Value: {
                get: function () {
                    return System.Windows.Media.Matrix.Identity;
                }
            }
        }
    });

    Bridge.define("System.Windows.Media.TransformGroup", {
        inherits: [System.Windows.Media.Transform],
        fields: {
            matrix: null
        },
        props: {
            Value: {
                get: function () {
                    return this.matrix;
                }
            },
            Children: null
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Transform.ctor.call(this);
                this.matrix = System.Windows.Media.Matrix.Identity;

                this.Children = new (System.Windows.FreezableCollection$1(System.Windows.Media.Transform)).ctor();
                this.Children.TrySetContextParent(this);
                this.Children.addChanged(Bridge.fn.cacheBind(this, this.OnChildChanged));
            }
        },
        methods: {
            OnChildChanged: function (sender, e) {
                this.matrix = System.Linq.Enumerable.from(this.Children).select($asm.$.System.Windows.Media.TransformGroup.f1).defaultIfEmpty(System.Windows.Media.Matrix.Identity).aggregate($asm.$.System.Windows.Media.TransformGroup.f2);
                this.InvalidateRenderResource();
                this.RaiseChanged();
            }
        }
    });

    Bridge.ns("System.Windows.Media.TransformGroup", $asm.$);

    Bridge.apply($asm.$.System.Windows.Media.TransformGroup, {
        f1: function (child) {
            return child.Value;
        },
        f2: function (matrix1, matrix2) {
            return System.Windows.Media.Matrix.op_Multiply(matrix1, matrix2);
        }
    });

    Bridge.define("System.Windows.Media.TranslateTransform", {
        inherits: [System.Windows.Media.Transform],
        statics: {
            fields: {
                XProperty: null,
                YProperty: null
            },
            ctors: {
                init: function () {
                    this.XProperty = System.Windows.DependencyProperty.Register("X", System.Double, System.Windows.Media.TranslateTransform, new System.Windows.FrameworkPropertyMetadata.$ctor9(0.0, System.Windows.Media.TranslateTransform.SetMatrix));
                    this.YProperty = System.Windows.DependencyProperty.Register("Y", System.Double, System.Windows.Media.TranslateTransform, new System.Windows.FrameworkPropertyMetadata.$ctor9(0.0, System.Windows.Media.TranslateTransform.SetMatrix));
                }
            },
            methods: {
                SetMatrix: function (dependencyObject, e) {
                    Bridge.cast(dependencyObject, System.Windows.Media.TranslateTransform).SetMatrix();
                }
            }
        },
        fields: {
            matrix: null
        },
        props: {
            Value: {
                get: function () {
                    return this.matrix;
                }
            },
            X: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.TranslateTransform.XProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.TranslateTransform.XProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            Y: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.TranslateTransform.YProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.TranslateTransform.YProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            }
        },
        ctors: {
            ctor: function () {
                System.Windows.Media.TranslateTransform.$ctor2.call(this, System.Windows.Media.Matrix.Identity);
                //
            },
            $ctor1: function (x, y) {
                System.Windows.Media.TranslateTransform.$ctor2.call(this, System.Windows.Media.Matrix.TranslationMatrix(x, y));
                //
            },
            $ctor2: function (matrix) {
                this.$initialize();
                System.Windows.Media.Transform.ctor.call(this);
                this.matrix = matrix;
            }
        },
        methods: {
            SetMatrix: function () {
                this.matrix = System.Windows.Media.Matrix.TranslationMatrix(this.X, this.Y);
                this.InvalidateRenderResource();
            }
        }
    });

    Bridge.define("System.Windows.MultiDataTriggerBase", {
        inherits: [System.Windows.DataTriggerBase],
        props: {
            Conditions: null,
            Setters: null,
            TriggerActions: {
                get: function () {
                    return this.Setters;
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.DataTriggerBase.ctor.call(this);
                this.Conditions = new (Granular.Collections.ObservableCollection$1(System.Windows.Condition)).ctor();
                this.Setters = new (Granular.Collections.ObservableCollection$1(System.Windows.ITriggerAction)).ctor();
            }
        }
    });

    Bridge.define("System.Windows.Shapes.Shape", {
        inherits: [System.Windows.FrameworkElement],
        statics: {
            fields: {
                FillProperty: null,
                StrokeProperty: null,
                StrokeThicknessProperty: null
            },
            ctors: {
                init: function () {
                    this.FillProperty = System.Windows.DependencyProperty.Register("Fill", System.Windows.Media.Brush, System.Windows.Shapes.Shape, new System.Windows.FrameworkPropertyMetadata.$ctor2(null, System.Windows.FrameworkPropertyMetadataOptions.AffectsRender));
                    this.StrokeProperty = System.Windows.DependencyProperty.Register("Stroke", System.Windows.Media.Brush, System.Windows.Shapes.Shape, new System.Windows.FrameworkPropertyMetadata.$ctor2(null, 18));
                    this.StrokeThicknessProperty = System.Windows.DependencyProperty.Register("StrokeThickness", System.Double, System.Windows.Shapes.Shape, new System.Windows.FrameworkPropertyMetadata.$ctor2(Bridge.box(0.0, System.Double, System.Double.format, System.Double.getHashCode), 18));
                }
            }
        },
        props: {
            Fill: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Shapes.Shape.FillProperty), System.Windows.Media.Brush);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Shapes.Shape.FillProperty, value);
                }
            },
            Stroke: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Shapes.Shape.StrokeProperty), System.Windows.Media.Brush);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Shapes.Shape.StrokeProperty, value);
                }
            },
            StrokeThickness: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Shapes.Shape.StrokeThicknessProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Shapes.Shape.StrokeThicknessProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            }
        },
        methods: {
            OnRender: function (renderContext) {
                System.Windows.FrameworkElement.prototype.OnRender.call(this, renderContext);

                renderContext.DrawGeometry(this.Fill, new System.Windows.Media.Pen.$ctor1(this.Stroke, this.StrokeThickness), this.DefiningGeometry);
            }
        }
    });

    Bridge.define("System.Windows.Trigger", {
        inherits: [System.Windows.DataTriggerBase],
        props: {
            Property: null,
            Value: null,
            SourceName: null,
            Setters: null,
            TriggerActions: {
                get: function () {
                    return this.Setters;
                }
            }
        },
        alias: ["CreateDataTriggerCondition", "System$Windows$IDataTriggerConditionProvider$CreateDataTriggerCondition"],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.DataTriggerBase.ctor.call(this);
                this.Setters = new (Granular.Collections.ObservableCollection$1(System.Windows.ITriggerAction)).ctor();
            }
        },
        methods: {
            CreateDataTriggerCondition: function (element) {
                if (this.Property == null) {
                    throw new Granular.Exception("Trigger.Property cannot be null");
                }

                var dependencyProperty = System.Windows.PropertyPathElementExtensions.GetDependencyProperty(this.Property, Bridge.getType(element));

                var resolvedValue = this.Value == null || Bridge.Reflection.isInstanceOfType(this.Value, dependencyProperty.PropertyType) ? this.Value : System.Windows.Markup.TypeConverter.ConvertValue(this.Value.toString(), dependencyProperty.PropertyType, System.Windows.Markup.XamlNamespaces.Empty, null);

                var source = Granular.Extensions.StringExtensions.IsNullOrEmpty(this.SourceName) ? element : Bridge.as(System.Windows.NameScope.GetTemplateNameScope(element).System$Windows$INameScope$findName(this.SourceName), System.Windows.FrameworkElement);

                return System.Windows.TriggerCondition.Register(source, dependencyProperty, resolvedValue);
            }
        }
    });

    Bridge.define("System.Windows.Controls.Border", {
        inherits: [System.Windows.Controls.Decorator],
        statics: {
            fields: {
                BackgroundProperty: null,
                BorderBrushProperty: null,
                BorderThicknessProperty: null,
                CornerRadiusProperty: null,
                PaddingProperty: null
            },
            ctors: {
                init: function () {
                    this.BackgroundProperty = System.Windows.Controls.Panel.BackgroundProperty.AddOwner(System.Windows.Controls.Border, new System.Windows.FrameworkPropertyMetadata.$ctor6(null, $asm.$.System.Windows.Controls.Border.f1));
                    this.BorderBrushProperty = System.Windows.DependencyProperty.Register("BorderBrush", System.Windows.Media.Brush, System.Windows.Controls.Border, new System.Windows.FrameworkPropertyMetadata.$ctor6(null, $asm.$.System.Windows.Controls.Border.f2));
                    this.BorderThicknessProperty = System.Windows.DependencyProperty.Register("BorderThickness", System.Windows.Thickness, System.Windows.Controls.Border, new System.Windows.FrameworkPropertyMetadata.$ctor3(System.Windows.Thickness.Zero, System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure, $asm.$.System.Windows.Controls.Border.f3));
                    this.CornerRadiusProperty = System.Windows.DependencyProperty.Register("CornerRadius", System.Windows.CornerRadius, System.Windows.Controls.Border, new System.Windows.FrameworkPropertyMetadata.$ctor6(System.Windows.CornerRadius.Zero, $asm.$.System.Windows.Controls.Border.f4));
                    this.PaddingProperty = System.Windows.DependencyProperty.Register("Padding", System.Windows.Thickness, System.Windows.Controls.Border, new System.Windows.FrameworkPropertyMetadata.$ctor2(System.Windows.Thickness.Zero, System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure));
                }
            },
            methods: {
                IsOverBorder: function (position, borderSize, borderTickness, cornerRadius) {
                    return position.X < borderTickness.Left || position.Y < borderTickness.Top || borderSize.Width - position.X < borderTickness.Right || borderSize.Height - position.Y < borderTickness.Bottom; // cornerRadius is ignored
                }
            }
        },
        fields: {
            borderRenderElement: null
        },
        props: {
            Background: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.Border.BackgroundProperty), System.Windows.Media.Brush);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Border.BackgroundProperty, value);
                }
            },
            BorderBrush: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.Border.BorderBrushProperty), System.Windows.Media.Brush);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Border.BorderBrushProperty, value);
                }
            },
            BorderThickness: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.Border.BorderThicknessProperty), System.Windows.Thickness);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Border.BorderThicknessProperty, value);
                }
            },
            CornerRadius: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.Border.CornerRadiusProperty), System.Windows.CornerRadius);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Border.CornerRadiusProperty, value);
                }
            },
            Padding: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.Border.PaddingProperty), System.Windows.Thickness);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Border.PaddingProperty, value);
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Controls.Decorator.ctor.call(this);
                //
            }
        },
        methods: {
            CreateRenderElementContentOverride: function (factory) {
                if (this.borderRenderElement == null) {
                    this.borderRenderElement = factory.System$Windows$Media$IRenderElementFactory$CreateBorderRenderElement(this);

                    this.borderRenderElement.System$Windows$Media$IBorderRenderElement$Background = this.Background;
                    this.borderRenderElement.System$Windows$Media$IBorderRenderElement$BorderBrush = this.BorderBrush;
                    this.borderRenderElement.System$Windows$Media$IBorderRenderElement$BorderThickness = this.BorderThickness;
                    this.borderRenderElement.System$Windows$Media$IBorderRenderElement$Bounds = new System.Windows.Rect.$ctor3(this.VisualSize);
                    this.borderRenderElement.System$Windows$Media$IBorderRenderElement$CornerRadius = this.CornerRadius;
                    this.borderRenderElement.System$Windows$Media$IBorderRenderElement$IsHitTestVisible = this.IsHitTestVisible;
                }

                return this.borderRenderElement;
            },
            MeasureOverride: function (availableSize) {
                return System.Windows.Size.op_Addition(System.Windows.Size.op_Addition(System.Windows.Controls.Decorator.prototype.MeasureOverride.call(this, System.Windows.SizeExtensions.Max((System.Windows.Size.op_Subtraction(System.Windows.Size.op_Subtraction(availableSize, this.BorderThickness.Size), this.Padding.Size)), System.Windows.Size.Zero)), this.BorderThickness.Size), this.Padding.Size);
            },
            ArrangeOverride: function (finalSize) {
                if (this.Child != null) {
                    this.Child.Arrange(new System.Windows.Rect.$ctor2(System.Windows.Point.op_Addition(this.BorderThickness.Location, this.Padding.Location), System.Windows.SizeExtensions.Max((System.Windows.Size.op_Subtraction(System.Windows.Size.op_Subtraction(finalSize, this.BorderThickness.Size), this.Padding.Size)), System.Windows.Size.Zero)));
                }

                if (this.borderRenderElement != null) {
                    this.borderRenderElement.System$Windows$Media$IBorderRenderElement$Bounds = new System.Windows.Rect.$ctor3(finalSize);
                }

                return finalSize;
            },
            HitTestOverride: function (position) {
                return System.Windows.SizeExtensions.Contains(this.VisualSize, position) && (this.Background != null || this.BorderBrush != null && System.Windows.Controls.Border.IsOverBorder(position, this.VisualSize, this.BorderThickness, this.CornerRadius));
            },
            OnBackgroundChanged: function (e) {
                if (this.borderRenderElement != null) {
                    this.borderRenderElement.System$Windows$Media$IBorderRenderElement$Background = Bridge.cast(e.NewValue, System.Windows.Media.Brush);
                }
            },
            OnBorderBrushChanged: function (e) {
                if (this.borderRenderElement != null) {
                    this.borderRenderElement.System$Windows$Media$IBorderRenderElement$BorderBrush = Bridge.cast(e.NewValue, System.Windows.Media.Brush);
                }
            },
            OnBorderThicknessChanged: function (e) {
                if (this.borderRenderElement != null) {
                    this.borderRenderElement.System$Windows$Media$IBorderRenderElement$BorderThickness = Bridge.cast(e.NewValue, System.Windows.Thickness);
                }
            },
            OnCornerRadiusChanged: function (e) {
                if (this.borderRenderElement != null) {
                    this.borderRenderElement.System$Windows$Media$IBorderRenderElement$CornerRadius = Bridge.cast(e.NewValue, System.Windows.CornerRadius);
                }
            }
        }
    });

    Bridge.ns("System.Windows.Controls.Border", $asm.$);

    Bridge.apply($asm.$.System.Windows.Controls.Border, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.Border).OnBackgroundChanged(e);
        },
        f2: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.Border).OnBorderBrushChanged(e);
        },
        f3: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.Border).OnBorderThicknessChanged(e);
        },
        f4: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.Border).OnCornerRadiusChanged(e);
        }
    });

    Bridge.define("System.Windows.Controls.ContentControl", {
        inherits: [System.Windows.Controls.Control,System.Windows.Controls.IItemContainer],
        statics: {
            fields: {
                ContentProperty: null,
                ContentTemplateProperty: null,
                ContentTemplateSelectorProperty: null,
                HasContentPropertyKey: null,
                HasContentProperty: null
            },
            ctors: {
                init: function () {
                    this.ContentProperty = System.Windows.DependencyProperty.Register("Content", System.Object, System.Windows.Controls.ContentControl, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.ContentControl.f1));
                    this.ContentTemplateProperty = System.Windows.DependencyProperty.Register("ContentTemplate", System.Windows.DataTemplate, System.Windows.Controls.ContentControl, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.ContentTemplateSelectorProperty = System.Windows.DependencyProperty.Register("ContentTemplateSelector", System.Windows.Controls.IDataTemplateSelector, System.Windows.Controls.ContentControl, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.HasContentPropertyKey = System.Windows.DependencyProperty.RegisterReadOnly("HasContent", System.Boolean, System.Windows.Controls.ContentControl, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.HasContentProperty = System.Windows.Controls.ContentControl.HasContentPropertyKey.DependencyProperty;
                },
                ctor: function () {
                    System.Windows.FrameworkElement.DefaultStyleKeyProperty.OverrideMetadata(System.Windows.Controls.ContentControl, new System.Windows.FrameworkPropertyMetadata.$ctor1(new System.Windows.StyleKey(System.Windows.Controls.ContentControl)));
                }
            }
        },
        fields: {
            itemTemplate: null,
            itemContainerStyle: null
        },
        props: {
            Content: {
                get: function () {
                    return this.GetValue(System.Windows.Controls.ContentControl.ContentProperty);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.ContentControl.ContentProperty, value);
                }
            },
            ContentTemplate: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.ContentControl.ContentTemplateProperty), System.Windows.DataTemplate);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.ContentControl.ContentTemplateProperty, value);
                }
            },
            ContentTemplateSelector: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.ContentControl.ContentTemplateSelectorProperty), System.Windows.Controls.IDataTemplateSelector);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.ContentControl.ContentTemplateSelectorProperty, value);
                }
            },
            HasContent: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue$1(System.Windows.Controls.ContentControl.HasContentPropertyKey)), System.Boolean));
                },
                set: function (value) {
                    this.SetValue$1(System.Windows.Controls.ContentControl.HasContentPropertyKey, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            }
        },
        alias: [
            "PrepareContainerForItem", "System$Windows$Controls$IItemContainer$PrepareContainerForItem",
            "ClearContainerForItem", "System$Windows$Controls$IItemContainer$ClearContainerForItem"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Controls.Control.ctor.call(this);
                //
            }
        },
        methods: {
            OnContentChanged: function (e) {
                this.HasContent = this.Content != null;
                this.RemoveLogicalChild(e.OldValue);
                this.AddLogicalChild(e.NewValue);
            },
            PrepareContainerForItem: function (item, itemTemplate, itemContainerStyle) {
                if (!this.ContainsValue(System.Windows.Controls.ContentControl.ContentTemplateProperty) && !this.ContainsValue(System.Windows.Controls.ContentControl.ContentTemplateSelectorProperty) && itemTemplate != null) {
                    this.ContentTemplate = itemTemplate;
                    this.itemTemplate = itemTemplate;
                }

                if (!this.ContainsValue(System.Windows.FrameworkElement.StyleProperty) && itemContainerStyle != null) {
                    this.Style = itemContainerStyle;
                    this.itemContainerStyle = itemContainerStyle;
                }

                if (!Bridge.referenceEquals(item, this)) {
                    this.Content = item;
                }
            },
            ClearContainerForItem: function (item) {
                if (Bridge.referenceEquals(this.itemTemplate, this.ContentTemplate)) {
                    this.ClearValue(System.Windows.Controls.ContentControl.ContentTemplateProperty);
                    this.itemTemplate = null;
                }

                if (Bridge.referenceEquals(this.itemContainerStyle, this.Style)) {
                    this.ClearValue(System.Windows.FrameworkElement.StyleProperty);
                    this.itemContainerStyle = null;
                }

                if (Bridge.referenceEquals(this.Content, item)) {
                    this.ClearValue(System.Windows.Controls.ContentControl.ContentProperty);
                }
            }
        }
    });

    Bridge.ns("System.Windows.Controls.ContentControl", $asm.$);

    Bridge.apply($asm.$.System.Windows.Controls.ContentControl, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.ContentControl).OnContentChanged(e);
        }
    });

    Bridge.define("System.Windows.Controls.Canvas", {
        inherits: [System.Windows.Controls.Panel],
        statics: {
            fields: {
                LeftProperty: null,
                TopProperty: null,
                RightProperty: null,
                BottomProperty: null
            },
            ctors: {
                init: function () {
                    this.LeftProperty = System.Windows.DependencyProperty.RegisterAttached("Left", System.Double, System.Windows.Controls.Canvas, new System.Windows.FrameworkPropertyMetadata.$ctor6(Bridge.box(Number.NaN, System.Double, System.Double.format, System.Double.getHashCode), System.Windows.Controls.Canvas.OnPositioningChanged));
                    this.TopProperty = System.Windows.DependencyProperty.RegisterAttached("Top", System.Double, System.Windows.Controls.Canvas, new System.Windows.FrameworkPropertyMetadata.$ctor6(Bridge.box(Number.NaN, System.Double, System.Double.format, System.Double.getHashCode), System.Windows.Controls.Canvas.OnPositioningChanged));
                    this.RightProperty = System.Windows.DependencyProperty.RegisterAttached("Right", System.Double, System.Windows.Controls.Canvas, new System.Windows.FrameworkPropertyMetadata.$ctor6(Bridge.box(Number.NaN, System.Double, System.Double.format, System.Double.getHashCode), System.Windows.Controls.Canvas.OnPositioningChanged));
                    this.BottomProperty = System.Windows.DependencyProperty.RegisterAttached("Bottom", System.Double, System.Windows.Controls.Canvas, new System.Windows.FrameworkPropertyMetadata.$ctor6(Bridge.box(Number.NaN, System.Double, System.Double.format, System.Double.getHashCode), System.Windows.Controls.Canvas.OnPositioningChanged));
                }
            },
            methods: {
                GetLeft: function (obj) {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj.GetValue(System.Windows.Controls.Canvas.LeftProperty)), System.Double));
                },
                SetLeft: function (obj, value) {
                    obj.SetValue(System.Windows.Controls.Canvas.LeftProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                },
                GetTop: function (obj) {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj.GetValue(System.Windows.Controls.Canvas.TopProperty)), System.Double));
                },
                SetTop: function (obj, value) {
                    obj.SetValue(System.Windows.Controls.Canvas.TopProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                },
                GetRight: function (obj) {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj.GetValue(System.Windows.Controls.Canvas.RightProperty)), System.Double));
                },
                SetRight: function (obj, value) {
                    obj.SetValue(System.Windows.Controls.Canvas.RightProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                },
                GetBottom: function (obj) {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj.GetValue(System.Windows.Controls.Canvas.BottomProperty)), System.Double));
                },
                SetBottom: function (obj, value) {
                    obj.SetValue(System.Windows.Controls.Canvas.BottomProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                },
                OnPositioningChanged: function (dependencyObject, e) {
                    if (Bridge.is(dependencyObject, System.Windows.Media.Visual) && Bridge.is(Bridge.cast(dependencyObject, System.Windows.Media.Visual).VisualParent, System.Windows.Controls.Canvas)) {
                        Bridge.cast(Bridge.cast(dependencyObject, System.Windows.Media.Visual).VisualParent, System.Windows.Controls.Canvas).InvalidateArrange();
                    }
                }
            }
        },
        methods: {
            MeasureOverride: function (availableSize) {
                var $t;
                $t = Bridge.getEnumerator(this.Children);
                try {
                    while ($t.moveNext()) {
                        var child = $t.Current;
                        child.Measure(System.Windows.Size.Infinity);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                return System.Windows.Size.Zero;
            },
            ArrangeOverride: function (finalSize) {
                var $t;
                $t = Bridge.getEnumerator(this.Children);
                try {
                    while ($t.moveNext()) {
                        var child = $t.Current;
                        // Canvas.Left and Canvas.Top have higher priority
                        var x = Granular.Extensions.DoubleExtensions.DefaultIfNaN(Granular.Extensions.DoubleExtensions.DefaultIfNaN(System.Windows.Controls.Canvas.GetLeft(child), finalSize.Width - child.DesiredSize.Width - System.Windows.Controls.Canvas.GetRight(child)), 0);
                        var y = Granular.Extensions.DoubleExtensions.DefaultIfNaN(Granular.Extensions.DoubleExtensions.DefaultIfNaN(System.Windows.Controls.Canvas.GetTop(child), finalSize.Height - child.DesiredSize.Height - System.Windows.Controls.Canvas.GetBottom(child)), 0);

                        child.Arrange(new System.Windows.Rect.$ctor2(new System.Windows.Point.$ctor1(x, y), child.DesiredSize));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                return finalSize;
            }
        }
    });

    Bridge.define("System.Windows.Controls.DockPanel", {
        inherits: [System.Windows.Controls.Panel],
        statics: {
            fields: {
                DockProperty: null,
                LastChildFillProperty: null
            },
            ctors: {
                init: function () {
                    this.DockProperty = System.Windows.DependencyProperty.RegisterAttached("Dock", System.Windows.Controls.Dock, System.Windows.Controls.DockPanel, new System.Windows.FrameworkPropertyMetadata.$ctor11(System.Windows.Controls.DockPanel.OnDockChanged));
                    this.LastChildFillProperty = System.Windows.DependencyProperty.Register("LastChildFill", System.Boolean, System.Windows.Controls.DockPanel, new System.Windows.FrameworkPropertyMetadata.$ctor2(Bridge.box(true, System.Boolean, System.Boolean.toString), System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure));
                }
            },
            methods: {
                GetDock: function (obj) {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj.GetValue(System.Windows.Controls.DockPanel.DockProperty)), System.Int32));
                },
                SetDock: function (obj, value) {
                    obj.SetValue(System.Windows.Controls.DockPanel.DockProperty, Bridge.box(value, System.Windows.Controls.Dock, System.Enum.toStringFn(System.Windows.Controls.Dock)));
                },
                GetDockOrientation: function (dock) {
                    return dock === System.Windows.Controls.Dock.Left || dock === System.Windows.Controls.Dock.Right ? System.Windows.Controls.Orientation.Horizontal : System.Windows.Controls.Orientation.Vertical;
                },
                OnDockChanged: function (dependencyObject, e) {
                    if (Bridge.is(dependencyObject, System.Windows.Media.Visual) && Bridge.is(Bridge.cast(dependencyObject, System.Windows.Media.Visual).VisualParent, System.Windows.Controls.DockPanel)) {
                        Bridge.cast(Bridge.cast(dependencyObject, System.Windows.Media.Visual).VisualParent, System.Windows.Controls.DockPanel).InvalidateArrange();
                    }
                }
            }
        },
        props: {
            LastChildFill: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.DockPanel.LastChildFillProperty)), System.Boolean));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.DockPanel.LastChildFillProperty, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            }
        },
        methods: {
            MeasureOverride: function (availableSize) {
                var $t;
                var remainingWidth = availableSize.Width;
                var remainingHeight = availableSize.Height;

                $t = Bridge.getEnumerator(this.Children);
                try {
                    while ($t.moveNext()) {
                        var child = $t.Current;
                        child.Measure(System.Windows.SizeExtensions.Max(new System.Windows.Size(remainingWidth, remainingHeight), System.Windows.Size.Zero));

                        if (System.Windows.Controls.DockPanel.GetDockOrientation(System.Windows.Controls.DockPanel.GetDock(child)) === System.Windows.Controls.Orientation.Horizontal) {
                            remainingWidth -= child.DesiredSize.Width;
                        } else {
                            remainingHeight -= child.DesiredSize.Height;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                var childrenWidth = 0;
                var childrenHeight = 0;

                for (var i = (this.Children.Count - 1) | 0; i >= 0; i = (i - 1) | 0) {
                    var child1 = this.Children.getItem(i);

                    if (System.Windows.Controls.DockPanel.GetDockOrientation(System.Windows.Controls.DockPanel.GetDock(child1)) === System.Windows.Controls.Orientation.Horizontal) {
                        childrenWidth += child1.DesiredSize.Width;
                        childrenHeight = Math.max(childrenHeight, child1.DesiredSize.Height);
                    } else {
                        childrenHeight += child1.DesiredSize.Height;
                        childrenWidth = Math.max(childrenWidth, child1.DesiredSize.Width);
                    }
                }

                return new System.Windows.Size(childrenWidth, childrenHeight);
            },
            ArrangeOverride: function (finalSize) {
                var remainingWidth = finalSize.Width;
                var remainingHeight = finalSize.Height;

                var left = 0;
                var top = 0;

                for (var i = 0; i < this.Children.Count; i = (i + 1) | 0) {
                    var child = this.Children.getItem(i);
                    var childDock = System.Windows.Controls.DockPanel.GetDock(child);
                    var childDockOrientation = System.Windows.Controls.DockPanel.GetDockOrientation(childDock);

                    var childFill = this.LastChildFill && i === ((this.Children.Count - 1) | 0);

                    var cellWidth = childDockOrientation === System.Windows.Controls.Orientation.Vertical || childFill ? remainingWidth : child.DesiredSize.Width;
                    var cellHeight = childDockOrientation === System.Windows.Controls.Orientation.Horizontal || childFill ? remainingHeight : child.DesiredSize.Height;

                    var cellLeft = childDock === System.Windows.Controls.Dock.Right ? remainingWidth - cellWidth : 0;
                    var cellTop = childDock === System.Windows.Controls.Dock.Bottom ? remainingHeight - cellHeight : 0;

                    child.Arrange(new System.Windows.Rect.$ctor1(left + cellLeft, top + cellTop, Granular.Extensions.DoubleExtensions.Max(cellWidth, 0), Granular.Extensions.DoubleExtensions.Max(cellHeight, 0)));

                    if (childDockOrientation === System.Windows.Controls.Orientation.Horizontal) {
                        remainingWidth -= cellWidth;

                        if (childDock === System.Windows.Controls.Dock.Left) {
                            left += cellWidth;
                        }
                    } else {
                        remainingHeight -= cellHeight;

                        if (childDock === System.Windows.Controls.Dock.Top) {
                            top += cellHeight;
                        }
                    }
                }

                return finalSize;
            }
        }
    });

    Bridge.define("System.Windows.Controls.Grid", {
        inherits: [System.Windows.Controls.Panel],
        statics: {
            fields: {
                RowProperty: null,
                ColumnProperty: null,
                RowSpanProperty: null,
                ColumnSpanProperty: null
            },
            ctors: {
                init: function () {
                    this.RowProperty = System.Windows.DependencyProperty.RegisterAttached("Row", System.Int32, System.Windows.Controls.Grid, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.ColumnProperty = System.Windows.DependencyProperty.RegisterAttached("Column", System.Int32, System.Windows.Controls.Grid, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.RowSpanProperty = System.Windows.DependencyProperty.RegisterAttached("RowSpan", System.Int32, System.Windows.Controls.Grid, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(1, System.Int32)));
                    this.ColumnSpanProperty = System.Windows.DependencyProperty.RegisterAttached("ColumnSpan", System.Int32, System.Windows.Controls.Grid, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(1, System.Int32)));
                }
            },
            methods: {
                GetRow: function (obj) {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj.GetValue(System.Windows.Controls.Grid.RowProperty)), System.Int32));
                },
                SetRow: function (obj, value) {
                    obj.SetValue(System.Windows.Controls.Grid.RowProperty, Bridge.box(value, System.Int32));
                },
                GetColumn: function (obj) {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj.GetValue(System.Windows.Controls.Grid.ColumnProperty)), System.Int32));
                },
                SetColumn: function (obj, value) {
                    obj.SetValue(System.Windows.Controls.Grid.ColumnProperty, Bridge.box(value, System.Int32));
                },
                GetRowSpan: function (obj) {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj.GetValue(System.Windows.Controls.Grid.RowSpanProperty)), System.Int32));
                },
                SetRowSpan: function (obj, value) {
                    obj.SetValue(System.Windows.Controls.Grid.RowSpanProperty, Bridge.box(value, System.Int32));
                },
                GetColumnSpan: function (obj) {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj.GetValue(System.Windows.Controls.Grid.ColumnSpanProperty)), System.Int32));
                },
                SetColumnSpan: function (obj, value) {
                    obj.SetValue(System.Windows.Controls.Grid.ColumnSpanProperty, Bridge.box(value, System.Int32));
                },
                GetChildPosition: function (child, rowsCount, columnsCount, row, column, rowSpan, columnSpan) {
                    row.v = Granular.Extensions.IntExtensions.Bounds(System.Windows.Controls.Grid.GetRow(child), 0, ((rowsCount - 1) | 0));
                    column.v = Granular.Extensions.IntExtensions.Bounds(System.Windows.Controls.Grid.GetColumn(child), 0, ((columnsCount - 1) | 0));
                    rowSpan.v = Granular.Extensions.IntExtensions.Bounds(System.Windows.Controls.Grid.GetRowSpan(child), 1, ((rowsCount - row.v) | 0));
                    columnSpan.v = Granular.Extensions.IntExtensions.Bounds(System.Windows.Controls.Grid.GetColumnSpan(child), 1, ((columnsCount - column.v) | 0));
                },
                GetMeasureLength: function (definitionBases, availableLength, start, span) {
                    var remainingLength = availableLength;
                    var absoluteLength = 0;
                    var allAbsolute = true;

                    for (var i = 0; i < definitionBases.length; i = (i + 1) | 0) {
                        if (i >= start && i < start + span) {
                            if (definitionBases[System.Array.index(i, definitionBases)].System$Windows$Controls$IDefinitionBase$Length.IsAbsolute) {
                                absoluteLength += definitionBases[System.Array.index(i, definitionBases)].System$Windows$Controls$IDefinitionBase$Length.Value;
                            } else {
                                allAbsolute = false;
                            }
                        } else if (definitionBases[System.Array.index(i, definitionBases)].System$Windows$Controls$IDefinitionBase$Length.IsAbsolute) {
                            remainingLength -= definitionBases[System.Array.index(i, definitionBases)].System$Windows$Controls$IDefinitionBase$Length.Value;
                        }
                    }

                    return allAbsolute ? absoluteLength : Math.max(0, remainingLength);
                },
                SetBoundedValues: function (definitionBases, lengths) {
                    for (var i = 0; i < lengths.v.length; i = (i + 1) | 0) {
                        lengths.v[System.Array.index(i, lengths.v)] = Granular.Extensions.DoubleExtensions.Bounds(lengths.v[System.Array.index(i, lengths.v)], definitionBases[System.Array.index(i, definitionBases)].System$Windows$Controls$IDefinitionBase$MinLength, definitionBases[System.Array.index(i, definitionBases)].System$Windows$Controls$IDefinitionBase$MaxLength);
                    }
                },
                SetStarLengths: function (definitionBases, starLength, lengths) {
                    for (var i = 0; i < definitionBases.length; i = (i + 1) | 0) {
                        if (definitionBases[System.Array.index(i, definitionBases)].System$Windows$Controls$IDefinitionBase$Length.IsStar) {
                            lengths.v[System.Array.index(i, lengths.v)] = definitionBases[System.Array.index(i, definitionBases)].System$Windows$Controls$IDefinitionBase$Length.Value * starLength;
                        }
                    }
                },
                SetActualLength: function (definitionBases, actualLengths) {
                    for (var i = 0; i < definitionBases.length; i = (i + 1) | 0) {
                        definitionBases[System.Array.index(i, definitionBases)].System$Windows$Controls$IDefinitionBase$ActualLength = actualLengths[System.Array.index(i, actualLengths)];
                    }
                },
                GetStarLength: function (definitionBases, totalStarsLength) {
                    // each axis starred length is a bounded function:
                    // axis.GetStarredLength(starLength) => (axis.Length.Value * starLength).Bounds(axis.MinLength, axis.MaxLength)

                    // find a starLength where:
                    // definitionBases.Sum(axis => axis.GetStarredLength(starLength)) == totalStarsLength

                    var starredAxis = Granular.Compatibility.Linq.Enumerable.Where(Bridge.global.System.Windows.Controls.IDefinitionBase, definitionBases, $asm.$.System.Windows.Controls.Grid.f1);

                    if (Granular.Compatibility.Linq.Enumerable.Count(Bridge.global.System.Windows.Controls.IDefinitionBase, starredAxis) === 0 || totalStarsLength <= 0) {
                        return 0;
                    }

                    if (Granular.Compatibility.Linq.Enumerable.Count(Bridge.global.System.Windows.Controls.IDefinitionBase, starredAxis) === 1) {
                        return totalStarsLength;
                    }

                    var bounds = Granular.Compatibility.Linq.Enumerable.ToArray(System.Double, Granular.Compatibility.Linq.Enumerable.Union(System.Double, Granular.Compatibility.Linq.Enumerable.Select(Bridge.global.System.Windows.Controls.IDefinitionBase, System.Double, starredAxis, $asm.$.System.Windows.Controls.Grid.f2), Granular.Compatibility.Linq.Enumerable.Select(Bridge.global.System.Windows.Controls.IDefinitionBase, System.Double, starredAxis, $asm.$.System.Windows.Controls.Grid.f3)));

                    var smallerBound = Granular.Compatibility.Linq.Enumerable.Max$1(Granular.Compatibility.Linq.Enumerable.DefaultIfEmpty$1(System.Double, Granular.Compatibility.Linq.Enumerable.Where(System.Double, bounds, function (vertex) {
                        return Granular.Compatibility.Linq.Enumerable.Sum$1(Bridge.global.System.Windows.Controls.IDefinitionBase, starredAxis, function (axis) {
                            return System.Windows.Controls.Grid.GetStarredAxisLength(axis, vertex);
                        }) <= totalStarsLength;
                    }), Number.NaN));
                    var largerBound = Granular.Compatibility.Linq.Enumerable.Min$1(Granular.Compatibility.Linq.Enumerable.DefaultIfEmpty$1(System.Double, Granular.Compatibility.Linq.Enumerable.Where(System.Double, bounds, function (vertex) {
                        return Granular.Compatibility.Linq.Enumerable.Sum$1(Bridge.global.System.Windows.Controls.IDefinitionBase, starredAxis, function (axis) {
                            return System.Windows.Controls.Grid.GetStarredAxisLength(axis, vertex);
                        }) >= totalStarsLength;
                    }), Number.NaN));

                    if (!isNaN(smallerBound) && !isNaN(largerBound)) {
                        if (smallerBound === largerBound) {
                            return smallerBound;
                        }

                        if ((Math.abs(largerBound) === Number.POSITIVE_INFINITY)) {
                            var totalSmallerStarsLength = Granular.Compatibility.Linq.Enumerable.Sum$1(Bridge.global.System.Windows.Controls.IDefinitionBase, Granular.Compatibility.Linq.Enumerable.Where(Bridge.global.System.Windows.Controls.IDefinitionBase, starredAxis, function (axis) {
                                return axis.System$Windows$Controls$IDefinitionBase$MaxLength <= axis.System$Windows$Controls$IDefinitionBase$Length.Value * smallerBound;
                            }), function (axis) {
                                return System.Windows.Controls.Grid.GetStarredAxisLength(axis, smallerBound);
                            });
                            var totalLargerStars = Granular.Compatibility.Linq.Enumerable.Sum$1(Bridge.global.System.Windows.Controls.IDefinitionBase, Granular.Compatibility.Linq.Enumerable.Where(Bridge.global.System.Windows.Controls.IDefinitionBase, starredAxis, function (axis) {
                                return axis.System$Windows$Controls$IDefinitionBase$MaxLength > axis.System$Windows$Controls$IDefinitionBase$Length.Value * smallerBound;
                            }), $asm.$.System.Windows.Controls.Grid.f4);

                            return (totalStarsLength - totalSmallerStarsLength) / totalLargerStars;
                        }

                        var smallerBoundTotalLength = Granular.Compatibility.Linq.Enumerable.Sum$1(Bridge.global.System.Windows.Controls.IDefinitionBase, starredAxis, function (axis) {
                            return System.Windows.Controls.Grid.GetStarredAxisLength(axis, smallerBound);
                        });
                        var largerBoundTotalLength = Granular.Compatibility.Linq.Enumerable.Sum$1(Bridge.global.System.Windows.Controls.IDefinitionBase, starredAxis, function (axis) {
                            return System.Windows.Controls.Grid.GetStarredAxisLength(axis, largerBound);
                        });

                        return smallerBound + (largerBound - smallerBound) * (totalStarsLength - smallerBoundTotalLength) / (largerBoundTotalLength - smallerBoundTotalLength);
                    }

                    return Granular.Extensions.DoubleExtensions.DefaultIfNaN(Granular.Extensions.DoubleExtensions.DefaultIfNaN(smallerBound, largerBound), 0);
                },
                GetStarredAxisLength: function (starredAxis, starLength) {
                    return Granular.Extensions.DoubleExtensions.Bounds((starredAxis.System$Windows$Controls$IDefinitionBase$Length.Value * starLength), starredAxis.System$Windows$Controls$IDefinitionBase$MinLength, starredAxis.System$Windows$Controls$IDefinitionBase$MaxLength);
                }
            }
        },
        fields: {
            defaultRowDefinitions: null,
            defaultColumnDefinitions: null
        },
        props: {
            RowDefinitions: null,
            ColumnDefinitions: null
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Controls.Panel.ctor.call(this);
                this.RowDefinitions = new (System.Windows.FreezableCollection$1(System.Windows.Controls.RowDefinition)).ctor();
                this.RowDefinitions.TrySetContextParent(this);

                this.ColumnDefinitions = new (System.Windows.FreezableCollection$1(System.Windows.Controls.ColumnDefinition)).ctor();
                this.ColumnDefinitions.TrySetContextParent(this);

                this.defaultRowDefinitions = System.Array.init([new System.Windows.Controls.RowDefinition()], System.Windows.Controls.RowDefinition);
                this.defaultColumnDefinitions = System.Array.init([new System.Windows.Controls.ColumnDefinition()], System.Windows.Controls.ColumnDefinition);
            }
        },
        methods: {
            MeasureOverride: function (availableSize) {
                var $t;
                var currentRowDefinitions = this.RowDefinitions.Count === 0 ? this.defaultRowDefinitions : Granular.Compatibility.Linq.Enumerable.ToArray(Bridge.global.System.Windows.Controls.RowDefinition, this.RowDefinitions);
                var currentColumnDefinitions = this.ColumnDefinitions.Count === 0 ? this.defaultColumnDefinitions : Granular.Compatibility.Linq.Enumerable.ToArray(Bridge.global.System.Windows.Controls.ColumnDefinition, this.ColumnDefinitions);

                if (currentRowDefinitions.length === 1 && currentColumnDefinitions.length === 1) {
                    // optimization
                    return this.MeasureSingleCell(availableSize, currentColumnDefinitions[System.Array.index(0, currentColumnDefinitions)].System$Windows$Controls$IDefinitionBase$Length, currentRowDefinitions[System.Array.index(0, currentRowDefinitions)].System$Windows$Controls$IDefinitionBase$Length);
                }

                var rowsLength = { v : Granular.Compatibility.Linq.Enumerable.ToArray(System.Double, Granular.Compatibility.Linq.Enumerable.Select(Bridge.global.System.Windows.Controls.IDefinitionBase, System.Double, currentRowDefinitions, $asm.$.System.Windows.Controls.Grid.f5)) };
                var columnsLength = { v : Granular.Compatibility.Linq.Enumerable.ToArray(System.Double, Granular.Compatibility.Linq.Enumerable.Select(Bridge.global.System.Windows.Controls.IDefinitionBase, System.Double, currentColumnDefinitions, $asm.$.System.Windows.Controls.Grid.f5)) };

                var row = { };
                var column = { };
                var rowSpan = { };
                var columnSpan = { };

                $t = Bridge.getEnumerator(this.Children);
                try {
                    while ($t.moveNext()) {
                        var child = Bridge.cast($t.Current, System.Windows.FrameworkElement);
                        System.Windows.Controls.Grid.GetChildPosition(child, currentRowDefinitions.length, currentColumnDefinitions.length, row, column, rowSpan, columnSpan);

                        child.Measure(new System.Windows.Size(System.Windows.Controls.Grid.GetMeasureLength(currentColumnDefinitions, availableSize.Width, column.v, columnSpan.v), System.Windows.Controls.Grid.GetMeasureLength(currentRowDefinitions, availableSize.Height, row.v, rowSpan.v)));

                        if (rowSpan.v === 1 && (currentRowDefinitions[System.Array.index(row.v, currentRowDefinitions)].System$Windows$Controls$IDefinitionBase$Length.IsAuto || currentRowDefinitions[System.Array.index(row.v, currentRowDefinitions)].System$Windows$Controls$IDefinitionBase$Length.IsStar)) {
                            rowsLength.v[System.Array.index(row.v, rowsLength.v)] = Math.max(rowsLength.v[System.Array.index(row.v, rowsLength.v)], child.DesiredSize.Height);
                        }

                        if (columnSpan.v === 1 && (currentColumnDefinitions[System.Array.index(column.v, currentColumnDefinitions)].System$Windows$Controls$IDefinitionBase$Length.IsAuto || currentColumnDefinitions[System.Array.index(column.v, currentColumnDefinitions)].System$Windows$Controls$IDefinitionBase$Length.IsStar)) {
                            columnsLength.v[System.Array.index(column.v, columnsLength.v)] = Math.max(columnsLength.v[System.Array.index(column.v, columnsLength.v)], child.DesiredSize.Width);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                System.Windows.Controls.Grid.SetBoundedValues(currentRowDefinitions, rowsLength);
                System.Windows.Controls.Grid.SetBoundedValues(currentColumnDefinitions, columnsLength);

                return new System.Windows.Size(Granular.Compatibility.Linq.Enumerable.Sum(columnsLength.v), Granular.Compatibility.Linq.Enumerable.Sum(rowsLength.v));
            },
            ArrangeOverride: function (finalSize) {
                var $t, $t1;
                var currentRowDefinitions = this.RowDefinitions.Count === 0 ? this.defaultRowDefinitions : Granular.Compatibility.Linq.Enumerable.ToArray(Bridge.global.System.Windows.Controls.RowDefinition, this.RowDefinitions);
                var currentColumnDefinitions = this.ColumnDefinitions.Count === 0 ? this.defaultColumnDefinitions : Granular.Compatibility.Linq.Enumerable.ToArray(Bridge.global.System.Windows.Controls.ColumnDefinition, this.ColumnDefinitions);

                if (currentRowDefinitions.length === 1 && currentColumnDefinitions.length === 1) {
                    // optimization
                    return this.ArrangeSingleCell(finalSize, currentColumnDefinitions[System.Array.index(0, currentColumnDefinitions)], currentRowDefinitions[System.Array.index(0, currentRowDefinitions)]);
                }

                var rowsLength = { v : Granular.Compatibility.Linq.Enumerable.ToArray(System.Double, Granular.Compatibility.Linq.Enumerable.Select(Bridge.global.System.Windows.Controls.IDefinitionBase, System.Double, currentRowDefinitions, $asm.$.System.Windows.Controls.Grid.f5)) };
                var columnsLength = { v : Granular.Compatibility.Linq.Enumerable.ToArray(System.Double, Granular.Compatibility.Linq.Enumerable.Select(Bridge.global.System.Windows.Controls.IDefinitionBase, System.Double, currentColumnDefinitions, $asm.$.System.Windows.Controls.Grid.f5)) };

                var row = { };
                var column = { };
                var rowSpan = { };
                var columnSpan = { };

                $t = Bridge.getEnumerator(this.Children);
                try {
                    while ($t.moveNext()) {
                        var child = Bridge.cast($t.Current, System.Windows.FrameworkElement);
                        System.Windows.Controls.Grid.GetChildPosition(child, currentRowDefinitions.length, currentColumnDefinitions.length, row, column, rowSpan, columnSpan);

                        if (rowSpan.v === 1 && currentRowDefinitions[System.Array.index(row.v, currentRowDefinitions)].System$Windows$Controls$IDefinitionBase$Length.IsAuto) {
                            rowsLength.v[System.Array.index(row.v, rowsLength.v)] = Math.max(rowsLength.v[System.Array.index(row.v, rowsLength.v)], child.DesiredSize.Height);
                        }

                        if (columnSpan.v === 1 && currentColumnDefinitions[System.Array.index(column.v, currentColumnDefinitions)].System$Windows$Controls$IDefinitionBase$Length.IsAuto) {
                            columnsLength.v[System.Array.index(column.v, columnsLength.v)] = Math.max(columnsLength.v[System.Array.index(column.v, columnsLength.v)], child.DesiredSize.Width);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                var rowStarLength = System.Windows.Controls.Grid.GetStarLength(currentRowDefinitions, finalSize.Height - Granular.Compatibility.Linq.Enumerable.Sum(rowsLength.v));
                var columnStarLength = System.Windows.Controls.Grid.GetStarLength(currentColumnDefinitions, finalSize.Width - Granular.Compatibility.Linq.Enumerable.Sum(columnsLength.v));

                System.Windows.Controls.Grid.SetStarLengths(currentRowDefinitions, rowStarLength, rowsLength);
                System.Windows.Controls.Grid.SetStarLengths(currentColumnDefinitions, columnStarLength, columnsLength);

                System.Windows.Controls.Grid.SetBoundedValues(currentRowDefinitions, rowsLength);
                System.Windows.Controls.Grid.SetBoundedValues(currentColumnDefinitions, columnsLength);

                System.Windows.Controls.Grid.SetActualLength(currentRowDefinitions, rowsLength.v);
                System.Windows.Controls.Grid.SetActualLength(currentColumnDefinitions, columnsLength.v);

                $t1 = Bridge.getEnumerator(this.Children);
                try {
                    while ($t1.moveNext()) {
                        var child1 = Bridge.cast($t1.Current, System.Windows.FrameworkElement);
                        System.Windows.Controls.Grid.GetChildPosition(child1, currentRowDefinitions.length, currentColumnDefinitions.length, row, column, rowSpan, columnSpan);

                        child1.Arrange(new System.Windows.Rect.$ctor1(Granular.Compatibility.Linq.Enumerable.Sum(Granular.Compatibility.Linq.Enumerable.Take(System.Double, columnsLength.v, column.v)), Granular.Compatibility.Linq.Enumerable.Sum(Granular.Compatibility.Linq.Enumerable.Take(System.Double, rowsLength.v, row.v)), Granular.Compatibility.Linq.Enumerable.Sum(Granular.Compatibility.Linq.Enumerable.Take(System.Double, Granular.Compatibility.Linq.Enumerable.Skip(System.Double, columnsLength.v, column.v), columnSpan.v)), Granular.Compatibility.Linq.Enumerable.Sum(Granular.Compatibility.Linq.Enumerable.Take(System.Double, Granular.Compatibility.Linq.Enumerable.Skip(System.Double, rowsLength.v, row.v), rowSpan.v))));
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$dispose();
                    }
                }
                return finalSize;
            },
            MeasureSingleCell: function (availableSize, width, height) {
                var $t;
                var desiredSize = System.Windows.Size.Zero;
                availableSize = new System.Windows.Size(width.IsAbsolute ? width.Value : availableSize.Width, height.IsAbsolute ? height.Value : availableSize.Height);

                $t = Bridge.getEnumerator(this.Children);
                try {
                    while ($t.moveNext()) {
                        var child = Bridge.cast($t.Current, System.Windows.FrameworkElement);
                        child.Measure(availableSize);
                        desiredSize = System.Windows.SizeExtensions.Max(desiredSize, child.DesiredSize);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                return desiredSize;
            },
            ArrangeSingleCell: function (finalSize, columnDefinition, rowDefinition) {
                var $t;
                var finalWidth = rowDefinition.System$Windows$Controls$IDefinitionBase$Length.IsAbsolute ? rowDefinition.System$Windows$Controls$IDefinitionBase$Length.Value : finalSize.Width;
                var finalHeight = columnDefinition.System$Windows$Controls$IDefinitionBase$Length.IsAbsolute ? columnDefinition.System$Windows$Controls$IDefinitionBase$Length.Value : finalSize.Height;

                var finalRect = new System.Windows.Rect.ctor(finalWidth, finalHeight);

                $t = Bridge.getEnumerator(this.Children);
                try {
                    while ($t.moveNext()) {
                        var child = Bridge.cast($t.Current, System.Windows.FrameworkElement);
                        child.Arrange(finalRect);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                columnDefinition.System$Windows$Controls$IDefinitionBase$ActualLength = finalWidth;
                rowDefinition.System$Windows$Controls$IDefinitionBase$ActualLength = finalHeight;

                return finalSize;
            }
        }
    });

    Bridge.ns("System.Windows.Controls.Grid", $asm.$);

    Bridge.apply($asm.$.System.Windows.Controls.Grid, {
        f1: function (axis) {
            return axis.System$Windows$Controls$IDefinitionBase$Length.IsStar;
        },
        f2: function (axis) {
            return axis.System$Windows$Controls$IDefinitionBase$MinLength / axis.System$Windows$Controls$IDefinitionBase$Length.Value;
        },
        f3: function (axis) {
            return axis.System$Windows$Controls$IDefinitionBase$MaxLength / axis.System$Windows$Controls$IDefinitionBase$Length.Value;
        },
        f4: function (axis) {
            return axis.System$Windows$Controls$IDefinitionBase$Length.Value;
        },
        f5: function (definitionBase) {
            return definitionBase.System$Windows$Controls$IDefinitionBase$Length.IsAbsolute ? definitionBase.System$Windows$Controls$IDefinitionBase$Length.Value : 0;
        }
    });

    Bridge.define("System.Windows.Controls.ItemsControl", {
        inherits: [System.Windows.Controls.Control,System.Windows.Controls.Primitives.IGeneratorHost],
        statics: {
            fields: {
                ItemsSourceProperty: null,
                ItemContainerStyleProperty: null,
                ItemContainerStyleSelectorProperty: null,
                ItemsPanelProperty: null,
                ItemTemplateProperty: null,
                ItemTemplateSelectorProperty: null,
                ItemContainerGeneratorPropertyKey: null,
                ItemContainerGeneratorProperty: null
            },
            ctors: {
                init: function () {
                    this.ItemsSourceProperty = System.Windows.DependencyProperty.Register("ItemsSource", System.Collections.IEnumerable, System.Windows.Controls.ItemsControl, new System.Windows.FrameworkPropertyMetadata.$ctor6(null, $asm.$.System.Windows.Controls.ItemsControl.f1));
                    this.ItemContainerStyleProperty = System.Windows.DependencyProperty.Register("ItemContainerStyle", System.Windows.Style, System.Windows.Controls.ItemsControl, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.ItemContainerStyleSelectorProperty = System.Windows.DependencyProperty.Register("ItemContainerStyleSelector", System.Windows.Controls.IStyleSelector, System.Windows.Controls.ItemsControl, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.ItemsPanelProperty = System.Windows.DependencyProperty.Register("ItemsPanel", System.Windows.IFrameworkTemplate, System.Windows.Controls.ItemsControl, new System.Windows.FrameworkPropertyMetadata.$ctor1(new System.Windows.Controls.ItemsControl.DefaultItemsPanelTemplate()));
                    this.ItemTemplateProperty = System.Windows.DependencyProperty.Register("ItemTemplate", System.Windows.DataTemplate, System.Windows.Controls.ItemsControl, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.ItemTemplateSelectorProperty = System.Windows.DependencyProperty.Register("ItemTemplateSelector", System.Windows.Controls.IDataTemplateSelector, System.Windows.Controls.ItemsControl, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.ItemContainerGeneratorPropertyKey = System.Windows.DependencyProperty.RegisterReadOnly("ItemContainerGenerator", System.Windows.Controls.Primitives.IItemContainerGenerator, System.Windows.Controls.ItemsControl, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.ItemContainerGeneratorProperty = System.Windows.Controls.ItemsControl.ItemContainerGeneratorPropertyKey.DependencyProperty;
                },
                ctor: function () {
                    System.Windows.FrameworkElement.DefaultStyleKeyProperty.OverrideMetadata(System.Windows.Controls.ItemsControl, new System.Windows.FrameworkPropertyMetadata.$ctor1(new System.Windows.StyleKey(System.Windows.Controls.ItemsControl)));
                }
            }
        },
        props: {
            ItemsSource: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.ItemsControl.ItemsSourceProperty), System.Collections.IEnumerable);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.ItemsControl.ItemsSourceProperty, value);
                }
            },
            ItemContainerStyle: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.ItemsControl.ItemContainerStyleProperty), System.Windows.Style);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.ItemsControl.ItemContainerStyleProperty, value);
                }
            },
            ItemContainerStyleSelector: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.ItemsControl.ItemContainerStyleSelectorProperty), System.Windows.Controls.IStyleSelector);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.ItemsControl.ItemContainerStyleSelectorProperty, value);
                }
            },
            ItemsPanel: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.ItemsControl.ItemsPanelProperty), System.Windows.IFrameworkTemplate);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.ItemsControl.ItemsPanelProperty, value);
                }
            },
            ItemTemplate: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.ItemsControl.ItemTemplateProperty), System.Windows.DataTemplate);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.ItemsControl.ItemTemplateProperty, value);
                }
            },
            ItemTemplateSelector: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.ItemsControl.ItemTemplateSelectorProperty), System.Windows.Controls.IDataTemplateSelector);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.ItemsControl.ItemTemplateSelectorProperty, value);
                }
            },
            Items: null,
            System$Windows$Controls$Primitives$IGeneratorHost$View: {
                get: function () {
                    return this.Items;
                }
            },
            ItemContainerGenerator: {
                get: function () {
                    return Bridge.cast(this.GetValue$1(System.Windows.Controls.ItemsControl.ItemContainerGeneratorPropertyKey), System.Windows.Controls.Primitives.IItemContainerGenerator);
                },
                set: function (value) {
                    this.SetValue$1(System.Windows.Controls.ItemsControl.ItemContainerGeneratorPropertyKey, value);
                }
            }
        },
        alias: [
            "GetContainerForItem", "System$Windows$Controls$Primitives$IGeneratorHost$GetContainerForItem",
            "PrepareContainerForItem", "System$Windows$Controls$Primitives$IGeneratorHost$PrepareContainerForItem",
            "ClearContainerForItem", "System$Windows$Controls$Primitives$IGeneratorHost$ClearContainerForItem"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Controls.Control.ctor.call(this);
                this.Items = new System.Windows.Controls.ItemCollection();
                this.ItemContainerGenerator = new System.Windows.Controls.ItemContainerGenerator(this);
            }
        },
        methods: {
            IsItemItsOwnContainer: function (item) {
                return this.IsItemItsOwnContainerOverride(item);
            },
            IsItemItsOwnContainerOverride: function (item) {
                return Bridge.is(item, System.Windows.FrameworkElement);
            },
            GetContainerForItem: function (item) {
                if (this.IsItemItsOwnContainer(item)) {
                    return Bridge.as(item, System.Windows.FrameworkElement);
                }

                return this.GetContainerForItemOverride();
            },
            GetContainerForItemOverride: function () {
                return new System.Windows.Controls.ContentPresenter();
            },
            PrepareContainerForItem: function (item, container) {
                this.PrepareContainerForItemOverride(item, container);

                this.OnPrepareContainerForItem(item, container);
            },
            PrepareContainerForItemOverride: function (item, container) {
                if (Bridge.is(container, System.Windows.Controls.IItemContainer)) {
                    var itemTemplate = this.ItemTemplate || (this.ItemTemplateSelector != null ? this.ItemTemplateSelector.System$Windows$Controls$IDataTemplateSelector$SelectTemplate(item, container) : null);
                    var itemContainerStyle = this.ItemContainerStyle || (this.ItemContainerStyleSelector != null ? this.ItemContainerStyleSelector.System$Windows$Controls$IStyleSelector$SelectStyle(item, container) : null);

                    Bridge.cast(container, System.Windows.Controls.IItemContainer).System$Windows$Controls$IItemContainer$PrepareContainerForItem(item, itemTemplate, itemContainerStyle);
                }
            },
            OnPrepareContainerForItem: function (item, container) {
                //
            },
            ClearContainerForItem: function (item, container) {
                this.ClearContainerForItemOverride(item, container);

                this.OnClearContainerForItem(item, container);
            },
            ClearContainerForItemOverride: function (item, container) {
                if (Bridge.is(container, System.Windows.Controls.IItemContainer)) {
                    Bridge.cast(container, System.Windows.Controls.IItemContainer).System$Windows$Controls$IItemContainer$ClearContainerForItem(item);
                }
            },
            OnClearContainerForItem: function (item, container) {
                //
            },
            OnItemsSourceChanged: function (e) {
                if (this.ItemsSource == null && !this.GetValueSource(System.Windows.Controls.ItemsControl.ItemsSourceProperty).IsExpression) {
                    this.Items.ClearItemsSource();
                } else {
                    this.Items.SetItemsSource(this.ItemsSource);
                }
            }
        }
    });

    Bridge.ns("System.Windows.Controls.ItemsControl", $asm.$);

    Bridge.apply($asm.$.System.Windows.Controls.ItemsControl, {
        f1: function (dependencyObject, e) {
            (Bridge.as(dependencyObject, System.Windows.Controls.ItemsControl)).OnItemsSourceChanged(e);
        }
    });

    Bridge.define("System.Windows.Controls.PasswordBox", {
        inherits: [System.Windows.Controls.Control],
        statics: {
            fields: {
                PasswordChangedEvent: null,
                MaxLengthProperty: null
            },
            ctors: {
                init: function () {
                    this.PasswordChangedEvent = System.Windows.EventManager.RegisterRoutedEvent("PasswordChanged", System.Windows.RoutingStrategy.Bubble, Function, System.Windows.Controls.PasswordBox);
                    this.MaxLengthProperty = System.Windows.Controls.TextBox.MaxLengthProperty.AddOwner(System.Windows.Controls.PasswordBox, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.PasswordBox.f1));
                },
                ctor: function () {
                    System.Windows.UIElement.IsEnabledProperty.OverrideMetadata(System.Windows.Controls.PasswordBox, new System.Windows.FrameworkPropertyMetadata.$ctor9(System.Windows.FrameworkPropertyMetadataOptions.AffectsVisualState, $asm.$.System.Windows.Controls.PasswordBox.f2));
                    System.Windows.UIElement.IsMouseOverProperty.OverrideMetadata(System.Windows.Controls.PasswordBox, new System.Windows.FrameworkPropertyMetadata.$ctor8(System.Windows.FrameworkPropertyMetadataOptions.AffectsVisualState));
                    System.Windows.UIElement.IsFocusedProperty.OverrideMetadata(System.Windows.Controls.PasswordBox, new System.Windows.FrameworkPropertyMetadata.$ctor8(System.Windows.FrameworkPropertyMetadataOptions.AffectsVisualState));
                    System.Windows.FrameworkElement.CursorProperty.OverrideMetadata(System.Windows.Controls.PasswordBox, new System.Windows.FrameworkPropertyMetadata.$ctor1(System.Windows.Input.Cursors.IBeam));
                    System.Windows.FrameworkElement.DefaultStyleKeyProperty.OverrideMetadata(System.Windows.Controls.PasswordBox, new System.Windows.FrameworkPropertyMetadata.$ctor1(new System.Windows.StyleKey(System.Windows.Controls.PasswordBox)));
                }
            }
        },
        fields: {
            password: null,
            textBoxView: null,
            contentHost: null
        },
        props: {
            MaxLength: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.PasswordBox.MaxLengthProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.PasswordBox.MaxLengthProperty, Bridge.box(value, System.Int32));
                }
            },
            Password: {
                get: function () {
                    return this.password;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.password, value)) {
                        return;
                    }

                    this.password = value;
                    this.textBoxView.Text = this.password;
                    this.RaiseEvent(new System.Windows.RoutedEventArgs(System.Windows.Controls.PasswordBox.PasswordChangedEvent, this));
                }
            }
        },
        ctors: {
            ctor: function () {
                var $t;
                this.$initialize();
                System.Windows.Controls.Control.ctor.call(this);
                this.textBoxView = ($t = new System.Windows.Controls.TextBoxView(), $t.IsPassword = true, $t);
                this.textBoxView.addTextChanged(Bridge.fn.bind(this, $asm.$.System.Windows.Controls.PasswordBox.f3));
            }
        },
        methods: {
            addPasswordChanged: function (value) {
                this.AddHandler(System.Windows.Controls.PasswordBox.PasswordChangedEvent, value);
            },
            removePasswordChanged: function (value) {
                this.RemoveHandler(System.Windows.Controls.PasswordBox.PasswordChangedEvent, value);
            },
            OnApplyTemplate: function () {
                System.Windows.Controls.Control.prototype.OnApplyTemplate.call(this);

                if (this.Template == null) {
                    this.contentHost = null;
                } else {
                    this.contentHost = Bridge.as(System.Windows.FrameworkTemplateExtensions.FindName(this.Template, "PART_ContentHost", this), System.Windows.Controls.Decorator);
                    this.contentHost.Child = this.textBoxView;
                }
            },
            SelectAll: function () {
                this.textBoxView.SelectionStart = 0;
                this.textBoxView.SelectionLength = this.Password.length;
            },
            OnGotFocus: function (e) {
                this.textBoxView.FocusRenderElement();
            },
            OnLostFocus: function (e) {
                this.textBoxView.ClearFocusRenderElement();
            },
            OnMouseDown: function (e) {
                this.Focus();
            },
            UpdateVisualState: function (useTransitions) {
                System.Windows.VisualStateManager.GoToState(this, this.GetCommonState(), useTransitions);
                System.Windows.VisualStateManager.GoToState(this, this.GetFocusState(), useTransitions);
            },
            GetCommonState: function () {
                if (!this.IsEnabled) {
                    return System.Windows.Controls.VisualStates.DisabledState;
                }

                if (this.IsMouseOver) {
                    return System.Windows.Controls.VisualStates.MouseOverState;
                }

                return System.Windows.Controls.VisualStates.NormalState;
            },
            GetFocusState: function () {
                return this.IsFocused ? System.Windows.Controls.VisualStates.FocusedState : System.Windows.Controls.VisualStates.UnfocusedState;
            }
        }
    });

    Bridge.ns("System.Windows.Controls.PasswordBox", $asm.$);

    Bridge.apply($asm.$.System.Windows.Controls.PasswordBox, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.PasswordBox).textBoxView.MaxLength = System.Nullable.getValue(Bridge.cast(Bridge.unbox(e.NewValue), System.Int32));
        },
        f2: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.PasswordBox).textBoxView.IsReadOnly = !Bridge.cast(sender, System.Windows.Controls.PasswordBox).IsEnabled;
        },
        f3: function (sender, e) {
            this.Password = this.textBoxView.Text;
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.RangeBase", {
        inherits: [System.Windows.Controls.Control],
        statics: {
            fields: {
                ValueChangedEvent: null,
                ValueProperty: null,
                MinimumProperty: null,
                MaximumProperty: null,
                SmallChangeProperty: null,
                LargeChangeProperty: null
            },
            ctors: {
                init: function () {
                    this.ValueChangedEvent = System.Windows.EventManager.RegisterRoutedEvent("ValueChanged", System.Windows.RoutingStrategy.Bubble, Function, System.Windows.Controls.Primitives.RangeBase);
                    this.ValueProperty = System.Windows.DependencyProperty.Register("Value", System.Double, System.Windows.Controls.Primitives.RangeBase, new System.Windows.FrameworkPropertyMetadata.$ctor10(System.Windows.FrameworkPropertyMetadataOptions.BindsTwoWayByDefault, $asm.$.System.Windows.Controls.Primitives.RangeBase.f1, System.Windows.Controls.Primitives.RangeBase.CoerceValueRange));
                    this.MinimumProperty = System.Windows.DependencyProperty.Register("Minimum", System.Double, System.Windows.Controls.Primitives.RangeBase, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.Primitives.RangeBase.f2));
                    this.MaximumProperty = System.Windows.DependencyProperty.Register("Maximum", System.Double, System.Windows.Controls.Primitives.RangeBase, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.Primitives.RangeBase.f3));
                    this.SmallChangeProperty = System.Windows.DependencyProperty.Register("SmallChange", System.Double, System.Windows.Controls.Primitives.RangeBase, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.LargeChangeProperty = System.Windows.DependencyProperty.Register("LargeChange", System.Double, System.Windows.Controls.Primitives.RangeBase, new System.Windows.FrameworkPropertyMetadata.ctor());
                }
            },
            methods: {
                CoerceValueRange: function (dependencyObject, value) {
                    return Bridge.box(Granular.Extensions.DoubleExtensions.Bounds(System.Nullable.getValue(Bridge.cast(Bridge.unbox(value), System.Double)), Bridge.cast(dependencyObject, System.Windows.Controls.Primitives.RangeBase).Minimum, Bridge.cast(dependencyObject, System.Windows.Controls.Primitives.RangeBase).Maximum), System.Double, System.Double.format, System.Double.getHashCode);
                }
            }
        },
        props: {
            Value: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.RangeBase.ValueProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.RangeBase.ValueProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            Minimum: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.RangeBase.MinimumProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.RangeBase.MinimumProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            Maximum: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.RangeBase.MaximumProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.RangeBase.MaximumProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            SmallChange: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.RangeBase.SmallChangeProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.RangeBase.SmallChangeProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            LargeChange: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.RangeBase.LargeChangeProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.RangeBase.LargeChangeProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            }
        },
        methods: {
            addValueChanged: function (value) {
                this.AddHandler(System.Windows.Controls.Primitives.RangeBase.ValueChangedEvent, value);
            },
            removeValueChanged: function (value) {
                this.RemoveHandler(System.Windows.Controls.Primitives.RangeBase.ValueChangedEvent, value);
            },
            UpdateVisualState: function (useTransitions) {
                System.Windows.VisualStateManager.GoToState(this, this.GetCommonState(), useTransitions);
                System.Windows.VisualStateManager.GoToState(this, this.GetFocusState(), useTransitions);
            },
            OnValueChanged: function (e) {
                this.RaiseEvent(new (System.Windows.RoutedPropertyChangedEventArgs$1(System.Double))(System.Windows.Controls.Primitives.RangeBase.ValueChangedEvent, this, System.Nullable.getValue(Bridge.cast(Bridge.unbox(e.OldValue), System.Double)), System.Nullable.getValue(Bridge.cast(Bridge.unbox(e.NewValue), System.Double))));
            },
            OnMinimumChanged: function (e) {
                this.CoerceValue(System.Windows.Controls.Primitives.RangeBase.ValueProperty); // CoerceValueRange may return a different value
            },
            OnMaximumChanged: function (e) {
                this.CoerceValue(System.Windows.Controls.Primitives.RangeBase.ValueProperty); // CoerceValueRange may return a different value
            },
            GetCommonState: function () {
                if (!this.IsEnabled) {
                    return System.Windows.Controls.VisualStates.DisabledState;
                }

                if (this.IsMouseOver) {
                    return System.Windows.Controls.VisualStates.MouseOverState;
                }

                return System.Windows.Controls.VisualStates.NormalState;
            },
            GetFocusState: function () {
                return this.IsKeyboardFocused ? System.Windows.Controls.VisualStates.FocusedState : System.Windows.Controls.VisualStates.UnfocusedState;
            }
        }
    });

    Bridge.ns("System.Windows.Controls.Primitives.RangeBase", $asm.$);

    Bridge.apply($asm.$.System.Windows.Controls.Primitives.RangeBase, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.Primitives.RangeBase).OnValueChanged(e);
        },
        f2: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.Primitives.RangeBase).OnMinimumChanged(e);
        },
        f3: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.Primitives.RangeBase).OnMaximumChanged(e);
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.TextBoxBase", {
        inherits: [System.Windows.Controls.Control],
        statics: {
            fields: {
                SelectionChangedEvent: null,
                TextChangedEvent: null,
                AcceptsReturnProperty: null,
                AcceptsTabProperty: null,
                IsReadOnlyProperty: null
            },
            ctors: {
                init: function () {
                    this.SelectionChangedEvent = System.Windows.EventManager.RegisterRoutedEvent("SelectionChanged", System.Windows.RoutingStrategy.Direct, Function, System.Windows.Controls.Primitives.TextBoxBase);
                    this.TextChangedEvent = System.Windows.EventManager.RegisterRoutedEvent("TextChanged", System.Windows.RoutingStrategy.Direct, Function, System.Windows.Controls.Primitives.TextBoxBase);
                    this.AcceptsReturnProperty = System.Windows.DependencyProperty.Register("AcceptsReturn", System.Boolean, System.Windows.Controls.Primitives.TextBoxBase, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.AcceptsTabProperty = System.Windows.DependencyProperty.Register("AcceptsTab", System.Boolean, System.Windows.Controls.Primitives.TextBoxBase, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.IsReadOnlyProperty = System.Windows.DependencyProperty.Register("IsReadOnly", System.Boolean, System.Windows.Controls.Primitives.TextBoxBase, new System.Windows.FrameworkPropertyMetadata.ctor());
                },
                ctor: function () {
                    System.Windows.UIElement.IsEnabledProperty.OverrideMetadata(System.Windows.Controls.Primitives.TextBoxBase, new System.Windows.FrameworkPropertyMetadata.$ctor8(System.Windows.FrameworkPropertyMetadataOptions.AffectsVisualState));
                    System.Windows.UIElement.IsMouseOverProperty.OverrideMetadata(System.Windows.Controls.Primitives.TextBoxBase, new System.Windows.FrameworkPropertyMetadata.$ctor8(System.Windows.FrameworkPropertyMetadataOptions.AffectsVisualState));
                    System.Windows.UIElement.IsFocusedProperty.OverrideMetadata(System.Windows.Controls.Primitives.TextBoxBase, new System.Windows.FrameworkPropertyMetadata.$ctor8(System.Windows.FrameworkPropertyMetadataOptions.AffectsVisualState));
                }
            }
        },
        props: {
            AcceptsReturn: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturnProperty)), System.Boolean));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturnProperty, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            },
            AcceptsTab: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.TextBoxBase.AcceptsTabProperty)), System.Boolean));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.TextBoxBase.AcceptsTabProperty, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            },
            IsReadOnly: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.TextBoxBase.IsReadOnlyProperty)), System.Boolean));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.TextBoxBase.IsReadOnlyProperty, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            },
            ContentHost: null
        },
        methods: {
            addSelectionChanged: function (value) {
                this.AddHandler(System.Windows.Controls.Primitives.TextBoxBase.SelectionChangedEvent, value);
            },
            removeSelectionChanged: function (value) {
                this.RemoveHandler(System.Windows.Controls.Primitives.TextBoxBase.SelectionChangedEvent, value);
            },
            addTextChanged: function (value) {
                this.AddHandler(System.Windows.Controls.Primitives.TextBoxBase.TextChangedEvent, value);
            },
            removeTextChanged: function (value) {
                this.RemoveHandler(System.Windows.Controls.Primitives.TextBoxBase.TextChangedEvent, value);
            },
            OnApplyTemplate: function () {
                System.Windows.Controls.Control.prototype.OnApplyTemplate.call(this);

                if (this.Template == null) {
                    this.ContentHost = null;
                } else {
                    this.ContentHost = Bridge.as(System.Windows.FrameworkTemplateExtensions.FindName(this.Template, "PART_ContentHost", this), System.Windows.Controls.Decorator);
                    this.ContentHost.Child = this.GetTextBoxContent();
                }
            },
            OnMouseDown: function (e) {
                this.Focus();
            },
            UpdateVisualState: function (useTransitions) {
                System.Windows.VisualStateManager.GoToState(this, this.GetCommonState(), useTransitions);
                System.Windows.VisualStateManager.GoToState(this, this.GetFocusState(), useTransitions);
            },
            GetCommonState: function () {
                if (!this.IsEnabled) {
                    return System.Windows.Controls.VisualStates.DisabledState;
                }

                if (this.IsMouseOver) {
                    return System.Windows.Controls.VisualStates.MouseOverState;
                }

                return System.Windows.Controls.VisualStates.NormalState;
            },
            GetFocusState: function () {
                return this.IsFocused ? System.Windows.Controls.VisualStates.FocusedState : System.Windows.Controls.VisualStates.UnfocusedState;
            }
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.Thumb", {
        inherits: [System.Windows.Controls.Control],
        statics: {
            fields: {
                DragStartedEvent: null,
                DragDeltaEvent: null,
                DragCompletedEvent: null,
                IsDraggingPropertyKey: null,
                IsDraggingProperty: null
            },
            ctors: {
                init: function () {
                    this.DragStartedEvent = System.Windows.EventManager.RegisterRoutedEvent("DragStarted", System.Windows.RoutingStrategy.Bubble, Function, System.Windows.Controls.Primitives.Thumb);
                    this.DragDeltaEvent = System.Windows.EventManager.RegisterRoutedEvent("DragDelta", System.Windows.RoutingStrategy.Bubble, Function, System.Windows.Controls.Primitives.Thumb);
                    this.DragCompletedEvent = System.Windows.EventManager.RegisterRoutedEvent("DragCompleted", System.Windows.RoutingStrategy.Bubble, Function, System.Windows.Controls.Primitives.Thumb);
                    this.IsDraggingPropertyKey = System.Windows.DependencyProperty.RegisterReadOnly("IsDragging", System.Boolean, System.Windows.Controls.Primitives.Thumb, new System.Windows.FrameworkPropertyMetadata.$ctor8(System.Windows.FrameworkPropertyMetadataOptions.AffectsVisualState));
                    this.IsDraggingProperty = System.Windows.Controls.Primitives.Thumb.IsDraggingPropertyKey.DependencyProperty;
                },
                ctor: function () {
                    System.Windows.UIElement.FocusableProperty.OverrideMetadata(System.Windows.Controls.Primitives.Thumb, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(false, System.Boolean, System.Boolean.toString)));
                    System.Windows.FrameworkElement.DefaultStyleKeyProperty.OverrideMetadata(System.Windows.Controls.Primitives.Thumb, new System.Windows.FrameworkPropertyMetadata.$ctor1(new System.Windows.StyleKey(System.Windows.Controls.Primitives.Thumb)));
                }
            }
        },
        fields: {
            dragStartPosition: null
        },
        props: {
            IsDragging: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue$1(System.Windows.Controls.Primitives.Thumb.IsDraggingPropertyKey)), System.Boolean));
                },
                set: function (value) {
                    this.SetValue$1(System.Windows.Controls.Primitives.Thumb.IsDraggingPropertyKey, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            }
        },
        methods: {
            addDragStarted: function (value) {
                this.AddHandler(System.Windows.Controls.Primitives.Thumb.DragStartedEvent, value);
            },
            removeDragStarted: function (value) {
                this.RemoveHandler(System.Windows.Controls.Primitives.Thumb.DragStartedEvent, value);
            },
            addDragDelta: function (value) {
                this.AddHandler(System.Windows.Controls.Primitives.Thumb.DragDeltaEvent, value);
            },
            removeDragDelta: function (value) {
                this.RemoveHandler(System.Windows.Controls.Primitives.Thumb.DragDeltaEvent, value);
            },
            addDragCompleted: function (value) {
                this.AddHandler(System.Windows.Controls.Primitives.Thumb.DragCompletedEvent, value);
            },
            removeDragCompleted: function (value) {
                this.RemoveHandler(System.Windows.Controls.Primitives.Thumb.DragCompletedEvent, value);
            },
            OnMouseDown: function (e) {
                if (e.ChangedButton === System.Windows.Input.MouseButton.Left) {
                    e.MouseDevice.Capture(this);
                    this.dragStartPosition = e.GetPosition(Bridge.cast(this.VisualParent, System.Windows.IInputElement));

                    this.IsDragging = true;

                    var dragStartedEventArgs = new System.Windows.Controls.Primitives.DragStartedEventArgs(System.Windows.Controls.Primitives.Thumb.DragStartedEvent, this);
                    this.RaiseEvent(dragStartedEventArgs);

                    e.Handled = dragStartedEventArgs.Handled;
                }
            },
            OnMouseMove: function (e) {
                if (this.IsDragging) {
                    var DragDeltaEventArgs = new System.Windows.Controls.Primitives.DragDeltaEventArgs(System.Windows.Controls.Primitives.Thumb.DragDeltaEvent, this, System.Windows.Point.op_Subtraction(e.GetPosition(Bridge.cast(this.VisualParent, System.Windows.IInputElement)), this.dragStartPosition));
                    this.RaiseEvent(DragDeltaEventArgs);

                    e.Handled = DragDeltaEventArgs.Handled;
                }
            },
            OnMouseUp: function (e) {
                if (this.IsDragging) {
                    e.MouseDevice.ReleaseCapture();

                    this.IsDragging = false;

                    var dragCompletedEventArgs = new System.Windows.Controls.Primitives.DragCompletedEventArgs(System.Windows.Controls.Primitives.Thumb.DragCompletedEvent, this, false);
                    this.RaiseEvent(dragCompletedEventArgs);

                    e.Handled = dragCompletedEventArgs.Handled;
                }
            },
            UpdateVisualState: function (useTransitions) {
                System.Windows.VisualStateManager.GoToState(this, this.GetCommonState(), useTransitions);
                System.Windows.VisualStateManager.GoToState(this, this.GetFocusState(), useTransitions);
            },
            GetCommonState: function () {
                if (!this.IsEnabled) {
                    return System.Windows.Controls.VisualStates.DisabledState;
                }

                if (this.IsDragging) {
                    return System.Windows.Controls.VisualStates.PressedState;
                }

                if (this.IsMouseOver) {
                    return System.Windows.Controls.VisualStates.MouseOverState;
                }

                return System.Windows.Controls.VisualStates.NormalState;
            },
            GetFocusState: function () {
                return this.IsKeyboardFocused ? System.Windows.Controls.VisualStates.FocusedState : System.Windows.Controls.VisualStates.UnfocusedState;
            }
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.UniformGrid", {
        inherits: [System.Windows.Controls.Panel],
        statics: {
            fields: {
                RowsProperty: null,
                ColumnsProperty: null,
                FirstColumnProperty: null
            },
            ctors: {
                init: function () {
                    this.RowsProperty = System.Windows.DependencyProperty.Register("Rows", System.Int32, System.Windows.Controls.Primitives.UniformGrid, new System.Windows.FrameworkPropertyMetadata.$ctor8(System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure));
                    this.ColumnsProperty = System.Windows.DependencyProperty.Register("Columns", System.Int32, System.Windows.Controls.Primitives.UniformGrid, new System.Windows.FrameworkPropertyMetadata.$ctor8(System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure));
                    this.FirstColumnProperty = System.Windows.DependencyProperty.Register("FirstColumn", System.Int32, System.Windows.Controls.Primitives.UniformGrid, new System.Windows.FrameworkPropertyMetadata.$ctor8(System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure));
                }
            }
        },
        fields: {
            actualRows: 0,
            actualColumns: 0
        },
        props: {
            Rows: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.UniformGrid.RowsProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.UniformGrid.RowsProperty, Bridge.box(value, System.Int32));
                }
            },
            Columns: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.UniformGrid.ColumnsProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.UniformGrid.ColumnsProperty, Bridge.box(value, System.Int32));
                }
            },
            FirstColumn: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.UniformGrid.FirstColumnProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.UniformGrid.FirstColumnProperty, Bridge.box(value, System.Int32));
                }
            }
        },
        methods: {
            MeasureOverride: function (availableSize) {
                var $t;
                var cellsCount = (this.FirstColumn + System.Linq.Enumerable.from(this.Children).where($asm.$.System.Windows.Controls.Primitives.UniformGrid.f1).count()) | 0;

                if (cellsCount === 0) {
                    return System.Windows.Size.Zero;
                }

                this.actualRows = this.Rows > 0 ? this.Rows : Bridge.Int.clip32(Granular.Extensions.DoubleExtensions.Max(Math.ceil(this.Columns > 0 ? cellsCount / this.Columns : Math.sqrt(cellsCount)), 1));
                this.actualColumns = this.Columns > 0 ? this.Columns : Bridge.Int.clip32(Granular.Extensions.DoubleExtensions.Max(Math.ceil(cellsCount / this.actualRows), 1));

                var availableCellSize = new System.Windows.Size(availableSize.Width / this.actualColumns, availableSize.Height / this.actualRows);
                var desiredCellSize = System.Windows.Size.Zero;

                $t = Bridge.getEnumerator(this.Children);
                try {
                    while ($t.moveNext()) {
                        var child = $t.Current;
                        child.Measure(availableCellSize);
                        desiredCellSize = System.Windows.SizeExtensions.Max(desiredCellSize, child.DesiredSize);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                return new System.Windows.Size(desiredCellSize.Width * this.actualColumns, desiredCellSize.Height * this.actualRows);
            },
            ArrangeOverride: function (finalSize) {
                var $t;
                var cellWidth = finalSize.Width / this.actualColumns;
                var cellHeight = finalSize.Height / this.actualRows;

                var cellIndex = this.FirstColumn;

                $t = Bridge.getEnumerator(this.Children);
                try {
                    while ($t.moveNext()) {
                        var child = $t.Current;
                        var columnIndex = cellIndex % this.actualColumns;
                        var rowIndex = (Bridge.Int.div(cellIndex, this.actualColumns)) | 0;

                        child.Arrange(new System.Windows.Rect.$ctor1(columnIndex * cellWidth, rowIndex * cellHeight, cellWidth, cellHeight));

                        if (child.Visibility !== System.Windows.Visibility.Collapsed) {
                            cellIndex = (cellIndex + 1) | 0;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                return finalSize;
            }
        }
    });

    Bridge.ns("System.Windows.Controls.Primitives.UniformGrid", $asm.$);

    Bridge.apply($asm.$.System.Windows.Controls.Primitives.UniformGrid, {
        f1: function (child) {
            return child.Visibility !== System.Windows.Visibility.Collapsed;
        }
    });

    Bridge.define("System.Windows.Controls.ScrollContentPresenter", {
        inherits: [System.Windows.Controls.ContentPresenter,System.Windows.Controls.Primitives.IScrollInfo,System.Windows.Documents.IAdornerLayerHost],
        statics: {
            fields: {
                CanContentScrollProperty: null
            },
            ctors: {
                init: function () {
                    this.CanContentScrollProperty = System.Windows.Controls.ScrollViewer.CanContentScrollProperty.AddOwner(System.Windows.Controls.ScrollContentPresenter, new System.Windows.FrameworkPropertyMetadata.$ctor9(System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange, System.Windows.Controls.ScrollContentPresenter.OnCanContentScrollChanged));
                }
            },
            methods: {
                OnCanContentScrollChanged: function (dependencyObject, e) {
                    if (Bridge.is(dependencyObject, System.Windows.Controls.ScrollContentPresenter)) {
                        Bridge.cast(dependencyObject, System.Windows.Controls.ScrollContentPresenter).OnCanContentScrollChanged(e);
                    }
                }
            }
        },
        fields: {
            innerScrollInfo: null,
            delegateScrollInfo: null
        },
        props: {
            AdornerLayer: null,
            CanContentScroll: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.ScrollContentPresenter.CanContentScrollProperty)), System.Boolean));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.ScrollContentPresenter.CanContentScrollProperty, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            },
            ExtentSize: {
                get: function () {
                    return this.delegateScrollInfo.System$Windows$Controls$Primitives$IScrollInfo$ExtentSize;
                }
            },
            ViewportSize: {
                get: function () {
                    return this.delegateScrollInfo.System$Windows$Controls$Primitives$IScrollInfo$ViewportSize;
                }
            },
            CanHorizontallyScroll: {
                get: function () {
                    return this.delegateScrollInfo.System$Windows$Controls$Primitives$IScrollInfo$CanHorizontallyScroll;
                },
                set: function (value) {
                    if (this.delegateScrollInfo.System$Windows$Controls$Primitives$IScrollInfo$CanHorizontallyScroll === value) {
                        return;
                    }

                    this.delegateScrollInfo.System$Windows$Controls$Primitives$IScrollInfo$CanHorizontallyScroll = value;
                    this.InvalidateMeasure();
                }
            },
            CanVerticallyScroll: {
                get: function () {
                    return this.delegateScrollInfo.System$Windows$Controls$Primitives$IScrollInfo$CanVerticallyScroll;
                },
                set: function (value) {
                    if (this.delegateScrollInfo.System$Windows$Controls$Primitives$IScrollInfo$CanVerticallyScroll === value) {
                        return;
                    }

                    this.delegateScrollInfo.System$Windows$Controls$Primitives$IScrollInfo$CanVerticallyScroll = value;
                    this.InvalidateMeasure();
                }
            },
            Offset: {
                get: function () {
                    return this.delegateScrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset;
                },
                set: function (value) {
                    if (System.Windows.Point.op_Equality(this.delegateScrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset, value)) {
                        return;
                    }

                    this.delegateScrollInfo.System$Windows$Controls$Primitives$IScrollInfo$Offset = value;
                    this.InvalidateArrange();
                }
            }
        },
        alias: [
            "AdornerLayer", "System$Windows$Documents$IAdornerLayerHost$AdornerLayer",
            "ExtentSize", "System$Windows$Controls$Primitives$IScrollInfo$ExtentSize",
            "ViewportSize", "System$Windows$Controls$Primitives$IScrollInfo$ViewportSize",
            "CanHorizontallyScroll", "System$Windows$Controls$Primitives$IScrollInfo$CanHorizontallyScroll",
            "CanVerticallyScroll", "System$Windows$Controls$Primitives$IScrollInfo$CanVerticallyScroll",
            "Offset", "System$Windows$Controls$Primitives$IScrollInfo$Offset"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Controls.ContentPresenter.ctor.call(this);
                this.innerScrollInfo = new System.Windows.Controls.ScrollContentPresenter.InnerScrollInfo();
                this.delegateScrollInfo = this.innerScrollInfo;

                this.AdornerLayer = new System.Windows.Documents.AdornerLayer();
                this.AddVisualChild(this.AdornerLayer);
            }
        },
        methods: {
            OnTemplateChildChanged: function () {
                // move AdornerLayer to the top
                this.SetVisualChildIndex(this.AdornerLayer, ((System.Linq.Enumerable.from(this.VisualChildren).count() - 1) | 0));
            },
            MeasureOverride: function (availableSize) {
                this.AdornerLayer.Measure(availableSize);

                var availableScrollSize = new System.Windows.Size(this.CanHorizontallyScroll ? Number.POSITIVE_INFINITY : availableSize.Width, this.CanVerticallyScroll ? Number.POSITIVE_INFINITY : availableSize.Height);
                var measuredSize = System.Windows.Controls.ContentPresenter.prototype.MeasureOverride.call(this, availableScrollSize);

                this.innerScrollInfo.ExtentSize = measuredSize;
                this.innerScrollInfo.ViewportSize = availableSize;

                return System.Windows.SizeExtensions.Min(measuredSize, availableSize);
            },
            ArrangeOverride: function (finalSize) {
                this.AdornerLayer.Arrange(new System.Windows.Rect.$ctor3(finalSize));

                if (this.TemplateChild != null) {
                    if (Bridge.referenceEquals(this.delegateScrollInfo, this.innerScrollInfo)) {
                        var finalScrollSize = new System.Windows.Size(this.CanHorizontallyScroll ? Number.POSITIVE_INFINITY : finalSize.Width, this.CanVerticallyScroll ? Number.POSITIVE_INFINITY : finalSize.Height);

                        var childFinalSize = System.Windows.SizeExtensions.Bounds(this.TemplateChild.DesiredSize, finalSize, finalScrollSize);
                        var childOffset = System.Windows.PointExtensions.Bounds(this.Offset, System.Windows.Point.Zero, System.Windows.SizeExtensions.ToPoint(System.Windows.SizeExtensions.Max((System.Windows.Size.op_Subtraction(childFinalSize, this.ViewportSize)), System.Windows.Size.Zero)));

                        this.TemplateChild.Arrange(new System.Windows.Rect.$ctor2(System.Windows.Point.op_UnaryNegation(childOffset), childFinalSize));
                    } else {
                        // CanContentScroll and Content implements IScrollInfo
                        this.TemplateChild.Arrange(new System.Windows.Rect.$ctor3(finalSize));
                    }
                }

                this.innerScrollInfo.ExtentSize = this.TemplateChild != null ? this.TemplateChild.VisualSize : System.Windows.Size.Zero;
                this.innerScrollInfo.ViewportSize = finalSize;

                return finalSize;
            },
            OnContentChanged: function (e) {
                System.Windows.Controls.ContentPresenter.prototype.OnContentChanged.call(this, e);
                this.delegateScrollInfo = this.GetDelegateScrollInfo();
            },
            GetDelegateScrollInfo: function () {
                if (this.CanContentScroll) {
                    if (Bridge.is(this.Content, System.Windows.Controls.Primitives.IScrollInfo)) {
                        return Bridge.cast(this.Content, System.Windows.Controls.Primitives.IScrollInfo);
                    }

                    if (Bridge.is(this.Content, System.Windows.Controls.ItemsPresenter) && Bridge.is(Bridge.cast(this.Content, System.Windows.Controls.ItemsPresenter).Panel, System.Windows.Controls.Primitives.IScrollInfo)) {
                        return Bridge.cast(Bridge.cast(this.Content, System.Windows.Controls.ItemsPresenter).Panel, System.Windows.Controls.Primitives.IScrollInfo);
                    }
                }

                return this.innerScrollInfo;
            },
            OnCanContentScrollChanged: function (e) {
                this.delegateScrollInfo = this.GetDelegateScrollInfo();
            }
        }
    });

    Bridge.define("System.Windows.Controls.StackPanel", {
        inherits: [System.Windows.Controls.Panel],
        statics: {
            fields: {
                OrientationProperty: null,
                FlowDirectionProperty: null
            },
            ctors: {
                init: function () {
                    this.OrientationProperty = System.Windows.DependencyProperty.Register("Orientation", System.Windows.Controls.Orientation, System.Windows.Controls.StackPanel, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(System.Windows.Controls.Orientation.Vertical, System.Windows.Controls.Orientation, System.Enum.toStringFn(System.Windows.Controls.Orientation))));
                    this.FlowDirectionProperty = System.Windows.DependencyProperty.Register("FlowDirection", System.Windows.FlowDirection, System.Windows.Controls.StackPanel, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(System.Windows.FlowDirection.TopDown, System.Windows.FlowDirection, System.Enum.toStringFn(System.Windows.FlowDirection))));
                }
            },
            methods: {
                CreateSize: function (orientation, mainLength, crossLength) {
                    return orientation === System.Windows.Controls.Orientation.Horizontal ? new System.Windows.Size(mainLength, crossLength) : new System.Windows.Size(crossLength, mainLength);
                },
                CreateRect: function (orientation, mainStart, crossStart, mainLength, crossLength) {
                    return orientation === System.Windows.Controls.Orientation.Horizontal ? new System.Windows.Rect.$ctor1(mainStart, crossStart, mainLength, crossLength) : new System.Windows.Rect.$ctor1(crossStart, mainStart, crossLength, mainLength);
                }
            }
        },
        fields: {
            measuredCrossLength: 0
        },
        props: {
            Orientation: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.StackPanel.OrientationProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.StackPanel.OrientationProperty, Bridge.box(value, System.Windows.Controls.Orientation, System.Enum.toStringFn(System.Windows.Controls.Orientation)));
                }
            },
            FlowDirection: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.StackPanel.FlowDirectionProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.StackPanel.FlowDirectionProperty, Bridge.box(value, System.Windows.FlowDirection, System.Enum.toStringFn(System.Windows.FlowDirection)));
                }
            },
            IsNormalFlow: {
                get: function () {
                    return this.FlowDirection === System.Windows.FlowDirection.LeftToRight || this.FlowDirection === System.Windows.FlowDirection.TopDown;
                }
            }
        },
        methods: {
            MeasureOverride: function (availableSize) {
                var $t;
                var availableCrossLength = this.GetCrossLength(availableSize);
                var measureSize = System.Windows.Controls.StackPanel.CreateSize(this.Orientation, Number.POSITIVE_INFINITY, availableCrossLength);

                var mainLength = 0;
                var crossLength = 0;

                $t = Bridge.getEnumerator(this.Children);
                try {
                    while ($t.moveNext()) {
                        var child = Bridge.cast($t.Current, System.Windows.FrameworkElement);
                        child.Measure(measureSize);

                        mainLength += this.GetMainLength(child.DesiredSize);
                        crossLength = Math.max(crossLength, this.GetCrossLength(child.DesiredSize));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                this.measuredCrossLength = availableCrossLength;

                return System.Windows.Controls.StackPanel.CreateSize(this.Orientation, mainLength, crossLength);
            },
            ArrangeOverride: function (finalSize) {
                var $t, $t1;
                var panelMainLength = System.Linq.Enumerable.from(this.Children).select(Bridge.fn.bind(this, $asm.$.System.Windows.Controls.StackPanel.f1)).sum();
                var panelCrossLength = this.GetCrossLength(finalSize);

                if (this.measuredCrossLength !== panelCrossLength) {
                    var measureSize = System.Windows.Controls.StackPanel.CreateSize(this.Orientation, Number.POSITIVE_INFINITY, panelCrossLength);

                    $t = Bridge.getEnumerator(this.Children);
                    try {
                        while ($t.moveNext()) {
                            var child = Bridge.cast($t.Current, System.Windows.FrameworkElement);
                            child.Measure(measureSize);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$dispose();
                        }
                    }
                    this.measuredCrossLength = panelCrossLength;
                }

                var childrenMainLength = 0;
                $t1 = Bridge.getEnumerator(this.Children);
                try {
                    while ($t1.moveNext()) {
                        var child1 = $t1.Current;
                        var childMainLength = this.GetMainLength(child1.DesiredSize);
                        var childMainStart = this.IsNormalFlow ? childrenMainLength : panelMainLength - childrenMainLength - childMainLength;

                        child1.Arrange(System.Windows.Controls.StackPanel.CreateRect(this.Orientation, childMainStart, 0, childMainLength, panelCrossLength));

                        childrenMainLength += childMainLength;
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$dispose();
                    }
                }
                return System.Windows.Controls.StackPanel.CreateSize(this.Orientation, this.GetMainLength(finalSize), panelCrossLength);
            },
            GetMainLength: function (size) {
                return this.Orientation === System.Windows.Controls.Orientation.Horizontal ? size.Width : size.Height;
            },
            GetCrossLength: function (size) {
                return this.Orientation === System.Windows.Controls.Orientation.Horizontal ? size.Height : size.Width;
            }
        }
    });

    Bridge.ns("System.Windows.Controls.StackPanel", $asm.$);

    Bridge.apply($asm.$.System.Windows.Controls.StackPanel, {
        f1: function (child) {
            return this.GetMainLength(child.DesiredSize);
        }
    });

    Bridge.define("System.Windows.Controls.WrapPanel", {
        inherits: [System.Windows.Controls.Panel],
        statics: {
            fields: {
                OrientationProperty: null
            },
            ctors: {
                init: function () {
                    this.OrientationProperty = System.Windows.DependencyProperty.Register("Orientation", System.Windows.Controls.Orientation, System.Windows.Controls.WrapPanel, new System.Windows.FrameworkPropertyMetadata.ctor());
                }
            }
        },
        props: {
            Orientation: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.WrapPanel.OrientationProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.WrapPanel.OrientationProperty, Bridge.box(value, System.Windows.Controls.Orientation, System.Enum.toStringFn(System.Windows.Controls.Orientation)));
                }
            }
        },
        methods: {
            MeasureOverride: function (availableSize) {
                var $t;
                if (!System.Linq.Enumerable.from(this.Children).any()) {
                    return System.Windows.Size.Zero;
                }

                $t = Bridge.getEnumerator(this.Children);
                try {
                    while ($t.moveNext()) {
                        var child = $t.Current;
                        this.MeasureChild(child, this.GetMainLength(availableSize), this.GetCrossLength(availableSize));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                var groups = this.GetElementGroups(availableSize);

                var mainLength = System.Linq.Enumerable.from(groups).select(Bridge.fn.bind(this, $asm.$.System.Windows.Controls.WrapPanel.f2)).max();
                var crossLength = System.Linq.Enumerable.from(groups).select(Bridge.fn.bind(this, $asm.$.System.Windows.Controls.WrapPanel.f4)).sum();

                return this.CreateSize(mainLength, crossLength);
            },
            ArrangeOverride: function (finalSize) {
                var $t, $t1;
                if (!System.Linq.Enumerable.from(this.Children).any()) {
                    return System.Windows.Size.Zero;
                }

                var groups = this.GetElementGroups(finalSize);

                var maxMainLength = 0;
                var totalCrossLength = 0;

                $t = Bridge.getEnumerator(groups, System.Collections.Generic.IEnumerable$1(System.Windows.UIElement));
                try {
                    while ($t.moveNext()) {
                        var group = $t.Current;
                        var groupMainLength = 0;
                        var groupMaxCrossLength = System.Linq.Enumerable.from(group).select(Bridge.fn.bind(this, $asm.$.System.Windows.Controls.WrapPanel.f5)).max();

                        $t1 = Bridge.getEnumerator(group, System.Windows.UIElement);
                        try {
                            while ($t1.moveNext()) {
                                var child = $t1.Current;
                                var childMainLength = this.GetMainLength(child.DesiredSize);

                                this.ArrangeChild(child, groupMainLength, totalCrossLength, childMainLength, groupMaxCrossLength);

                                groupMainLength += childMainLength;
                            }
                        } finally {
                            if (Bridge.is($t1, System.IDisposable)) {
                                $t1.System$IDisposable$dispose();
                            }
                        }
                        maxMainLength = Math.max(maxMainLength, groupMainLength);
                        totalCrossLength += groupMaxCrossLength;
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                return this.CreateSize(maxMainLength, totalCrossLength);
            },
            GetElementGroups: function (size) {
                var $t;
                var mainLength = this.GetMainLength(size);

                var groups = new (System.Collections.Generic.List$1(System.Collections.Generic.IEnumerable$1(System.Windows.UIElement))).ctor();

                var currentGroup = new (System.Collections.Generic.List$1(System.Windows.UIElement)).ctor();
                var currentGroupMainLength = 0;

                $t = Bridge.getEnumerator(this.Children);
                try {
                    while ($t.moveNext()) {
                        var child = $t.Current;
                        var childMainLength = this.GetMainLength(child.DesiredSize);

                        if (currentGroupMainLength > 0 && currentGroupMainLength + childMainLength > mainLength) {
                            groups.add(currentGroup);

                            // start a new group
                            currentGroup = new (System.Collections.Generic.List$1(System.Windows.UIElement)).ctor();
                            currentGroupMainLength = 0;
                        }

                        currentGroupMainLength += childMainLength;
                        currentGroup.add(child);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }
                groups.add(currentGroup);
                return groups;
            },
            MeasureChild: function (child, availableMainLength, availableCrossLength) {
                child.Measure(this.Orientation === System.Windows.Controls.Orientation.Horizontal ? new System.Windows.Size(availableMainLength, availableCrossLength) : new System.Windows.Size(availableCrossLength, availableMainLength));
            },
            ArrangeChild: function (child, finalMainStart, finalCrossStart, finalMainLength, finalCrossLength) {
                child.Arrange(this.Orientation === System.Windows.Controls.Orientation.Horizontal ? new System.Windows.Rect.$ctor1(finalMainStart, finalCrossStart, finalMainLength, finalCrossLength) : new System.Windows.Rect.$ctor1(finalCrossStart, finalMainStart, finalCrossLength, finalMainLength));
            },
            CreateSize: function (mainLength, crossLength) {
                if (this.Orientation === System.Windows.Controls.Orientation.Horizontal) {
                    return new System.Windows.Size(mainLength, crossLength);
                }

                return new System.Windows.Size(crossLength, mainLength);
            },
            GetMainLength: function (size) {
                return this.Orientation === System.Windows.Controls.Orientation.Horizontal ? size.Width : size.Height;
            },
            GetCrossLength: function (size) {
                return this.Orientation === System.Windows.Controls.Orientation.Horizontal ? size.Height : size.Width;
            }
        }
    });

    Bridge.ns("System.Windows.Controls.WrapPanel", $asm.$);

    Bridge.apply($asm.$.System.Windows.Controls.WrapPanel, {
        f1: function (child1) {
            return this.GetMainLength(child1.DesiredSize);
        },
        f2: function (group) {
            return System.Linq.Enumerable.from(group).select(Bridge.fn.bind(this, $asm.$.System.Windows.Controls.WrapPanel.f1)).sum();
        },
        f3: function (child1) {
            return this.GetCrossLength(child1.DesiredSize);
        },
        f4: function (group) {
            return System.Linq.Enumerable.from(group).select(Bridge.fn.bind(this, $asm.$.System.Windows.Controls.WrapPanel.f3)).max();
        },
        f5: function (child) {
            return this.GetCrossLength(child.DesiredSize);
        }
    });

    Bridge.define("System.Windows.Documents.Paragraph", {
        inherits: [System.Windows.Documents.Block],
        props: {
            Inlines: null
        }
    });

    Bridge.define("System.Windows.Documents.Run", {
        inherits: [System.Windows.Documents.Inline],
        statics: {
            fields: {
                TextProperty: null
            },
            ctors: {
                init: function () {
                    this.TextProperty = System.Windows.DependencyProperty.Register("Text", System.String, System.Windows.Documents.Run, new System.Windows.FrameworkPropertyMetadata.ctor());
                }
            }
        },
        props: {
            Text: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Documents.Run.TextProperty), System.String);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Documents.Run.TextProperty, value);
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Documents.Inline.ctor.call(this);
                //
            },
            $ctor1: function (text) {
                this.$initialize();
                System.Windows.Documents.Inline.ctor.call(this);
                this.Text = text;
            }
        },
        methods: {
            GetRenderElement: function (factory) {
                return null;
            },
            RemoveRenderElement: function (factory) {
                //
            }
        }
    });

    Bridge.define("System.Windows.Media.Color", {
        statics: {
            methods: {
                FromArgb: function (a, r, g, b) {
                    return new System.Windows.Media.Color(a, r, g, b);
                },
                FromRgb: function (r, g, b) {
                    return new System.Windows.Media.Color(255, r, g, b);
                },
                FromUInt32: function (argb) {
                    return new System.Windows.Media.Color((((((argb & 4278190080) >>> 0)) >>> 24) & 255), (((((argb & 16711680) >>> 0)) >>> 16) & 255), (((((argb & 65280) >>> 0)) >>> 8) & 255), ((((argb & 255) >>> 0)) & 255));
                },
                op_Equality: function (color1, color2) {
                    return Bridge.equals(color1, color2);
                },
                op_Inequality: function (color1, color2) {
                    return !(System.Windows.Media.Color.op_Equality(color1, color2));
                },
                op_Addition: function (color1, color2) {
                    return new System.Windows.Media.Color(((Granular.Extensions.IntExtensions.Bounds((((color1.A + color2.A) | 0)), 0, 255)) & 255), ((Granular.Extensions.IntExtensions.Bounds((((color1.R + color2.R) | 0)), 0, 255)) & 255), ((Granular.Extensions.IntExtensions.Bounds((((color1.G + color2.G) | 0)), 0, 255)) & 255), ((Granular.Extensions.IntExtensions.Bounds((((color1.B + color2.B) | 0)), 0, 255)) & 255));
                },
                op_Subtraction: function (color1, color2) {
                    return new System.Windows.Media.Color(((Granular.Extensions.IntExtensions.Bounds((((color1.A - color2.A) | 0)), 0, 255)) & 255), ((Granular.Extensions.IntExtensions.Bounds((((color1.R - color2.R) | 0)), 0, 255)) & 255), ((Granular.Extensions.IntExtensions.Bounds((((color1.G - color2.G) | 0)), 0, 255)) & 255), ((Granular.Extensions.IntExtensions.Bounds((((color1.B - color2.B) | 0)), 0, 255)) & 255));
                },
                op_Multiply$1: function (color, scalar) {
                    return new System.Windows.Media.Color(Bridge.Int.clipu8(Granular.Extensions.DoubleExtensions.Bounds((scalar * color.A), 0, 255)), Bridge.Int.clipu8(Granular.Extensions.DoubleExtensions.Bounds((scalar * color.R), 0, 255)), Bridge.Int.clipu8(Granular.Extensions.DoubleExtensions.Bounds((scalar * color.G), 0, 255)), Bridge.Int.clipu8(Granular.Extensions.DoubleExtensions.Bounds((scalar * color.B), 0, 255)));
                },
                op_Multiply: function (scalar, color) {
                    return System.Windows.Media.Color.op_Multiply$1(color, scalar);
                }
            }
        },
        fields: {
            hashCode: 0
        },
        props: {
            A: 0,
            R: 0,
            G: 0,
            B: 0
        },
        ctors: {
            ctor: function (a, r, g, b) {
                this.$initialize();
                this.A = a;
                this.R = r;
                this.G = g;
                this.B = b;

                this.hashCode = this.A ^ this.R ^ this.G ^ this.B;
            }
        },
        methods: {
            equals: function (obj) {
                var other = Bridge.as(obj, System.Windows.Media.Color);

                return Bridge.referenceEquals(this, other) || !Bridge.referenceEquals(other, null) && this.A === other.A && this.R === other.R && this.G === other.G && this.B === other.B;
            },
            getHashCode: function () {
                return this.hashCode;
            },
            toString: function () {
                return System.String.format("#{0:X2}{1:X2}{2:X2}{3:X2}", Bridge.box(this.A, System.Byte), Bridge.box(this.R, System.Byte), Bridge.box(this.G, System.Byte), Bridge.box(this.B, System.Byte));
            },
            IsClose: function (color) {
                return Math.abs(((this.A - color.A) | 0)) <= 1 && Math.abs(((this.R - color.R) | 0)) <= 1 && Math.abs(((this.G - color.G) | 0)) <= 1 && Math.abs(((this.B - color.B) | 0)) <= 1;
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.DoubleAnimation", {
        inherits: [System.Windows.Media.Animation.TransitionAnimationTimeline$1(System.Nullable$1(System.Double))],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Animation.TransitionAnimationTimeline$1(System.Nullable$1(System.Double)).ctor.call(this, System.Windows.Media.Animation.DoubleAnimationOperations.Default, true);
                //
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.DoubleAnimationUsingKeyFrames", {
        inherits: [System.Windows.Media.Animation.KeyFramesAnimationTimeline$1(System.Nullable$1(System.Double))],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Animation.KeyFramesAnimationTimeline$1(System.Nullable$1(System.Double)).ctor.call(this, System.Windows.Media.Animation.DoubleAnimationOperations.Default, true);
                //
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.RectAnimation", {
        inherits: [System.Windows.Media.Animation.TransitionAnimationTimeline$1(System.Windows.Rect)],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Animation.TransitionAnimationTimeline$1(System.Windows.Rect).ctor.call(this, System.Windows.Media.Animation.RectAnimationOperations.Default, true);
                //
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.RectAnimationUsingKeyFrames", {
        inherits: [System.Windows.Media.Animation.KeyFramesAnimationTimeline$1(System.Windows.Rect)],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Animation.KeyFramesAnimationTimeline$1(System.Windows.Rect).ctor.call(this, System.Windows.Media.Animation.RectAnimationOperations.Default, true);
                //
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.Storyboard", {
        inherits: [System.Windows.Media.Animation.ParallelTimeline],
        statics: {
            fields: {
                TargetNameProperty: null,
                TargetProperty: null,
                TargetPropertyProperty: null
            },
            ctors: {
                init: function () {
                    this.TargetNameProperty = System.Windows.DependencyProperty.RegisterAttached("TargetName", System.String, System.Windows.Media.Animation.Storyboard, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.TargetProperty = System.Windows.DependencyProperty.RegisterAttached("Target", System.Windows.DependencyObject, System.Windows.Media.Animation.Storyboard, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.TargetPropertyProperty = System.Windows.DependencyProperty.RegisterAttached("TargetProperty", System.Windows.PropertyPath, System.Windows.Media.Animation.Storyboard, new System.Windows.FrameworkPropertyMetadata.ctor());
                }
            },
            methods: {
                GetTargetName: function (obj) {
                    return Bridge.cast(obj.GetValue(System.Windows.Media.Animation.Storyboard.TargetNameProperty), System.String);
                },
                SetTargetName: function (obj, value) {
                    obj.SetValue(System.Windows.Media.Animation.Storyboard.TargetNameProperty, value);
                },
                GetTarget: function (obj) {
                    return Bridge.cast(obj.GetValue(System.Windows.Media.Animation.Storyboard.TargetProperty), System.Windows.DependencyObject);
                },
                SetTarget: function (obj, value) {
                    obj.SetValue(System.Windows.Media.Animation.Storyboard.TargetProperty, value);
                },
                GetTargetProperty: function (obj) {
                    return Bridge.cast(obj.GetValue(System.Windows.Media.Animation.Storyboard.TargetPropertyProperty), System.Windows.PropertyPath);
                },
                SetTargetProperty: function (obj, value) {
                    obj.SetValue(System.Windows.Media.Animation.Storyboard.TargetPropertyProperty, value);
                },
                TryGetPropertyPathTarget: function (root, propertyPath, target, targetProperty) {
                    var baseValue = { };
                    target.v = System.Linq.Enumerable.from(propertyPath.Elements).count() > 1 && System.Windows.PropertyPathExtensions.TryGetValue(System.Windows.PropertyPathExtensions.GetBasePropertyPath(propertyPath), root, baseValue) ? Bridge.as(baseValue.v, System.Windows.DependencyObject) : root;

                    if (target.v != null && !propertyPath.IsEmpty) {
                        return System.Linq.Enumerable.from(propertyPath.Elements).last().System$Windows$IPropertyPathElement$TryGetDependencyProperty(Bridge.getType(target.v), targetProperty);
                    }

                    target.v = null;
                    targetProperty.v = null;
                    return false;
                }
            }
        },
        fields: {
            clocks: null
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Animation.ParallelTimeline.ctor.call(this);
                this.clocks = new (System.Collections.Generic.Dictionary$2(System.Windows.FrameworkElement,System.Windows.Media.Animation.TimelineClock))();
            }
        },
        methods: {
            Begin: function (containingObject, nameScope, handoffBehavior, layerOwner) {
                var $t;
                if (nameScope === void 0) { nameScope = null; }
                if (handoffBehavior === void 0) { handoffBehavior = 0; }
                if (layerOwner === void 0) { layerOwner = null; }
                this.Stop(containingObject);

                var clock = this.CreateClock();
                clock.Begin(Bridge.cast(containingObject, System.Windows.Media.Animation.IAnimatable).System$Windows$Media$Animation$IAnimatable$RootClock);

                this.clocks.set(containingObject, clock);

                var targets = this.GetAnimationClocksTargets(clock, containingObject, nameScope || System.Windows.NameScope.GetContainingNameScope(containingObject));
                $t = Bridge.getEnumerator(Granular.Collections.IListDictionaryExtensions.GetKeys(Bridge.global.System.Windows.Media.Animation.Storyboard.TargetKey, Bridge.global.System.Windows.Media.Animation.AnimationTimelineClock, targets), System.Windows.Media.Animation.Storyboard.TargetKey);
                try {
                    while ($t.moveNext()) {
                        var target = $t.Current;
                        System.Windows.Media.Animation.AnimatableExtensions.ApplyAnimationClocks(target.Target, target.TargetProperty, targets.getValues(target), handoffBehavior, layerOwner);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$dispose();
                    }
                }},
            Remove: function (containingObject, nameScope, layerOwner) {
                var $t;
                if (nameScope === void 0) { nameScope = null; }
                if (layerOwner === void 0) { layerOwner = null; }
                this.Stop(containingObject);

                var clock = { };
                if (this.clocks.tryGetValue(containingObject, clock)) {
                    var targets = this.GetAnimationClocksTargets(clock.v, containingObject, nameScope || System.Windows.NameScope.GetContainingNameScope(containingObject));
                    $t = Bridge.getEnumerator(Granular.Collections.IListDictionaryExtensions.GetKeys(Bridge.global.System.Windows.Media.Animation.Storyboard.TargetKey, Bridge.global.System.Windows.Media.Animation.AnimationTimelineClock, targets), System.Windows.Media.Animation.Storyboard.TargetKey);
                    try {
                        while ($t.moveNext()) {
                            var target = $t.Current;
                            target.Target.System$Windows$Media$Animation$IAnimatable$RemoveAnimationClocks(target.TargetProperty, targets.getValues(target), layerOwner);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$dispose();
                        }
                    }this.clocks.remove(containingObject);
                }
            },
            Pause: function (containingObject) {
                var clock = { };
                if (this.clocks.tryGetValue(containingObject, clock)) {
                    clock.v.Pause();
                }
            },
            Resume: function (containingObject) {
                var clock = { };
                if (this.clocks.tryGetValue(containingObject, clock)) {
                    clock.v.Resume();
                }
            },
            Seek: function (containingObject, time) {
                var clock = { };
                if (this.clocks.tryGetValue(containingObject, clock)) {
                    clock.v.Seek(time);
                }
            },
            SeekOffset: function (containingObject, offset) {
                var clock = { };
                if (this.clocks.tryGetValue(containingObject, clock)) {
                    clock.v.SeekOffset(offset);
                }
            },
            SkipToFill: function (containingObject) {
                var clock = { };
                if (this.clocks.tryGetValue(containingObject, clock)) {
                    clock.v.SkipToFill();
                }
            },
            Stop: function (containingObject) {
                var clock = { };
                if (this.clocks.tryGetValue(containingObject, clock)) {
                    clock.v.Stop();
                }
            },
            GetAnimationClocksTargets: function (clock, containingObject, nameScope) {
                var targets = { v : new (Granular.Collections.ListDictionary$2(System.Windows.Media.Animation.Storyboard.TargetKey,System.Windows.Media.Animation.AnimationTimelineClock))() };
                this.GetAnimationClocksTargets$1(clock, containingObject, nameScope, targets);
                return targets.v;
            },
            GetAnimationClocksTargets$1: function (clock, containingObject, nameScope, targets) {
                var $t;
                var animationClock = Bridge.as(clock, System.Windows.Media.Animation.AnimationTimelineClock);
                if (animationClock != null) {
                    var target = this.GetClockTarget(animationClock, containingObject, nameScope);
                    if (target != null) {
                        targets.v.add(target, animationClock);
                    }
                }

                var clockGroup = Bridge.as(clock, System.Windows.Media.Animation.TimelineGroupClock);
                if (clockGroup != null) {
                    $t = Bridge.getEnumerator(clockGroup.Children, System.Windows.Media.Animation.TimelineClock);
                    try {
                        while ($t.moveNext()) {
                            var child = $t.Current;
                            this.GetAnimationClocksTargets$1(child, containingObject, nameScope, targets);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$dispose();
                        }
                    }}
            },
            GetClockTarget: function (clock, containingObject, nameScope) {
                var root = System.Windows.Media.Animation.Storyboard.GetTarget(clock.Timeline);

                if (root == null) {
                    var targetName = System.Windows.Media.Animation.Storyboard.GetTargetName(clock.Timeline);

                    if (Granular.Extensions.StringExtensions.IsNullOrEmpty(targetName)) {
                        root = containingObject;
                    } else {
                        root = Bridge.as(nameScope.System$Windows$INameScope$findName(targetName), System.Windows.DependencyObject);

                        if (root == null) {
                            throw new Granular.Exception("Can't find Storyboard.TargetName \"{0}\" for element \"{1}\"", [targetName, containingObject]);
                        }
                    }
                }

                var propertyPath = System.Windows.Media.Animation.Storyboard.GetTargetProperty(clock.Timeline);

                var target = { };
                var targetProperty = { };
                return System.Windows.Media.Animation.Storyboard.TryGetPropertyPathTarget(root, propertyPath, target, targetProperty) && Bridge.is(target.v, System.Windows.Media.Animation.IAnimatable) ? new System.Windows.Media.Animation.Storyboard.TargetKey(Bridge.cast(target.v, System.Windows.Media.Animation.IAnimatable), targetProperty.v) : null;
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.ThicknessAnimation", {
        inherits: [System.Windows.Media.Animation.TransitionAnimationTimeline$1(System.Windows.Thickness)],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Animation.TransitionAnimationTimeline$1(System.Windows.Thickness).ctor.call(this, System.Windows.Media.Animation.ThicknessAnimationOperations.Default, true);
                //
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.ThicknessAnimationUsingKeyFrames", {
        inherits: [System.Windows.Media.Animation.KeyFramesAnimationTimeline$1(System.Windows.Thickness)],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Animation.KeyFramesAnimationTimeline$1(System.Windows.Thickness).ctor.call(this, System.Windows.Media.Animation.ThicknessAnimationOperations.Default, true);
                //
            }
        }
    });

    Bridge.define("System.Windows.Media.ImageBrush", {
        inherits: [System.Windows.Media.TileBrush],
        statics: {
            fields: {
                ImageSourceProperty: null
            },
            ctors: {
                init: function () {
                    this.ImageSourceProperty = System.Windows.DependencyProperty.Register("ImageSource", System.Windows.Media.ImageSource, System.Windows.Media.ImageBrush, new System.Windows.FrameworkPropertyMetadata.$ctor6(null, $asm.$.System.Windows.Media.ImageBrush.f1));
                }
            }
        },
        fields: {
            renderResource$2: null
        },
        props: {
            ImageSource: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Media.ImageBrush.ImageSourceProperty), System.Windows.Media.ImageSource);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.ImageBrush.ImageSourceProperty, value);
                }
            }
        },
        methods: {
            CreateRenderResource: function (factory) {
                return factory.System$Windows$Media$IRenderElementFactory$CreateImageBrushRenderResource();
            },
            OnRenderResourceCreated: function (renderResource) {
                System.Windows.Media.TileBrush.prototype.OnRenderResourceCreated.call(this, renderResource);

                this.renderResource$2 = Bridge.cast(renderResource, System.Windows.Media.IImageBrushRenderResource);
                this.renderResource$2.System$Windows$Media$IImageBrushRenderResource$ImageSource = this.ImageSource;
            },
            OnImageSourceChanged: function (e) {
                this.renderResource$2.System$Windows$Media$IImageBrushRenderResource$ImageSource = this.ImageSource;
            }
        }
    });

    Bridge.ns("System.Windows.Media.ImageBrush", $asm.$);

    Bridge.apply($asm.$.System.Windows.Media.ImageBrush, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Media.ImageBrush).OnImageSourceChanged(e);
        }
    });

    Bridge.define("System.Windows.Media.Imaging.BitmapImage", {
        inherits: [System.Windows.Media.Imaging.BitmapSource,System.Windows.Markup.IUriContext,System.Windows.Markup.ISupportInitialize],
        statics: {
            fields: {
                UriSourceProperty: null,
                SourceRectProperty: null
            },
            ctors: {
                init: function () {
                    this.UriSourceProperty = System.Windows.DependencyProperty.Register("UriSource", System.Uri, System.Windows.Media.Imaging.BitmapImage, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Media.Imaging.BitmapImage.f1));
                    this.SourceRectProperty = System.Windows.DependencyProperty.Register("SourceRect", System.Windows.Rect, System.Windows.Media.Imaging.BitmapImage, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Media.Imaging.BitmapImage.f2));
                }
            }
        },
        fields: {
            renderResource$2: null,
            isInitialized: false
        },
        props: {
            UriSource: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Media.Imaging.BitmapImage.UriSourceProperty), System.Uri);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Imaging.BitmapImage.UriSourceProperty, value);
                }
            },
            SourceRect: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Media.Imaging.BitmapImage.SourceRectProperty), System.Windows.Rect);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.Imaging.BitmapImage.SourceRectProperty, value);
                }
            },
            BaseUri: null
        },
        alias: [
            "BaseUri", "System$Windows$Markup$IUriContext$BaseUri",
            "BeginInit", "System$Windows$Markup$ISupportInitialize$BeginInit",
            "EndInit", "System$Windows$Markup$ISupportInitialize$EndInit"
        ],
        methods: {
            BeginInit: function () {
                //
            },
            EndInit: function () {
                //
            },
            CreateRenderResource: function (factory) {
                return factory.System$Windows$Media$IRenderElementFactory$CreateImageSourceRenderResource();
            },
            OnRenderResourceCreated: function (renderResource) {
                System.Windows.Media.Imaging.BitmapSource.prototype.OnRenderResourceCreated.call(this, renderResource);

                this.renderResource$2 = Bridge.cast(renderResource, System.Windows.Media.IImageSourceRenderResource);
                this.InitializeRenderResource();
            },
            InitializeRenderResource: function () {
                if (this.isInitialized || this.renderResource$2 == null || this.UriSource == null) {
                    return;
                }

                this.renderResource$2.System$Windows$Media$IImageSourceRenderResource$Initialize(System.UriExtensions.ResolveAbsoluteUri(this.UriSource, this.BaseUri), this.SourceRect);
                this.isInitialized = true;
            },
            OnUriSourceChanged: function (e) {
                if (this.isInitialized) {
                    throw new Granular.Exception("UriSource cannot be changed after BitmapImage was initialized");
                }

                this.InitializeRenderResource();
            },
            OnSourceRectChanged: function (e) {
                if (this.isInitialized) {
                    throw new Granular.Exception("SourceRect cannot be changed after BitmapImage was initialized");
                }

                this.InitializeRenderResource();
            }
        }
    });

    Bridge.ns("System.Windows.Media.Imaging.BitmapImage", $asm.$);

    Bridge.apply($asm.$.System.Windows.Media.Imaging.BitmapImage, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Media.Imaging.BitmapImage).OnUriSourceChanged(e);
        },
        f2: function (sender, e) {
            Bridge.cast(sender, System.Windows.Media.Imaging.BitmapImage).OnSourceRectChanged(e);
        }
    });

    Bridge.define("System.Windows.Media.LinearGradientBrush", {
        inherits: [System.Windows.Media.GradientBrush],
        statics: {
            fields: {
                StartPointProperty: null,
                EndPointProperty: null
            },
            ctors: {
                init: function () {
                    this.StartPointProperty = System.Windows.DependencyProperty.Register("StartPoint", System.Windows.Point, System.Windows.Media.LinearGradientBrush, new System.Windows.FrameworkPropertyMetadata.$ctor6(System.Windows.Point.Zero, $asm.$.System.Windows.Media.LinearGradientBrush.f1));
                    this.EndPointProperty = System.Windows.DependencyProperty.Register("EndPoint", System.Windows.Point, System.Windows.Media.LinearGradientBrush, new System.Windows.FrameworkPropertyMetadata.$ctor6(new System.Windows.Point.$ctor1(1, 1), $asm.$.System.Windows.Media.LinearGradientBrush.f2));
                }
            },
            methods: {
                GetStartPoint: function (angle) {
                    var startPoint = { };
                    var endPoint = { };

                    System.Windows.Media.LinearGradientBrush.GetPoints(angle, startPoint, endPoint);

                    return startPoint.v;
                },
                GetEndPoint: function (angle) {
                    var startPoint = { };
                    var endPoint = { };

                    System.Windows.Media.LinearGradientBrush.GetPoints(angle, startPoint, endPoint);

                    return endPoint.v;
                },
                GetPoints: function (angle, startPoint, endPoint) {
                    var radians = Math.PI * angle / 180;
                    var x = Math.cos(radians);
                    var y = Math.sin(radians);

                    var scale = 1 / Granular.Extensions.DoubleExtensions.Max(Granular.Extensions.DoubleExtensions.Abs(x), Granular.Extensions.DoubleExtensions.Abs(y));
                    x *= scale;
                    y *= scale;

                    var offset = new System.Windows.Point.$ctor1(Granular.Extensions.DoubleExtensions.Min(x, 0), Granular.Extensions.DoubleExtensions.Min(y, 0));

                    startPoint.v = System.Windows.Point.op_UnaryNegation(offset);
                    endPoint.v = System.Windows.Point.op_Subtraction(new System.Windows.Point.$ctor1(x, y), offset);
                }
            }
        },
        fields: {
            renderResource$2: null
        },
        props: {
            StartPoint: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Media.LinearGradientBrush.StartPointProperty), System.Windows.Point);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.LinearGradientBrush.StartPointProperty, value);
                }
            },
            EndPoint: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Media.LinearGradientBrush.EndPointProperty), System.Windows.Point);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.LinearGradientBrush.EndPointProperty, value);
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.GradientBrush.ctor.call(this);
                //
            },
            $ctor2: function (angle, startColor, endColor) {
                System.Windows.Media.LinearGradientBrush.$ctor3.call(this, System.Windows.Media.LinearGradientBrush.GetStartPoint(angle), System.Windows.Media.LinearGradientBrush.GetEndPoint(angle), System.Array.init([new System.Windows.Media.GradientStop.$ctor1(startColor, 0), new System.Windows.Media.GradientStop.$ctor1(endColor, 1)], System.Windows.Media.GradientStop));
                //
            },
            $ctor1: function (angle, gradientStops) {
                System.Windows.Media.LinearGradientBrush.$ctor3.call(this, System.Windows.Media.LinearGradientBrush.GetStartPoint(angle), System.Windows.Media.LinearGradientBrush.GetEndPoint(angle), gradientStops);
                //
            },
            $ctor4: function (startPoint, endPoint, startColor, endColor) {
                System.Windows.Media.LinearGradientBrush.$ctor3.call(this, startPoint, endPoint, System.Array.init([new System.Windows.Media.GradientStop.$ctor1(startColor, 0), new System.Windows.Media.GradientStop.$ctor1(endColor, 1)], System.Windows.Media.GradientStop));
                //
            },
            $ctor3: function (startPoint, endPoint, gradientStops) {
                this.$initialize();
                System.Windows.Media.GradientBrush.$ctor1.call(this, gradientStops);
                this.StartPoint = startPoint;
                this.EndPoint = endPoint;
            }
        },
        methods: {
            CreateRenderResource: function (factory) {
                return factory.System$Windows$Media$IRenderElementFactory$CreateLinearGradientBrushRenderResource();
            },
            OnRenderResourceCreated: function (renderResource) {
                System.Windows.Media.GradientBrush.prototype.OnRenderResourceCreated.call(this, renderResource);

                this.renderResource$2 = Bridge.cast(renderResource, System.Windows.Media.ILinearGradientBrushRenderResource);
                this.renderResource$2.System$Windows$Media$ILinearGradientBrushRenderResource$StartPoint = this.StartPoint;
                this.renderResource$2.System$Windows$Media$ILinearGradientBrushRenderResource$EndPoint = this.EndPoint;
            },
            OnStartPointChanged: function (e) {
                if (this.renderResource$2 != null) {
                    this.renderResource$2.System$Windows$Media$ILinearGradientBrushRenderResource$StartPoint = this.StartPoint;
                }
            },
            OnEndPointChanged: function (e) {
                if (this.renderResource$2 != null) {
                    this.renderResource$2.System$Windows$Media$ILinearGradientBrushRenderResource$EndPoint = this.EndPoint;
                }
            }
        }
    });

    Bridge.ns("System.Windows.Media.LinearGradientBrush", $asm.$);

    Bridge.apply($asm.$.System.Windows.Media.LinearGradientBrush, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Media.LinearGradientBrush).OnStartPointChanged(e);
        },
        f2: function (sender, e) {
            Bridge.cast(sender, System.Windows.Media.LinearGradientBrush).OnEndPointChanged(e);
        }
    });

    Bridge.define("System.Windows.Media.RadialGradientBrush", {
        inherits: [System.Windows.Media.GradientBrush],
        statics: {
            fields: {
                CenterProperty: null,
                GradientOriginProperty: null,
                RadiusXProperty: null,
                RadiusYProperty: null
            },
            ctors: {
                init: function () {
                    this.CenterProperty = System.Windows.DependencyProperty.Register("Center", System.Windows.Point, System.Windows.Media.RadialGradientBrush, new System.Windows.FrameworkPropertyMetadata.$ctor6(new System.Windows.Point.$ctor1(0.5, 0.5), $asm.$.System.Windows.Media.RadialGradientBrush.f1));
                    this.GradientOriginProperty = System.Windows.DependencyProperty.Register("GradientOrigin", System.Windows.Point, System.Windows.Media.RadialGradientBrush, new System.Windows.FrameworkPropertyMetadata.$ctor6(new System.Windows.Point.$ctor1(0.5, 0.5), $asm.$.System.Windows.Media.RadialGradientBrush.f2));
                    this.RadiusXProperty = System.Windows.DependencyProperty.Register("RadiusX", System.Double, System.Windows.Media.RadialGradientBrush, new System.Windows.FrameworkPropertyMetadata.$ctor6(Bridge.box(0.5, System.Double, System.Double.format, System.Double.getHashCode), $asm.$.System.Windows.Media.RadialGradientBrush.f3));
                    this.RadiusYProperty = System.Windows.DependencyProperty.Register("RadiusY", System.Double, System.Windows.Media.RadialGradientBrush, new System.Windows.FrameworkPropertyMetadata.$ctor6(Bridge.box(0.5, System.Double, System.Double.format, System.Double.getHashCode), $asm.$.System.Windows.Media.RadialGradientBrush.f4));
                }
            }
        },
        fields: {
            renderResource$2: null
        },
        props: {
            Center: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Media.RadialGradientBrush.CenterProperty), System.Windows.Point);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.RadialGradientBrush.CenterProperty, value);
                }
            },
            GradientOrigin: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Media.RadialGradientBrush.GradientOriginProperty), System.Windows.Point);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.RadialGradientBrush.GradientOriginProperty, value);
                }
            },
            RadiusX: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.RadialGradientBrush.RadiusXProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.RadialGradientBrush.RadiusXProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            RadiusY: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Media.RadialGradientBrush.RadiusYProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Media.RadialGradientBrush.RadiusYProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.GradientBrush.ctor.call(this);
                //
            },
            $ctor2: function (startColor, endColor) {
                System.Windows.Media.RadialGradientBrush.$ctor1.call(this, System.Array.init([new System.Windows.Media.GradientStop.$ctor1(startColor, 0), new System.Windows.Media.GradientStop.$ctor1(endColor, 1)], System.Windows.Media.GradientStop));
                //
            },
            $ctor1: function (gradientStops) {
                this.$initialize();
                System.Windows.Media.GradientBrush.$ctor1.call(this, gradientStops);
                //
            }
        },
        methods: {
            CreateRenderResource: function (factory) {
                return factory.System$Windows$Media$IRenderElementFactory$CreateRadialGradientBrushRenderResource();
            },
            OnRenderResourceCreated: function (renderResource) {
                System.Windows.Media.GradientBrush.prototype.OnRenderResourceCreated.call(this, renderResource);

                this.renderResource$2 = Bridge.cast(renderResource, System.Windows.Media.IRadialGradientBrushRenderResource);
                this.renderResource$2.System$Windows$Media$IRadialGradientBrushRenderResource$Center = this.Center;
                this.renderResource$2.System$Windows$Media$IRadialGradientBrushRenderResource$GradientOrigin = this.GradientOrigin;
                this.renderResource$2.System$Windows$Media$IRadialGradientBrushRenderResource$RadiusX = this.RadiusX;
                this.renderResource$2.System$Windows$Media$IRadialGradientBrushRenderResource$RadiusY = this.RadiusY;
            },
            OnCenterChanged: function (e) {
                if (this.renderResource$2 != null) {
                    this.renderResource$2.System$Windows$Media$IRadialGradientBrushRenderResource$Center = this.Center;
                }
            },
            OnGradientOriginChanged: function (e) {
                if (this.renderResource$2 != null) {
                    this.renderResource$2.System$Windows$Media$IRadialGradientBrushRenderResource$GradientOrigin = this.GradientOrigin;
                }
            },
            OnRadiusXChanged: function (e) {
                if (this.renderResource$2 != null) {
                    this.renderResource$2.System$Windows$Media$IRadialGradientBrushRenderResource$RadiusX = this.RadiusX;
                }
            },
            OnRadiusYChanged: function (e) {
                if (this.renderResource$2 != null) {
                    this.renderResource$2.System$Windows$Media$IRadialGradientBrushRenderResource$RadiusY = this.RadiusY;
                }
            }
        }
    });

    Bridge.ns("System.Windows.Media.RadialGradientBrush", $asm.$);

    Bridge.apply($asm.$.System.Windows.Media.RadialGradientBrush, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Media.RadialGradientBrush).OnCenterChanged(e);
        },
        f2: function (sender, e) {
            Bridge.cast(sender, System.Windows.Media.RadialGradientBrush).OnGradientOriginChanged(e);
        },
        f3: function (sender, e) {
            Bridge.cast(sender, System.Windows.Media.RadialGradientBrush).OnRadiusXChanged(e);
        },
        f4: function (sender, e) {
            Bridge.cast(sender, System.Windows.Media.RadialGradientBrush).OnRadiusYChanged(e);
        }
    });

    Bridge.define("System.Windows.MultiDataTrigger", {
        inherits: [System.Windows.MultiDataTriggerBase],
        alias: ["CreateDataTriggerCondition", "System$Windows$IDataTriggerConditionProvider$CreateDataTriggerCondition"],
        methods: {
            CreateDataTriggerCondition: function (element) {
                return System.Windows.MultiDataTriggerCondition.Register(element, System.Linq.Enumerable.from(this.Conditions).select($asm.$.System.Windows.MultiDataTrigger.f1).toArray(System.Windows.MultiDataTrigger.MultiDataTriggerConditionProvider));
            }
        }
    });

    Bridge.ns("System.Windows.MultiDataTrigger", $asm.$);

    Bridge.apply($asm.$.System.Windows.MultiDataTrigger, {
        f1: function (condition) {
            return new System.Windows.MultiDataTrigger.MultiDataTriggerConditionProvider(condition);
        }
    });

    Bridge.define("System.Windows.MultiTrigger", {
        inherits: [System.Windows.MultiDataTriggerBase],
        alias: ["CreateDataTriggerCondition", "System$Windows$IDataTriggerConditionProvider$CreateDataTriggerCondition"],
        methods: {
            CreateDataTriggerCondition: function (element) {
                return System.Windows.MultiDataTriggerCondition.Register(element, System.Linq.Enumerable.from(this.Conditions).select($asm.$.System.Windows.MultiTrigger.f1).toArray(System.Windows.MultiTrigger.TriggerConditionProvider));
            }
        }
    });

    Bridge.ns("System.Windows.MultiTrigger", $asm.$);

    Bridge.apply($asm.$.System.Windows.MultiTrigger, {
        f1: function (condition) {
            return new System.Windows.MultiTrigger.TriggerConditionProvider(condition);
        }
    });

    Bridge.define("System.Windows.Shapes.Ellipse", {
        inherits: [System.Windows.Shapes.Shape],
        fields: {
            definingGeometry: null
        },
        props: {
            DefiningGeometry: {
                get: function () {
                    if (this.definingGeometry == null) {
                        this.definingGeometry = new System.Windows.Media.EllipseGeometry.$ctor1(new System.Windows.Point.$ctor1(this.RenderSize.Width / 2, this.RenderSize.Height / 2), this.RenderSize.Width / 2 - this.StrokeThickness / 2, this.RenderSize.Height / 2 - this.StrokeThickness / 2);
                    }

                    return this.definingGeometry;
                }
            }
        },
        methods: {
            ArrangeOverride: function (finalSize) {
                this.InvalidateDefiningGeometry();
                return System.Windows.Shapes.Shape.prototype.ArrangeOverride.call(this, finalSize);
            },
            InvalidateDefiningGeometry: function () {
                this.definingGeometry = null;
                this.InvalidateVisual();
            }
        }
    });

    Bridge.define("System.Windows.Shapes.Line", {
        inherits: [System.Windows.Shapes.Shape],
        statics: {
            fields: {
                X1Property: null,
                Y1Property: null,
                X2Property: null,
                Y2Property: null
            },
            ctors: {
                init: function () {
                    this.X1Property = System.Windows.DependencyProperty.Register("X1", System.Double, System.Windows.Shapes.Line, new System.Windows.FrameworkPropertyMetadata.$ctor9(0.0, $asm.$.System.Windows.Shapes.Line.f1));
                    this.Y1Property = System.Windows.DependencyProperty.Register("Y1", System.Double, System.Windows.Shapes.Line, new System.Windows.FrameworkPropertyMetadata.$ctor9(0.0, $asm.$.System.Windows.Shapes.Line.f1));
                    this.X2Property = System.Windows.DependencyProperty.Register("X2", System.Double, System.Windows.Shapes.Line, new System.Windows.FrameworkPropertyMetadata.$ctor9(0.0, $asm.$.System.Windows.Shapes.Line.f1));
                    this.Y2Property = System.Windows.DependencyProperty.Register("Y2", System.Double, System.Windows.Shapes.Line, new System.Windows.FrameworkPropertyMetadata.$ctor9(0.0, $asm.$.System.Windows.Shapes.Line.f1));
                }
            }
        },
        fields: {
            definingGeometry: null
        },
        props: {
            X1: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Shapes.Line.X1Property)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Shapes.Line.X1Property, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            Y1: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Shapes.Line.Y1Property)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Shapes.Line.Y1Property, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            X2: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Shapes.Line.X2Property)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Shapes.Line.X2Property, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            Y2: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Shapes.Line.Y2Property)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Shapes.Line.Y2Property, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            DefiningGeometry: {
                get: function () {
                    if (this.definingGeometry == null) {
                        this.definingGeometry = new System.Windows.Media.LineGeometry.$ctor1(new System.Windows.Point.$ctor1(this.X1, this.Y1), new System.Windows.Point.$ctor1(this.X2, this.Y2));
                    }

                    return this.definingGeometry;
                }
            }
        },
        methods: {
            InvalidateDefiningGeometry: function () {
                this.definingGeometry = null;
                this.InvalidateVisual();
            }
        }
    });

    Bridge.ns("System.Windows.Shapes.Line", $asm.$);

    Bridge.apply($asm.$.System.Windows.Shapes.Line, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Shapes.Line).InvalidateDefiningGeometry();
        }
    });

    Bridge.define("System.Windows.Shapes.Path", {
        inherits: [System.Windows.Shapes.Shape],
        statics: {
            fields: {
                DataProperty: null
            },
            ctors: {
                init: function () {
                    this.DataProperty = System.Windows.DependencyProperty.Register("Data", System.Windows.Media.Geometry, System.Windows.Shapes.Path, new System.Windows.FrameworkPropertyMetadata.$ctor2(null, System.Windows.FrameworkPropertyMetadataOptions.AffectsRender));
                }
            }
        },
        props: {
            Data: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Shapes.Path.DataProperty), System.Windows.Media.Geometry);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Shapes.Path.DataProperty, value);
                }
            },
            DefiningGeometry: {
                get: function () {
                    return this.Data;
                }
            }
        }
    });

    Bridge.define("System.Windows.Shapes.Rectangle", {
        inherits: [System.Windows.Shapes.Shape],
        statics: {
            fields: {
                RadiusXProperty: null,
                RadiusYProperty: null
            },
            ctors: {
                init: function () {
                    this.RadiusXProperty = System.Windows.DependencyProperty.Register("RadiusX", System.Double, System.Windows.Shapes.Rectangle, new System.Windows.FrameworkPropertyMetadata.$ctor9(0.0, $asm.$.System.Windows.Shapes.Rectangle.f1));
                    this.RadiusYProperty = System.Windows.DependencyProperty.Register("RadiusY", System.Double, System.Windows.Shapes.Rectangle, new System.Windows.FrameworkPropertyMetadata.$ctor9(0.0, $asm.$.System.Windows.Shapes.Rectangle.f1));
                }
            }
        },
        fields: {
            definingGeometry: null
        },
        props: {
            RadiusX: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Shapes.Rectangle.RadiusXProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Shapes.Rectangle.RadiusXProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            RadiusY: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Shapes.Rectangle.RadiusYProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Shapes.Rectangle.RadiusYProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            DefiningGeometry: {
                get: function () {
                    if (this.definingGeometry == null) {
                        this.definingGeometry = new System.Windows.Media.RectangleGeometry.$ctor2(new System.Windows.Rect.$ctor1(this.StrokeThickness / 2, this.StrokeThickness / 2, this.RenderSize.Width - this.StrokeThickness, this.RenderSize.Height - this.StrokeThickness), this.RadiusX, this.RadiusY);
                    }

                    return this.definingGeometry;
                }
            }
        },
        methods: {
            ArrangeOverride: function (finalSize) {
                this.InvalidateDefiningGeometry();
                return System.Windows.Shapes.Shape.prototype.ArrangeOverride.call(this, finalSize);
            },
            InvalidateDefiningGeometry: function () {
                this.definingGeometry = null;
                this.InvalidateVisual();
            }
        }
    });

    Bridge.ns("System.Windows.Shapes.Rectangle", $asm.$);

    Bridge.apply($asm.$.System.Windows.Shapes.Rectangle, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Shapes.Rectangle).InvalidateDefiningGeometry();
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.ButtonBase", {
        inherits: [System.Windows.Controls.ContentControl],
        statics: {
            fields: {
                ClickEvent: null,
                ClickModeProperty: null,
                IsPressedProperty: null,
                CommandProperty: null,
                CommandParameterProperty: null
            },
            ctors: {
                init: function () {
                    this.ClickEvent = System.Windows.EventManager.RegisterRoutedEvent("Click", System.Windows.RoutingStrategy.Bubble, Function, System.Windows.Controls.Primitives.ButtonBase);
                    this.ClickModeProperty = System.Windows.DependencyProperty.Register("ClickMode", System.Windows.Controls.ClickMode, System.Windows.Controls.Primitives.ButtonBase, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.IsPressedProperty = System.Windows.DependencyProperty.Register("IsPressed", System.Boolean, System.Windows.Controls.Primitives.ButtonBase, new System.Windows.FrameworkPropertyMetadata.$ctor3(Bridge.box(false, System.Boolean, System.Boolean.toString), System.Windows.FrameworkPropertyMetadataOptions.AffectsVisualState, $asm.$.System.Windows.Controls.Primitives.ButtonBase.f1));
                    this.CommandProperty = System.Windows.DependencyProperty.Register("Command", System.Windows.Input.ICommand, System.Windows.Controls.Primitives.ButtonBase, new System.Windows.FrameworkPropertyMetadata.$ctor6(null, $asm.$.System.Windows.Controls.Primitives.ButtonBase.f2));
                    this.CommandParameterProperty = System.Windows.DependencyProperty.Register("CommandParameterProperty", System.Object, System.Windows.Controls.Primitives.ButtonBase, new System.Windows.FrameworkPropertyMetadata.ctor());
                },
                ctor: function () {
                    System.Windows.EventManager.RegisterClassHandler(System.Windows.Controls.Primitives.ButtonBase, System.Windows.Controls.Primitives.ButtonBase.ClickEvent, $asm.$.System.Windows.Controls.Primitives.ButtonBase.f3, false);

                    System.Windows.UIElement.IsEnabledProperty.OverrideMetadata(System.Windows.Controls.Primitives.ButtonBase, new System.Windows.FrameworkPropertyMetadata.$ctor8(System.Windows.FrameworkPropertyMetadataOptions.AffectsVisualState));
                    System.Windows.UIElement.IsMouseOverProperty.OverrideMetadata(System.Windows.Controls.Primitives.ButtonBase, new System.Windows.FrameworkPropertyMetadata.$ctor8(System.Windows.FrameworkPropertyMetadataOptions.AffectsVisualState));
                    System.Windows.UIElement.IsFocusedProperty.OverrideMetadata(System.Windows.Controls.Primitives.ButtonBase, new System.Windows.FrameworkPropertyMetadata.$ctor8(System.Windows.FrameworkPropertyMetadataOptions.AffectsVisualState));
                }
            },
            methods: {
                IsVisualChild: function (parent, child) {
                    return child != null && (Bridge.referenceEquals(parent, child) || System.Windows.Controls.Primitives.ButtonBase.IsVisualChild(parent, child.VisualParent));
                }
            }
        },
        fields: {
            keyboardFocus: null
        },
        props: {
            ClickMode: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.ButtonBase.ClickModeProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.ButtonBase.ClickModeProperty, Bridge.box(value, System.Windows.Controls.ClickMode, System.Enum.toStringFn(System.Windows.Controls.ClickMode)));
                }
            },
            IsPressed: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.ButtonBase.IsPressedProperty)), System.Boolean));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.ButtonBase.IsPressedProperty, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            },
            Command: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.Primitives.ButtonBase.CommandProperty), System.Windows.Input.ICommand);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.ButtonBase.CommandProperty, value);
                }
            },
            CommandParameter: {
                get: function () {
                    return this.GetValue(System.Windows.Controls.Primitives.ButtonBase.CommandParameterProperty);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.ButtonBase.CommandParameterProperty, value);
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Controls.ContentControl.ctor.call(this);
                //
            }
        },
        methods: {
            addClick: function (value) {
                this.AddHandler(System.Windows.Controls.Primitives.ButtonBase.ClickEvent, value);
            },
            removeClick: function (value) {
                this.RemoveHandler(System.Windows.Controls.Primitives.ButtonBase.ClickEvent, value);
            },
            RaiseClick: function () {
                var e = new System.Windows.RoutedEventArgs(System.Windows.Controls.Primitives.ButtonBase.ClickEvent, this);
                this.RaiseEvent(e);
                return e.Handled;
            },
            OnClick: function (e) {
                var command = this.Command;
                if (command != null) {
                    command.System$Windows$Input$ICommand$Execute(this.CommandParameter);
                }
            },
            OnIsPressedChanged: function (e) {
                //
            },
            OnPressStarted: function () {
                //
            },
            OnPressEnded: function () {
                //
            },
            OnMouseDown: function (e) {
                if (e.ChangedButton === System.Windows.Input.MouseButton.Left) {
                    this.Focus();

                    this.IsPressed = true;
                    this.OnPressStarted();

                    e.MouseDevice.Capture(this);

                    if (this.ClickMode === System.Windows.Controls.ClickMode.Press) {
                        e.Handled = this.RaiseClick();
                    }
                }
            },
            OnMouseUp: function (e) {
                if (e.ChangedButton === System.Windows.Input.MouseButton.Left && Bridge.referenceEquals(e.MouseDevice.CaptureTarget, this)) {
                    this.IsPressed = false;
                    this.OnPressEnded();

                    e.MouseDevice.ReleaseCapture();

                    if (this.IsMouseOver && this.ClickMode === System.Windows.Controls.ClickMode.Release) {
                        e.Handled = this.RaiseClick();
                    }
                }
            },
            OnMouseMove: function (e) {
                if (Bridge.referenceEquals(e.MouseDevice.CaptureTarget, this)) {
                    this.IsPressed = Bridge.referenceEquals(e.MouseDevice.CaptureTarget, this) && System.Windows.Controls.Primitives.ButtonBase.IsVisualChild(this, Bridge.as(e.MouseDevice.HitTarget, System.Windows.Media.Visual));
                }
            },
            OnKeyDown: function (e) {
                if (e.Key === System.Windows.Input.Key.Space && !this.IsPressed) {
                    this.IsPressed = true;
                    this.OnPressStarted();

                    if (this.ClickMode === System.Windows.Controls.ClickMode.Press) {
                        e.Handled = this.RaiseClick();
                    }
                }
            },
            OnKeyUp: function (e) {
                if (e.Key === System.Windows.Input.Key.Space) {
                    this.IsPressed = false;
                    this.OnPressEnded();

                    if (this.ClickMode === System.Windows.Controls.ClickMode.Release) {
                        e.Handled = this.RaiseClick();
                    }
                }
            },
            OnGotFocus: function (e) {
                this.keyboardFocus = System.Windows.Input.Keyboard.Focus(this);
            },
            OnLostFocus: function (e) {
                if (this.keyboardFocus != null) {
                    this.keyboardFocus.System$IDisposable$dispose();
                    this.keyboardFocus = null;
                }
            },
            UpdateVisualState: function (useTransitions) {
                System.Windows.VisualStateManager.GoToState(this, this.GetCommonState(), useTransitions);
                System.Windows.VisualStateManager.GoToState(this, this.GetFocusState(), useTransitions);
            },
            GetCommonState: function () {
                if (!this.IsEnabled) {
                    return System.Windows.Controls.VisualStates.DisabledState;
                }

                if (this.IsPressed) {
                    return System.Windows.Controls.VisualStates.PressedState;
                }

                if (this.IsMouseOver) {
                    return System.Windows.Controls.VisualStates.MouseOverState;
                }

                return System.Windows.Controls.VisualStates.NormalState;
            },
            GetFocusState: function () {
                return this.IsFocused ? System.Windows.Controls.VisualStates.FocusedState : System.Windows.Controls.VisualStates.UnfocusedState;
            },
            OnCommandChanged: function (oldValue, newValue) {
                if (oldValue != null) {
                    oldValue.System$Windows$Input$ICommand$removeCanExecuteChanged(Bridge.fn.cacheBind(this, this.UpdateCommandStatus));
                }

                if (newValue != null) {
                    newValue.System$Windows$Input$ICommand$addCanExecuteChanged(Bridge.fn.cacheBind(this, this.UpdateCommandStatus));
                    this.UpdateCommandStatus(this, { });
                }
            },
            UpdateCommandStatus: function (sender, e) {
                this.IsEnabled = this.Command.System$Windows$Input$ICommand$CanExecute(this.CommandParameter);
            }
        }
    });

    Bridge.ns("System.Windows.Controls.Primitives.ButtonBase", $asm.$);

    Bridge.apply($asm.$.System.Windows.Controls.Primitives.ButtonBase, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.Primitives.ButtonBase).OnIsPressedChanged(e);
        },
        f2: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.Primitives.ButtonBase).OnCommandChanged(Bridge.cast(e.OldValue, System.Windows.Input.ICommand), Bridge.cast(e.NewValue, System.Windows.Input.ICommand));
        },
        f3: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.Primitives.ButtonBase).OnClick(e);
        }
    });

    Bridge.define("System.Windows.Controls.HeaderedContentControl", {
        inherits: [System.Windows.Controls.ContentControl],
        statics: {
            fields: {
                HeaderProperty: null,
                HeaderTemplateProperty: null,
                HeaderTemplateSelectorProperty: null,
                HasHeaderPropertyKey: null,
                HasHeaderProperty: null
            },
            ctors: {
                init: function () {
                    this.HeaderProperty = System.Windows.DependencyProperty.Register("Header", System.Object, System.Windows.Controls.HeaderedContentControl, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.HeaderedContentControl.f1));
                    this.HeaderTemplateProperty = System.Windows.DependencyProperty.Register("HeaderTemplate", System.Windows.DataTemplate, System.Windows.Controls.HeaderedContentControl, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.HeaderTemplateSelectorProperty = System.Windows.DependencyProperty.Register("HeaderTemplateSelector", System.Windows.Controls.IDataTemplateSelector, System.Windows.Controls.HeaderedContentControl, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.HasHeaderPropertyKey = System.Windows.DependencyProperty.RegisterReadOnly("HasHeader", System.Boolean, System.Windows.Controls.HeaderedContentControl, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.HasHeaderProperty = System.Windows.Controls.HeaderedContentControl.HasHeaderPropertyKey.DependencyProperty;
                }
            }
        },
        props: {
            Header: {
                get: function () {
                    return this.GetValue(System.Windows.Controls.HeaderedContentControl.HeaderProperty);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.HeaderedContentControl.HeaderProperty, value);
                }
            },
            HeaderTemplate: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.HeaderedContentControl.HeaderTemplateProperty), System.Windows.DataTemplate);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.HeaderedContentControl.HeaderTemplateProperty, value);
                }
            },
            HeaderTemplateSelector: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.HeaderedContentControl.HeaderTemplateSelectorProperty), System.Windows.Controls.IDataTemplateSelector);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.HeaderedContentControl.HeaderTemplateSelectorProperty, value);
                }
            },
            HasHeader: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue$1(System.Windows.Controls.HeaderedContentControl.HasHeaderPropertyKey)), System.Boolean));
                },
                set: function (value) {
                    this.SetValue$1(System.Windows.Controls.HeaderedContentControl.HasHeaderPropertyKey, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            }
        },
        methods: {
            OnHeaderChanged: function (e) {
                this.HasHeader = this.Header != null;
                this.RemoveLogicalChild(e.OldValue);
                this.AddLogicalChild(e.NewValue);
            }
        }
    });

    Bridge.ns("System.Windows.Controls.HeaderedContentControl", $asm.$);

    Bridge.apply($asm.$.System.Windows.Controls.HeaderedContentControl, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.HeaderedContentControl).OnHeaderChanged(e);
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.Selector", {
        inherits: [System.Windows.Controls.ItemsControl],
        statics: {
            fields: {
                SelectionChangedEvent: null,
                SelectedEvent: null,
                UnselectedEvent: null,
                IsSynchronizedWithCurrentItemProperty: null,
                SelectedIndexProperty: null,
                SelectedItemProperty: null,
                SelectedValueProperty: null,
                SelectedValuePathProperty: null,
                IsSelectedProperty: null,
                IsSelectionActivePropertyKey: null,
                IsSelectionActiveProperty: null
            },
            ctors: {
                init: function () {
                    this.SelectionChangedEvent = System.Windows.EventManager.RegisterRoutedEvent("SelectionChanged", System.Windows.RoutingStrategy.Bubble, Function, System.Windows.Controls.Primitives.Selector);
                    this.SelectedEvent = System.Windows.EventManager.RegisterRoutedEvent("Selected", System.Windows.RoutingStrategy.Bubble, Function, System.Windows.Controls.Primitives.Selector);
                    this.UnselectedEvent = System.Windows.EventManager.RegisterRoutedEvent("Unselected", System.Windows.RoutingStrategy.Bubble, Function, System.Windows.Controls.Primitives.Selector);
                    this.IsSynchronizedWithCurrentItemProperty = System.Windows.DependencyProperty.Register("IsSynchronizedWithCurrentItem", System.Nullable$1(System.Boolean), System.Windows.Controls.Primitives.Selector, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.SelectedIndexProperty = System.Windows.DependencyProperty.Register("SelectedIndex", System.Int32, System.Windows.Controls.Primitives.Selector, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.Primitives.Selector.f1));
                    this.SelectedItemProperty = System.Windows.DependencyProperty.Register("SelectedItem", System.Object, System.Windows.Controls.Primitives.Selector, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.Primitives.Selector.f2));
                    this.SelectedValueProperty = System.Windows.DependencyProperty.Register("SelectedValue", System.Object, System.Windows.Controls.Primitives.Selector, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.Primitives.Selector.f3));
                    this.SelectedValuePathProperty = System.Windows.DependencyProperty.Register("SelectedValuePath", System.String, System.Windows.Controls.Primitives.Selector, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.IsSelectedProperty = System.Windows.DependencyProperty.Register("IsSelected", System.Boolean, System.Windows.Controls.Primitives.Selector, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.IsSelectionActivePropertyKey = System.Windows.DependencyProperty.RegisterAttachedReadOnly("IsSelectionActive", System.Boolean, System.Windows.Controls.Primitives.Selector, new System.Windows.FrameworkPropertyMetadata.$ctor8(System.Windows.FrameworkPropertyMetadataOptions.Inherits));
                    this.IsSelectionActiveProperty = System.Windows.Controls.Primitives.Selector.IsSelectionActivePropertyKey.DependencyProperty;
                }
            },
            methods: {
                GetIsSelectionActive: function (obj) {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj.GetValue(System.Windows.Controls.Primitives.Selector.IsSelectionActiveProperty)), System.Boolean));
                },
                SetIsSelectionActive: function (obj, value) {
                    obj.SetValue$1(System.Windows.Controls.Primitives.Selector.IsSelectionActivePropertyKey, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            }
        },
        props: {
            IsSynchronizedWithCurrentItem: {
                get: function () {
                    return Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.Selector.IsSynchronizedWithCurrentItemProperty)), System.Boolean, true);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.Selector.IsSynchronizedWithCurrentItemProperty, Bridge.box(value, System.Boolean, System.Nullable.toStringFn(System.Boolean.toString), System.Nullable.getHashCode));
                }
            },
            SelectedIndex: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.Selector.SelectedIndexProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.Selector.SelectedIndexProperty, Bridge.box(value, System.Int32));
                }
            },
            SelectedItem: {
                get: function () {
                    return this.GetValue(System.Windows.Controls.Primitives.Selector.SelectedItemProperty);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.Selector.SelectedItemProperty, value);
                }
            },
            SelectedValue: {
                get: function () {
                    return this.GetValue(System.Windows.Controls.Primitives.Selector.SelectedValueProperty);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.Selector.SelectedValueProperty, value);
                }
            },
            SelectedValuePath: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.Primitives.Selector.SelectedValuePathProperty), System.String);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.Selector.SelectedValuePathProperty, value);
                }
            },
            IsSelected: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.Selector.IsSelectedProperty)), System.Boolean));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.Selector.IsSelectedProperty, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Controls.ItemsControl.ctor.call(this);
                System.Windows.Controls.Primitives.Selector.SetIsSelectionActive(this, false);
            }
        },
        methods: {
            addSelectionChanged: function (value) {
                this.AddHandler(System.Windows.Controls.Primitives.Selector.SelectionChangedEvent, value);
            },
            removeSelectionChanged: function (value) {
                this.RemoveHandler(System.Windows.Controls.Primitives.Selector.SelectionChangedEvent, value);
            },
            addSelected: function (value) {
                this.AddHandler(System.Windows.Controls.Primitives.Selector.SelectedEvent, value);
            },
            removeSelected: function (value) {
                this.RemoveHandler(System.Windows.Controls.Primitives.Selector.SelectedEvent, value);
            },
            addUnselected: function (value) {
                this.AddHandler(System.Windows.Controls.Primitives.Selector.UnselectedEvent, value);
            },
            removeUnselected: function (value) {
                this.RemoveHandler(System.Windows.Controls.Primitives.Selector.UnselectedEvent, value);
            },
            OnGotFocus: function (e) {
                System.Windows.Controls.Primitives.Selector.SetIsSelectionActive(this, true);
            },
            OnLostFocus: function (e) {
                System.Windows.Controls.Primitives.Selector.SetIsSelectionActive(this, false);
            },
            OnSelectedIndexChanged: function (e) {
                //
            },
            OnSelectedItemChanged: function (e) {
                if (e.OldValue != null) {
                    this.ItemContainerGenerator.System$Windows$Controls$Primitives$IItemContainerGenerator$ContainerFromItem(e.OldValue).SetCurrentValue(System.Windows.Controls.Primitives.Selector.IsSelectedProperty, Bridge.box(false, System.Boolean, System.Boolean.toString));
                }

                if (e.NewValue != null) {
                    this.ItemContainerGenerator.System$Windows$Controls$Primitives$IItemContainerGenerator$ContainerFromItem(e.NewValue).SetCurrentValue(System.Windows.Controls.Primitives.Selector.IsSelectedProperty, Bridge.box(true, System.Boolean, System.Boolean.toString));
                }
            },
            OnSelectedValueChanged: function (e) {
                //
            }
        }
    });

    Bridge.ns("System.Windows.Controls.Primitives.Selector", $asm.$);

    Bridge.apply($asm.$.System.Windows.Controls.Primitives.Selector, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.Primitives.Selector).OnSelectedIndexChanged(e);
        },
        f2: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.Primitives.Selector).OnSelectedItemChanged(e);
        },
        f3: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.Primitives.Selector).OnSelectedValueChanged(e);
        }
    });

    Bridge.define("System.Windows.Controls.ListBoxItem", {
        inherits: [System.Windows.Controls.ContentControl],
        statics: {
            fields: {
                SelectedEvent: null,
                UnselectedEvent: null,
                IsSelectedProperty: null
            },
            ctors: {
                init: function () {
                    this.SelectedEvent = System.Windows.Controls.Primitives.Selector.SelectedEvent.AddOwner(System.Windows.Controls.ListBoxItem);
                    this.UnselectedEvent = System.Windows.Controls.Primitives.Selector.UnselectedEvent.AddOwner(System.Windows.Controls.ListBoxItem);
                    this.IsSelectedProperty = System.Windows.Controls.Primitives.Selector.IsSelectedProperty.AddOwner(System.Windows.Controls.ListBoxItem, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.ListBoxItem.f1));
                },
                ctor: function () {
                    System.Windows.UIElement.IsEnabledProperty.OverrideMetadata(System.Windows.Controls.ListBoxItem, new System.Windows.FrameworkPropertyMetadata.$ctor8(System.Windows.FrameworkPropertyMetadataOptions.AffectsVisualState));
                    System.Windows.UIElement.IsMouseOverProperty.OverrideMetadata(System.Windows.Controls.ListBoxItem, new System.Windows.FrameworkPropertyMetadata.$ctor8(System.Windows.FrameworkPropertyMetadataOptions.AffectsVisualState));
                    System.Windows.Controls.Primitives.Selector.IsSelectionActiveProperty.OverrideMetadata(System.Windows.Controls.ListBoxItem, new System.Windows.FrameworkPropertyMetadata.$ctor8(2080));
                    System.Windows.FrameworkElement.DefaultStyleKeyProperty.OverrideMetadata(System.Windows.Controls.ListBoxItem, new System.Windows.FrameworkPropertyMetadata.$ctor1(new System.Windows.StyleKey(System.Windows.Controls.ListBoxItem)));
                }
            }
        },
        props: {
            IsSelected: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.ListBoxItem.IsSelectedProperty)), System.Boolean));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.ListBoxItem.IsSelectedProperty, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            }
        },
        methods: {
            addSelected: function (value) {
                this.AddHandler(System.Windows.Controls.ListBoxItem.SelectedEvent, value);
            },
            removeSelected: function (value) {
                this.RemoveHandler(System.Windows.Controls.ListBoxItem.SelectedEvent, value);
            },
            addUnselected: function (value) {
                this.AddHandler(System.Windows.Controls.ListBoxItem.UnselectedEvent, value);
            },
            removeUnselected: function (value) {
                this.RemoveHandler(System.Windows.Controls.ListBoxItem.UnselectedEvent, value);
            },
            OnMouseDown: function (e) {
                this.Focus();
            },
            OnIsSelectedChanged: function (e) {
                this.RaiseEvent(new System.Windows.RoutedEventArgs(System.Nullable.getValue(Bridge.cast(Bridge.unbox(e.NewValue), System.Boolean)) === true ? System.Windows.Controls.ListBoxItem.SelectedEvent : System.Windows.Controls.ListBoxItem.UnselectedEvent, this));
            },
            UpdateVisualState: function (useTransitions) {
                System.Windows.VisualStateManager.GoToState(this, this.GetCommonState(), useTransitions);
                System.Windows.VisualStateManager.GoToState(this, this.GetSelectionState(), useTransitions);
                System.Windows.VisualStateManager.GoToState(this, this.GetFocusState(), useTransitions);
            },
            GetCommonState: function () {
                if (!this.IsEnabled) {
                    return System.Windows.Controls.VisualStates.DisabledState;
                }

                if (this.IsMouseOver) {
                    return System.Windows.Controls.VisualStates.MouseOverState;
                }

                return System.Windows.Controls.VisualStates.NormalState;
            },
            GetSelectionState: function () {
                if (!this.IsSelected) {
                    return System.Windows.Controls.VisualStates.UnselectedState;
                }

                if (!System.Windows.Controls.Primitives.Selector.GetIsSelectionActive(this)) {
                    return System.Windows.Controls.VisualStates.SelectedUnfocusedState;
                }

                return System.Windows.Controls.VisualStates.SelectedState;
            },
            GetFocusState: function () {
                return this.IsFocused ? System.Windows.Controls.VisualStates.FocusedState : System.Windows.Controls.VisualStates.UnfocusedState;
            }
        }
    });

    Bridge.ns("System.Windows.Controls.ListBoxItem", $asm.$);

    Bridge.apply($asm.$.System.Windows.Controls.ListBoxItem, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.ListBoxItem).OnIsSelectedChanged(e);
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.ScrollBar", {
        inherits: [System.Windows.Controls.Primitives.RangeBase],
        statics: {
            fields: {
                ScrollEvent: null,
                OrientationProperty: null,
                ViewportSizeProperty: null
            },
            ctors: {
                init: function () {
                    this.ScrollEvent = System.Windows.EventManager.RegisterRoutedEvent("Scroll", System.Windows.RoutingStrategy.Bubble, Function, System.Windows.Controls.Primitives.ScrollBar);
                    this.OrientationProperty = System.Windows.DependencyProperty.Register("Orientation", System.Windows.Controls.Orientation, System.Windows.Controls.Primitives.ScrollBar, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.ViewportSizeProperty = System.Windows.DependencyProperty.Register("ViewportSize", System.Double, System.Windows.Controls.Primitives.ScrollBar, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.Primitives.ScrollBar.f1));
                },
                ctor: function () {
                    System.Windows.UIElement.FocusableProperty.OverrideMetadata(System.Windows.Controls.Primitives.ScrollBar, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(false, System.Boolean, System.Boolean.toString)));
                    System.Windows.FrameworkElement.DefaultStyleKeyProperty.OverrideMetadata(System.Windows.Controls.Primitives.ScrollBar, new System.Windows.FrameworkPropertyMetadata.$ctor1(new System.Windows.StyleKey(System.Windows.Controls.Primitives.ScrollBar)));
                }
            }
        },
        fields: {
            SnapBackThreshold: 0,
            thumb: null,
            track: null,
            decreasePageButton: null,
            increasePageButton: null,
            decreaseLineButton: null,
            increaseLineButton: null,
            dragInitialValue: 0
        },
        props: {
            Orientation: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.ScrollBar.OrientationProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.ScrollBar.OrientationProperty, Bridge.box(value, System.Windows.Controls.Orientation, System.Enum.toStringFn(System.Windows.Controls.Orientation)));
                }
            },
            ViewportSize: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.ScrollBar.ViewportSizeProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.ScrollBar.ViewportSizeProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            Thumb: {
                get: function () {
                    return this.thumb;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.thumb, value)) {
                        return;
                    }

                    if (this.thumb != null) {
                        this.thumb.removeDragStarted(Bridge.fn.cacheBind(this, this.OnThumbDragStarted));
                        this.thumb.removeDragDelta(Bridge.fn.cacheBind(this, this.OnThumbDragDelta));
                        this.thumb.removeDragCompleted(Bridge.fn.cacheBind(this, this.OnThumbDragCompleted));
                    }

                    this.thumb = value;

                    if (this.thumb != null) {
                        this.thumb.addDragStarted(Bridge.fn.cacheBind(this, this.OnThumbDragStarted));
                        this.thumb.addDragDelta(Bridge.fn.cacheBind(this, this.OnThumbDragDelta));
                        this.thumb.addDragCompleted(Bridge.fn.cacheBind(this, this.OnThumbDragCompleted));
                    }
                }
            },
            Track: {
                get: function () {
                    return this.track;
                },
                set: function (value) {
                    this.track = value;

                    if (this.track != null) {
                        this.Thumb = this.track.Thumb;
                        this.DecreasePageButton = this.track.DecreaseRepeatButton;
                        this.IncreasePageButton = this.track.IncreaseRepeatButton;
                    } else {
                        this.Thumb = null;
                        this.DecreasePageButton = null;
                        this.IncreasePageButton = null;
                    }
                }
            },
            DecreasePageButton: {
                get: function () {
                    return this.decreasePageButton;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.decreasePageButton, value)) {
                        return;
                    }

                    if (this.decreasePageButton != null) {
                        this.decreasePageButton.removeClick(Bridge.fn.cacheBind(this, this.OnDecreasePageClicked));
                    }

                    this.decreasePageButton = value;

                    if (this.decreasePageButton != null) {
                        this.decreasePageButton.addClick(Bridge.fn.cacheBind(this, this.OnDecreasePageClicked));
                    }
                }
            },
            IncreasePageButton: {
                get: function () {
                    return this.increasePageButton;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.increasePageButton, value)) {
                        return;
                    }

                    if (this.increasePageButton != null) {
                        this.increasePageButton.removeClick(Bridge.fn.cacheBind(this, this.OnIncreasePageClicked));
                    }

                    this.increasePageButton = value;

                    if (this.increasePageButton != null) {
                        this.increasePageButton.addClick(Bridge.fn.cacheBind(this, this.OnIncreasePageClicked));
                    }
                }
            },
            DecreaseLineButton: {
                get: function () {
                    return this.decreaseLineButton;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.decreaseLineButton, value)) {
                        return;
                    }

                    if (this.decreaseLineButton != null) {
                        this.decreaseLineButton.removeClick(Bridge.fn.cacheBind(this, this.OnDecreaseLineClicked));
                    }

                    this.decreaseLineButton = value;

                    if (this.decreaseLineButton != null) {
                        this.decreaseLineButton.addClick(Bridge.fn.cacheBind(this, this.OnDecreaseLineClicked));
                    }
                }
            },
            IncreaseLineButton: {
                get: function () {
                    return this.increaseLineButton;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.increaseLineButton, value)) {
                        return;
                    }

                    if (this.increaseLineButton != null) {
                        this.increaseLineButton.removeClick(Bridge.fn.cacheBind(this, this.OnIncreaseLineClicked));
                    }

                    this.increaseLineButton = value;

                    if (this.increaseLineButton != null) {
                        this.increaseLineButton.addClick(Bridge.fn.cacheBind(this, this.OnIncreaseLineClicked));
                    }
                }
            }
        },
        ctors: {
            init: function () {
                this.SnapBackThreshold = 150;
            },
            ctor: function () {
                this.$initialize();
                System.Windows.Controls.Primitives.RangeBase.ctor.call(this);
                //
            }
        },
        methods: {
            addScroll: function (value) {
                this.AddHandler(System.Windows.Controls.Primitives.ScrollBar.ScrollEvent, value);
            },
            removeScroll: function (value) {
                this.RemoveHandler(System.Windows.Controls.Primitives.ScrollBar.ScrollEvent, value);
            },
            OnApplyTemplate: function () {
                System.Windows.Controls.Primitives.RangeBase.prototype.OnApplyTemplate.call(this);

                if (this.Template != null) {
                    this.DecreaseLineButton = Bridge.as(System.Windows.FrameworkTemplateExtensions.FindName(this.Template, "PART_DecreaseButton", this), System.Windows.Controls.Primitives.ButtonBase);
                    this.IncreaseLineButton = Bridge.as(System.Windows.FrameworkTemplateExtensions.FindName(this.Template, "PART_IncreaseButton", this), System.Windows.Controls.Primitives.ButtonBase);
                    this.Track = Bridge.as(System.Windows.FrameworkTemplateExtensions.FindName(this.Template, "PART_Track", this), System.Windows.Controls.Primitives.Track);
                } else {
                    this.DecreaseLineButton = null;
                    this.IncreaseLineButton = null;
                    this.Track = null;
                }
            },
            OnDecreaseLineClicked: function (sender, e) {
                this.Value -= this.SmallChange;
                this.RaiseScrollEvent(System.Windows.Controls.Primitives.ScrollEventType.SmallDecrement);
                e.Handled = true;
            },
            OnIncreaseLineClicked: function (sender, e) {
                this.Value += this.SmallChange;
                this.RaiseScrollEvent(System.Windows.Controls.Primitives.ScrollEventType.SmallIncrement);
                e.Handled = true;
            },
            OnDecreasePageClicked: function (sender, e) {
                this.Value -= this.LargeChange;
                this.RaiseScrollEvent(System.Windows.Controls.Primitives.ScrollEventType.LargeDecrement);
                e.Handled = true;
            },
            OnIncreasePageClicked: function (sender, e) {
                this.Value += this.LargeChange;
                this.RaiseScrollEvent(System.Windows.Controls.Primitives.ScrollEventType.LargeIncrement);
                e.Handled = true;
            },
            OnThumbDragStarted: function (sender, e) {
                this.dragInitialValue = this.Value;
                e.Handled = true;
            },
            OnThumbDragDelta: function (sender, e) {
                this.Value = Math.abs(this.GetCrossLength(e.Delta)) > this.SnapBackThreshold ? this.dragInitialValue : Granular.Extensions.DoubleExtensions.Bounds((this.dragInitialValue + (this.Maximum - this.Minimum) * this.GetMainLength(e.Delta) / (this.GetMainLength$1(this.Track.RenderSize) - this.GetMainLength$1(this.Thumb.RenderSize))), this.Minimum, this.Maximum);

                this.RaiseScrollEvent(System.Windows.Controls.Primitives.ScrollEventType.ThumbTrack);
                e.Handled = true;
            },
            OnThumbDragCompleted: function (sender, e) {
                if (e.IsCanceled) {
                    this.Value = this.dragInitialValue;
                }

                this.RaiseScrollEvent(System.Windows.Controls.Primitives.ScrollEventType.EndScroll);
                e.Handled = true;
            },
            OnViewportSizeChanged: function (e) {
                this.SmallChange = System.Windows.Controls.Primitives.ScrollInfoExtensions.ScrollLineDelta;
                this.LargeChange = Granular.Extensions.DoubleExtensions.Max((this.ViewportSize - System.Windows.Controls.Primitives.ScrollInfoExtensions.ScrollLineDelta), System.Windows.Controls.Primitives.ScrollInfoExtensions.ScrollLineDelta);
            },
            GetMainLength$1: function (size) {
                return this.Orientation === System.Windows.Controls.Orientation.Horizontal ? size.Width : size.Height;
            },
            GetMainLength: function (point) {
                return this.Orientation === System.Windows.Controls.Orientation.Horizontal ? point.X : point.Y;
            },
            GetCrossLength: function (point) {
                return this.Orientation === System.Windows.Controls.Orientation.Horizontal ? point.Y : point.X;
            },
            RaiseScrollEvent: function (scrollEventType) {
                this.RaiseEvent(new System.Windows.Controls.Primitives.ScrollEventArgs(System.Windows.Controls.Primitives.ScrollBar.ScrollEvent, this, scrollEventType, this.Value));
            }
        }
    });

    Bridge.ns("System.Windows.Controls.Primitives.ScrollBar", $asm.$);

    Bridge.apply($asm.$.System.Windows.Controls.Primitives.ScrollBar, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.Primitives.ScrollBar).OnViewportSizeChanged(e);
        }
    });

    Bridge.define("System.Windows.Controls.ProgressBar", {
        inherits: [System.Windows.Controls.Primitives.RangeBase],
        statics: {
            fields: {
                IsIndeterminateProperty: null
            },
            ctors: {
                init: function () {
                    this.IsIndeterminateProperty = System.Windows.DependencyProperty.Register("IsIndeterminate", System.Boolean, System.Windows.Controls.ProgressBar, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.ProgressBar.f1));
                },
                ctor: function () {
                    System.Windows.UIElement.FocusableProperty.OverrideMetadata(System.Windows.Controls.ProgressBar, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(false, System.Boolean, System.Boolean.toString)));
                    System.Windows.Controls.Primitives.RangeBase.MaximumProperty.OverrideMetadata(System.Windows.Controls.ProgressBar, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(100.0, System.Double, System.Double.format, System.Double.getHashCode)));
                    System.Windows.Controls.Control.ForegroundProperty.OverrideMetadata(System.Windows.Controls.ProgressBar, new System.Windows.FrameworkPropertyMetadata.$ctor9(System.Windows.FrameworkPropertyMetadataOptions.Inherits, $asm.$.System.Windows.Controls.ProgressBar.f2));
                    System.Windows.FrameworkElement.DefaultStyleKeyProperty.OverrideMetadata(System.Windows.Controls.ProgressBar, new System.Windows.FrameworkPropertyMetadata.$ctor1(new System.Windows.StyleKey(System.Windows.Controls.ProgressBar)));
                }
            }
        },
        fields: {
            track: null,
            indicator: null,
            glow: null,
            currentAnimatedIndicatorWidth: 0,
            currentAnimationClock: null
        },
        props: {
            IsIndeterminate: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.ProgressBar.IsIndeterminateProperty)), System.Boolean));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.ProgressBar.IsIndeterminateProperty, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            },
            Track: {
                get: function () {
                    return this.track;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.track, value)) {
                        return;
                    }

                    if (this.track != null) {
                        this.track.removeLayoutUpdated(Bridge.fn.cacheBind(this, this.OnTrackLayoutUpdated));
                    }

                    this.track = value;

                    if (this.track != null) {
                        this.track.addLayoutUpdated(Bridge.fn.cacheBind(this, this.OnTrackLayoutUpdated));
                    }
                }
            },
            Indicator: {
                get: function () {
                    return this.indicator;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.indicator, value)) {
                        return;
                    }

                    if (this.indicator != null) {
                        this.indicator.removeLayoutUpdated(Bridge.fn.cacheBind(this, this.OnIndicatorLayoutUpdated));
                    }

                    this.indicator = value;

                    if (this.indicator != null) {
                        this.indicator.addLayoutUpdated(Bridge.fn.cacheBind(this, this.OnIndicatorLayoutUpdated));
                    }
                }
            }
        },
        methods: {
            OnApplyTemplate: function () {
                System.Windows.Controls.Primitives.RangeBase.prototype.OnApplyTemplate.call(this);

                if (this.Template != null) {
                    this.Track = Bridge.as(System.Windows.FrameworkTemplateExtensions.FindName(this.Template, "PART_Track", this), System.Windows.FrameworkElement);
                    this.Indicator = Bridge.as(System.Windows.FrameworkTemplateExtensions.FindName(this.Template, "PART_Indicator", this), System.Windows.FrameworkElement);
                    this.glow = Bridge.as(System.Windows.FrameworkTemplateExtensions.FindName(this.Template, "PART_Glow", this), System.Windows.Controls.Border);
                } else {
                    this.Track = null;
                    this.Indicator = null;
                    this.glow = null;
                }

                this.SetIndicatorSize();
                this.SetGlowColor();
                this.SetGlowAnimation();
            },
            OnValueChanged: function (e) {
                this.SetIndicatorSize();
            },
            OnMinimumChanged: function (e) {
                this.SetIndicatorSize();
            },
            OnMaximumChanged: function (e) {
                this.SetIndicatorSize();
            },
            OnTrackLayoutUpdated: function (sender, e) {
                this.SetIndicatorSize();
            },
            OnIndicatorLayoutUpdated: function (sender, e) {
                this.SetGlowAnimation();
            },
            OnIsIndeterminateChanged: function (e) {
                this.SetIndicatorSize();
                this.SetGlowColor();
            },
            OnForegroundChanged: function (e) {
                this.SetGlowColor();
            },
            SetIndicatorSize: function () {
                if (this.Track == null || this.Indicator == null) {
                    return;
                }

                var width = this.IsIndeterminate ? this.Track.ActualWidth : this.Track.ActualWidth * (this.Value - this.Minimum) / (this.Maximum - this.Minimum);

                if (!Granular.Extensions.DoubleExtensions.IsClose(this.Indicator.Width, width)) {
                    this.Indicator.Width = width;
                }
            },
            SetGlowColor: function () {
                if (this.glow == null) {
                    return;
                }

                if (this.IsIndeterminate && !(Bridge.is(this.Foreground, System.Windows.Media.SolidColorBrush))) {
                    this.glow.Background = this.Foreground;
                } else {
                    var color = this.IsIndeterminate ? Bridge.cast(this.Foreground, System.Windows.Media.SolidColorBrush).Color : System.Windows.Media.Color.FromArgb(128, 255, 255, 255);

                    this.glow.Background = new System.Windows.Media.LinearGradientBrush.$ctor3(System.Windows.Point.Zero, new System.Windows.Point.$ctor1(1, 0), System.Array.init([new System.Windows.Media.GradientStop.$ctor1(System.Windows.Media.Colors.Transparent, 0), new System.Windows.Media.GradientStop.$ctor1(color, 0.4), new System.Windows.Media.GradientStop.$ctor1(color, 0.6), new System.Windows.Media.GradientStop.$ctor1(System.Windows.Media.Colors.Transparent, 1)], System.Windows.Media.GradientStop));
                }
            },
            SetGlowAnimation: function () {
                var $t;
                if (this.Indicator == null || this.glow == null || Granular.Extensions.DoubleExtensions.IsClose(this.Indicator.ActualWidth, this.currentAnimatedIndicatorWidth)) {
                    return;
                }

                this.currentAnimatedIndicatorWidth = this.Indicator.ActualWidth;

                var currentOffset = this.glow.Margin.Left;

                if (this.currentAnimationClock != null) {
                    Bridge.cast(this.glow, System.Windows.Media.Animation.IAnimatable).System$Windows$Media$Animation$IAnimatable$RootClock.System$Windows$Media$Animation$IRootClock$RemoveClock(this.currentAnimationClock);
                    this.currentAnimationClock = null;
                }

                if (this.Indicator.ActualWidth > 0) {
                    var startOffset = -this.glow.ActualWidth;
                    var endOffset = this.Indicator.ActualWidth;

                    var time = System.TimeSpan.fromSeconds((endOffset - startOffset) / 200);

                    var thicknessAnimation = new System.Windows.Media.Animation.ThicknessAnimationUsingKeyFrames();

                    thicknessAnimation.KeyFrames.add(($t = new System.Windows.Media.Animation.LinearThicknessKeyFrame(), $t.Value = new System.Windows.Thickness.$ctor3(startOffset, 0, 0, 0), $t.KeyTime = System.Windows.Media.Animation.KeyTime.FromTimeSpan(System.TimeSpan.zero), $t));
                    thicknessAnimation.KeyFrames.add(($t = new System.Windows.Media.Animation.LinearThicknessKeyFrame(), $t.Value = new System.Windows.Thickness.$ctor3(endOffset, 0, 0, 0), $t.KeyTime = System.Windows.Media.Animation.KeyTime.FromTimeSpan(time), $t));

                    thicknessAnimation.Duration = new System.Windows.Duration.ctor(System.TimeSpan.add(time, System.TimeSpan.fromSeconds(1)));

                    thicknessAnimation.RepeatBehavior = System.Windows.Media.Animation.RepeatBehavior.Forever;
                    thicknessAnimation.BeginTime = System.TimeSpan.neg(Granular.Extensions.TimeSpanExtensions.Scale(time, (currentOffset - startOffset) / (endOffset - startOffset)));

                    this.currentAnimationClock = Bridge.cast(thicknessAnimation.CreateClock(), System.Windows.Media.Animation.AnimationTimelineClock);

                    System.Windows.Media.Animation.AnimatableExtensions.ApplyAnimationClock(this.glow, System.Windows.FrameworkElement.MarginProperty, this.currentAnimationClock);
                    this.currentAnimationClock.Begin(Bridge.cast(this.glow, System.Windows.Media.Animation.IAnimatable).System$Windows$Media$Animation$IAnimatable$RootClock);
                } else {
                    System.Windows.Media.Animation.AnimatableExtensions.ClearAnimationClocks(this.glow, System.Windows.FrameworkElement.MarginProperty);
                }
            }
        }
    });

    Bridge.ns("System.Windows.Controls.ProgressBar", $asm.$);

    Bridge.apply($asm.$.System.Windows.Controls.ProgressBar, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.ProgressBar).OnIsIndeterminateChanged(e);
        },
        f2: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.ProgressBar).OnForegroundChanged(e);
        }
    });

    Bridge.define("System.Windows.Controls.ScrollViewer", {
        inherits: [System.Windows.Controls.ContentControl],
        statics: {
            fields: {
                ScrollChangedEvent: null,
                CanContentScrollProperty: null,
                ComputedHorizontalScrollBarVisibilityPropertyKey: null,
                ComputedHorizontalScrollBarVisibilityProperty: null,
                ComputedVerticalScrollBarVisibilityPropertyKey: null,
                ComputedVerticalScrollBarVisibilityProperty: null,
                ComputedScrollBarsVisibilityPropertyKey: null,
                ComputedScrollBarsVisibilityProperty: null,
                HorizontalScrollBarVisibilityProperty: null,
                VerticalScrollBarVisibilityProperty: null,
                HorizontalOffsetProperty: null,
                VerticalOffsetProperty: null,
                ExtentWidthPropertyKey: null,
                ExtentWidthProperty: null,
                ExtentHeightPropertyKey: null,
                ExtentHeightProperty: null,
                ViewportWidthPropertyKey: null,
                ViewportWidthProperty: null,
                ViewportHeightPropertyKey: null,
                ViewportHeightProperty: null,
                ScrollableWidthPropertyKey: null,
                ScrollableWidthProperty: null,
                ScrollableHeightPropertyKey: null,
                ScrollableHeightProperty: null
            },
            ctors: {
                init: function () {
                    this.ScrollChangedEvent = System.Windows.EventManager.RegisterRoutedEvent("ScrollChanged", System.Windows.RoutingStrategy.Bubble, Function, System.Windows.Controls.ScrollViewer);
                    this.CanContentScrollProperty = System.Windows.DependencyProperty.RegisterAttached("CanContentScroll", System.Boolean, System.Windows.Controls.ScrollViewer, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.ComputedHorizontalScrollBarVisibilityPropertyKey = System.Windows.DependencyProperty.RegisterReadOnly("ComputedHorizontalScrollBarVisibility", System.Windows.Visibility, System.Windows.Controls.ScrollViewer, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.ComputedHorizontalScrollBarVisibilityProperty = System.Windows.Controls.ScrollViewer.ComputedHorizontalScrollBarVisibilityPropertyKey.DependencyProperty;
                    this.ComputedVerticalScrollBarVisibilityPropertyKey = System.Windows.DependencyProperty.RegisterReadOnly("ComputedVerticalScrollBarVisibility", System.Windows.Visibility, System.Windows.Controls.ScrollViewer, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.ComputedVerticalScrollBarVisibilityProperty = System.Windows.Controls.ScrollViewer.ComputedVerticalScrollBarVisibilityPropertyKey.DependencyProperty;
                    this.ComputedScrollBarsVisibilityPropertyKey = System.Windows.DependencyProperty.RegisterReadOnly("ComputedScrollBarsVisibility", System.Windows.Visibility, System.Windows.Controls.ScrollViewer, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.ComputedScrollBarsVisibilityProperty = System.Windows.Controls.ScrollViewer.ComputedScrollBarsVisibilityPropertyKey.DependencyProperty;
                    this.HorizontalScrollBarVisibilityProperty = System.Windows.DependencyProperty.RegisterAttached("HorizontalScrollBarVisibility", System.Windows.Controls.ScrollBarVisibility, System.Windows.Controls.ScrollViewer, new System.Windows.FrameworkPropertyMetadata.$ctor3(Bridge.box(System.Windows.Controls.ScrollBarVisibility.Visible, System.Windows.Controls.ScrollBarVisibility, System.Enum.toStringFn(System.Windows.Controls.ScrollBarVisibility)), System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure, System.Windows.Controls.ScrollViewer.OnScrollBarVisibilityChanged));
                    this.VerticalScrollBarVisibilityProperty = System.Windows.DependencyProperty.RegisterAttached("VerticalScrollBarVisibility", System.Windows.Controls.ScrollBarVisibility, System.Windows.Controls.ScrollViewer, new System.Windows.FrameworkPropertyMetadata.$ctor3(Bridge.box(System.Windows.Controls.ScrollBarVisibility.Visible, System.Windows.Controls.ScrollBarVisibility, System.Enum.toStringFn(System.Windows.Controls.ScrollBarVisibility)), System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure, System.Windows.Controls.ScrollViewer.OnScrollBarVisibilityChanged));
                    this.HorizontalOffsetProperty = System.Windows.DependencyProperty.Register("HorizontalOffset", System.Double, System.Windows.Controls.ScrollViewer, new System.Windows.FrameworkPropertyMetadata.$ctor9(System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange, $asm.$.System.Windows.Controls.ScrollViewer.f1));
                    this.VerticalOffsetProperty = System.Windows.DependencyProperty.Register("VerticalOffset", System.Double, System.Windows.Controls.ScrollViewer, new System.Windows.FrameworkPropertyMetadata.$ctor9(System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange, $asm.$.System.Windows.Controls.ScrollViewer.f1));
                    this.ExtentWidthPropertyKey = System.Windows.DependencyProperty.RegisterReadOnly("ExtentWidth", System.Double, System.Windows.Controls.ScrollViewer, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.ExtentWidthProperty = System.Windows.Controls.ScrollViewer.ExtentWidthPropertyKey.DependencyProperty;
                    this.ExtentHeightPropertyKey = System.Windows.DependencyProperty.RegisterReadOnly("ExtentHeight", System.Double, System.Windows.Controls.ScrollViewer, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.ExtentHeightProperty = System.Windows.Controls.ScrollViewer.ExtentHeightPropertyKey.DependencyProperty;
                    this.ViewportWidthPropertyKey = System.Windows.DependencyProperty.RegisterReadOnly("ViewportWidth", System.Double, System.Windows.Controls.ScrollViewer, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.ViewportWidthProperty = System.Windows.Controls.ScrollViewer.ViewportWidthPropertyKey.DependencyProperty;
                    this.ViewportHeightPropertyKey = System.Windows.DependencyProperty.RegisterReadOnly("ViewportHeight", System.Double, System.Windows.Controls.ScrollViewer, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.ViewportHeightProperty = System.Windows.Controls.ScrollViewer.ViewportHeightPropertyKey.DependencyProperty;
                    this.ScrollableWidthPropertyKey = System.Windows.DependencyProperty.RegisterReadOnly("ScrollableWidth", System.Double, System.Windows.Controls.ScrollViewer, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.ScrollableWidthProperty = System.Windows.Controls.ScrollViewer.ScrollableWidthPropertyKey.DependencyProperty;
                    this.ScrollableHeightPropertyKey = System.Windows.DependencyProperty.RegisterReadOnly("ScrollableHeight", System.Double, System.Windows.Controls.ScrollViewer, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.ScrollableHeightProperty = System.Windows.Controls.ScrollViewer.ScrollableHeightPropertyKey.DependencyProperty;
                },
                ctor: function () {
                    System.Windows.Controls.Control.IsTabStopProperty.OverrideMetadata(System.Windows.Controls.ScrollViewer, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(false, System.Boolean, System.Boolean.toString)));
                    System.Windows.FrameworkElement.DefaultStyleKeyProperty.OverrideMetadata(System.Windows.Controls.ScrollViewer, new System.Windows.FrameworkPropertyMetadata.$ctor1(new System.Windows.StyleKey(System.Windows.Controls.ScrollViewer)));
                }
            },
            methods: {
                GetCanContentScroll: function (obj) {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj.GetValue(System.Windows.Controls.ScrollViewer.CanContentScrollProperty)), System.Boolean));
                },
                SetCanContentScroll: function (obj, value) {
                    obj.SetValue(System.Windows.Controls.ScrollViewer.CanContentScrollProperty, Bridge.box(value, System.Boolean, System.Boolean.toString));
                },
                InvalidateElementMeasurePath: function (root, element) {
                    if (element == null) {
                        return;
                    }

                    while (!Bridge.referenceEquals(element, root)) {
                        element.InvalidateMeasure();
                        element = Bridge.cast(element.VisualParent, System.Windows.UIElement);
                    }
                },
                GetScrollBarVisibility: function (scrollBarVisibility, isOverflowed) {
                    switch (scrollBarVisibility) {
                        case System.Windows.Controls.ScrollBarVisibility.Disabled: 
                            return System.Windows.Visibility.Collapsed;
                        case System.Windows.Controls.ScrollBarVisibility.Auto: 
                            return isOverflowed ? System.Windows.Visibility.Visible : System.Windows.Visibility.Collapsed;
                        case System.Windows.Controls.ScrollBarVisibility.Hidden: 
                            return System.Windows.Visibility.Collapsed;
                        case System.Windows.Controls.ScrollBarVisibility.Visible: 
                            return System.Windows.Visibility.Visible;
                    }

                    throw new Granular.Exception("Unexpected ScrollBarVisibility \"{0}\"", [Bridge.box(scrollBarVisibility, System.Windows.Controls.ScrollBarVisibility, System.Enum.toStringFn(System.Windows.Controls.ScrollBarVisibility))]);
                },
                OnScrollBarVisibilityChanged: function (dependencyObject, e) {
                    if (Bridge.is(dependencyObject, System.Windows.Controls.ScrollViewer)) {
                        Bridge.cast(dependencyObject, System.Windows.Controls.ScrollViewer).SetContentCanScroll();
                    }
                }
            }
        },
        fields: {
            horizontalScrollBar: null,
            verticalScrollBar: null,
            scrollContentPresenter: null
        },
        props: {
            ComputedHorizontalScrollBarVisibility: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue$1(System.Windows.Controls.ScrollViewer.ComputedHorizontalScrollBarVisibilityPropertyKey)), System.Int32));
                },
                set: function (value) {
                    this.SetValue$1(System.Windows.Controls.ScrollViewer.ComputedHorizontalScrollBarVisibilityPropertyKey, Bridge.box(value, System.Windows.Visibility, System.Enum.toStringFn(System.Windows.Visibility)));
                }
            },
            ComputedVerticalScrollBarVisibility: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue$1(System.Windows.Controls.ScrollViewer.ComputedVerticalScrollBarVisibilityPropertyKey)), System.Int32));
                },
                set: function (value) {
                    this.SetValue$1(System.Windows.Controls.ScrollViewer.ComputedVerticalScrollBarVisibilityPropertyKey, Bridge.box(value, System.Windows.Visibility, System.Enum.toStringFn(System.Windows.Visibility)));
                }
            },
            ComputedScrollBarsVisibility: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue$1(System.Windows.Controls.ScrollViewer.ComputedScrollBarsVisibilityPropertyKey)), System.Int32));
                },
                set: function (value) {
                    this.SetValue$1(System.Windows.Controls.ScrollViewer.ComputedScrollBarsVisibilityPropertyKey, Bridge.box(value, System.Windows.Visibility, System.Enum.toStringFn(System.Windows.Visibility)));
                }
            },
            HorizontalScrollBarVisibility: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.ScrollViewer.HorizontalScrollBarVisibilityProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.ScrollViewer.HorizontalScrollBarVisibilityProperty, Bridge.box(value, System.Windows.Controls.ScrollBarVisibility, System.Enum.toStringFn(System.Windows.Controls.ScrollBarVisibility)));
                }
            },
            VerticalScrollBarVisibility: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.ScrollViewer.VerticalScrollBarVisibilityProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.ScrollViewer.VerticalScrollBarVisibilityProperty, Bridge.box(value, System.Windows.Controls.ScrollBarVisibility, System.Enum.toStringFn(System.Windows.Controls.ScrollBarVisibility)));
                }
            },
            HorizontalOffset: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.ScrollViewer.HorizontalOffsetProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.ScrollViewer.HorizontalOffsetProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            VerticalOffset: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.ScrollViewer.VerticalOffsetProperty)), System.Double));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.ScrollViewer.VerticalOffsetProperty, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            ExtentWidth: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue$1(System.Windows.Controls.ScrollViewer.ExtentWidthPropertyKey)), System.Double));
                },
                set: function (value) {
                    this.SetValue$1(System.Windows.Controls.ScrollViewer.ExtentWidthPropertyKey, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            ExtentHeight: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue$1(System.Windows.Controls.ScrollViewer.ExtentHeightPropertyKey)), System.Double));
                },
                set: function (value) {
                    this.SetValue$1(System.Windows.Controls.ScrollViewer.ExtentHeightPropertyKey, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            ViewportWidth: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue$1(System.Windows.Controls.ScrollViewer.ViewportWidthPropertyKey)), System.Double));
                },
                set: function (value) {
                    this.SetValue$1(System.Windows.Controls.ScrollViewer.ViewportWidthPropertyKey, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            ViewportHeight: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue$1(System.Windows.Controls.ScrollViewer.ViewportHeightPropertyKey)), System.Double));
                },
                set: function (value) {
                    this.SetValue$1(System.Windows.Controls.ScrollViewer.ViewportHeightPropertyKey, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            ScrollableWidth: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue$1(System.Windows.Controls.ScrollViewer.ScrollableWidthPropertyKey)), System.Double));
                },
                set: function (value) {
                    this.SetValue$1(System.Windows.Controls.ScrollViewer.ScrollableWidthPropertyKey, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            ScrollableHeight: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue$1(System.Windows.Controls.ScrollViewer.ScrollableHeightPropertyKey)), System.Double));
                },
                set: function (value) {
                    this.SetValue$1(System.Windows.Controls.ScrollViewer.ScrollableHeightPropertyKey, Bridge.box(value, System.Double, System.Double.format, System.Double.getHashCode));
                }
            },
            HorizontalScrollBar: {
                get: function () {
                    return this.horizontalScrollBar;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.horizontalScrollBar, value)) {
                        return;
                    }

                    if (this.horizontalScrollBar != null) {
                        this.horizontalScrollBar.removeValueChanged(Bridge.fn.cacheBind(this, this.OnScrollBarValueChanged));
                    }

                    this.horizontalScrollBar = value;

                    if (this.horizontalScrollBar != null) {
                        this.horizontalScrollBar.addValueChanged(Bridge.fn.cacheBind(this, this.OnScrollBarValueChanged));
                    }
                }
            },
            VerticalScrollBar: {
                get: function () {
                    return this.verticalScrollBar;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.verticalScrollBar, value)) {
                        return;
                    }

                    if (this.verticalScrollBar != null) {
                        this.verticalScrollBar.removeValueChanged(Bridge.fn.cacheBind(this, this.OnScrollBarValueChanged));
                    }

                    this.verticalScrollBar = value;

                    if (this.verticalScrollBar != null) {
                        this.verticalScrollBar.addValueChanged(Bridge.fn.cacheBind(this, this.OnScrollBarValueChanged));
                    }
                }
            }
        },
        methods: {
            addScrollChanged: function (value) {
                this.AddHandler(System.Windows.Controls.ScrollViewer.ScrollChangedEvent, value);
            },
            removeScrollChanged: function (value) {
                this.RemoveHandler(System.Windows.Controls.ScrollViewer.ScrollChangedEvent, value);
            },
            OnApplyTemplate: function () {
                System.Windows.Controls.ContentControl.prototype.OnApplyTemplate.call(this);

                if (this.Template != null) {
                    this.scrollContentPresenter = Bridge.as(System.Windows.FrameworkTemplateExtensions.FindName(this.Template, "PART_ScrollContentPresenter", this), System.Windows.Controls.ScrollContentPresenter);
                    this.HorizontalScrollBar = Bridge.as(System.Windows.FrameworkTemplateExtensions.FindName(this.Template, "PART_HorizontalScrollBar", this), System.Windows.Controls.Primitives.ScrollBar);
                    this.VerticalScrollBar = Bridge.as(System.Windows.FrameworkTemplateExtensions.FindName(this.Template, "PART_VerticalScrollBar", this), System.Windows.Controls.Primitives.ScrollBar);
                } else {
                    this.scrollContentPresenter = null;
                    this.HorizontalScrollBar = null;
                    this.VerticalScrollBar = null;
                }

                this.SetContentCanScroll();
                this.SetScrollInfoSizes();
            },
            OnScrollBarValueChanged: function (sender, e) {
                this.HorizontalOffset = this.HorizontalScrollBar.Value;
                this.VerticalOffset = this.VerticalScrollBar.Value;
            },
            OnMouseWheel: function (e) {
                if (this.scrollContentPresenter != null) {
                    this.VerticalOffset = Granular.Extensions.DoubleExtensions.Bounds((this.VerticalOffset - Bridge.Int.sign(e.Delta) * System.Windows.Controls.Primitives.ScrollInfoExtensions.MouseWheelDelta), 0, this.ScrollableHeight);
                    e.Handled = true;
                }
            },
            SetOffsets: function () {
                if (this.scrollContentPresenter != null) {
                    this.scrollContentPresenter.Offset = new System.Windows.Point.$ctor1(this.HorizontalOffset, this.VerticalOffset);
                }

                if (this.HorizontalScrollBar != null) {
                    this.HorizontalScrollBar.Value = this.HorizontalOffset;
                }

                if (this.VerticalScrollBar != null) {
                    this.VerticalScrollBar.Value = this.VerticalOffset;
                }
            },
            SetContentCanScroll: function () {
                if (this.scrollContentPresenter != null) {
                    this.scrollContentPresenter.CanHorizontallyScroll = this.HorizontalScrollBarVisibility !== System.Windows.Controls.ScrollBarVisibility.Disabled;
                    this.scrollContentPresenter.CanVerticallyScroll = this.VerticalScrollBarVisibility !== System.Windows.Controls.ScrollBarVisibility.Disabled;
                }
            },
            SetScrollInfoSizes: function () {
                if (this.scrollContentPresenter != null) {
                    this.ExtentWidth = this.scrollContentPresenter.ExtentSize.Width;
                    this.ExtentHeight = this.scrollContentPresenter.ExtentSize.Height;
                    this.ViewportWidth = this.scrollContentPresenter.ViewportSize.Width;
                    this.ViewportHeight = this.scrollContentPresenter.ViewportSize.Height;
                } else {
                    this.ExtentWidth = 0;
                    this.ExtentHeight = 0;
                    this.ViewportWidth = 0;
                    this.ViewportHeight = 0;
                }

                this.ScrollableWidth = Granular.Extensions.DoubleExtensions.Max((this.ExtentWidth - this.ViewportWidth), 0);
                this.ScrollableHeight = Granular.Extensions.DoubleExtensions.Max((this.ExtentHeight - this.ViewportHeight), 0);

                this.HorizontalOffset = Granular.Extensions.DoubleExtensions.Min(this.HorizontalOffset, this.ScrollableWidth);
                this.VerticalOffset = Granular.Extensions.DoubleExtensions.Min(this.VerticalOffset, this.ScrollableHeight);
            },
            MeasureOverride: function (availableSize) {
                if (this.TemplateChild == null) {
                    return System.Windows.Size.Zero;
                }

                this.ComputedHorizontalScrollBarVisibility = System.Windows.Controls.ScrollViewer.GetScrollBarVisibility(this.HorizontalScrollBarVisibility, false);
                this.ComputedVerticalScrollBarVisibility = System.Windows.Controls.ScrollViewer.GetScrollBarVisibility(this.VerticalScrollBarVisibility, false);
                this.ComputedScrollBarsVisibility = this.ComputedHorizontalScrollBarVisibility === System.Windows.Visibility.Visible && this.ComputedVerticalScrollBarVisibility === System.Windows.Visibility.Visible ? System.Windows.Visibility.Visible : System.Windows.Visibility.Collapsed;

                // 3 passes, each pass can cause an overflow (and add a scrollbar which invalidates the measure), starting with no overlaps
                for (var measurePass = 0; measurePass < 3; measurePass = (measurePass + 1) | 0) {
                    // computed visibilities can invalidate the ScrollBars measure, invalidate their path so they will be re-measured through TemplateChild
                    System.Windows.Controls.ScrollViewer.InvalidateElementMeasurePath(this, this.HorizontalScrollBar);
                    System.Windows.Controls.ScrollViewer.InvalidateElementMeasurePath(this, this.VerticalScrollBar);

                    this.TemplateChild.Measure(availableSize);

                    var measuredHorizontalScrollBarVisibility = System.Windows.Controls.ScrollViewer.GetScrollBarVisibility(this.HorizontalScrollBarVisibility, this.scrollContentPresenter != null && this.scrollContentPresenter.ViewportSize.Width < this.scrollContentPresenter.ExtentSize.Width);
                    var measuredVerticalScrollBarVisibility = System.Windows.Controls.ScrollViewer.GetScrollBarVisibility(this.VerticalScrollBarVisibility, this.scrollContentPresenter != null && this.scrollContentPresenter.ViewportSize.Height < this.scrollContentPresenter.ExtentSize.Height);

                    if (this.ComputedHorizontalScrollBarVisibility === measuredHorizontalScrollBarVisibility && this.ComputedVerticalScrollBarVisibility === measuredVerticalScrollBarVisibility) {
                        break;
                    }

                    this.ComputedHorizontalScrollBarVisibility = measuredHorizontalScrollBarVisibility;
                    this.ComputedVerticalScrollBarVisibility = measuredVerticalScrollBarVisibility;
                    this.ComputedScrollBarsVisibility = this.ComputedHorizontalScrollBarVisibility === System.Windows.Visibility.Visible && this.ComputedVerticalScrollBarVisibility === System.Windows.Visibility.Visible ? System.Windows.Visibility.Visible : System.Windows.Visibility.Collapsed;
                }

                this.SetScrollInfoSizes();

                return this.TemplateChild.DesiredSize;
            }
        }
    });

    Bridge.ns("System.Windows.Controls.ScrollViewer", $asm.$);

    Bridge.apply($asm.$.System.Windows.Controls.ScrollViewer, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.ScrollViewer).SetOffsets();
        }
    });

    Bridge.define("System.Windows.Controls.TextBox", {
        inherits: [System.Windows.Controls.Primitives.TextBoxBase],
        statics: {
            fields: {
                TextProperty: null,
                CaretIndexProperty: null,
                SelectionStartProperty: null,
                SelectionLengthProperty: null,
                MaxLengthProperty: null,
                TextAlignmentProperty: null,
                TextWrappingProperty: null,
                HorizontalScrollBarVisibilityProperty: null,
                VerticalScrollBarVisibilityProperty: null
            },
            ctors: {
                init: function () {
                    this.TextProperty = System.Windows.DependencyProperty.Register("Text", System.String, System.Windows.Controls.TextBox, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.TextBox.f1));
                    this.CaretIndexProperty = System.Windows.DependencyProperty.Register("CaretIndex", System.Int32, System.Windows.Controls.TextBox, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.TextBox.f2));
                    this.SelectionStartProperty = System.Windows.DependencyProperty.Register("SelectionStart", System.Int32, System.Windows.Controls.TextBox, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.TextBox.f3));
                    this.SelectionLengthProperty = System.Windows.DependencyProperty.Register("SelectionLength", System.Int32, System.Windows.Controls.TextBox, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.TextBox.f4));
                    this.MaxLengthProperty = System.Windows.DependencyProperty.Register("MaxLength", System.Int32, System.Windows.Controls.TextBox, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.TextBox.f5));
                    this.TextAlignmentProperty = System.Windows.Controls.TextBlock.TextAlignmentProperty.AddOwner(System.Windows.Controls.TextBox, new System.Windows.FrameworkPropertyMetadata.$ctor8(System.Windows.FrameworkPropertyMetadataOptions.Inherits));
                    this.TextWrappingProperty = System.Windows.Controls.TextBlock.TextWrappingProperty.AddOwner(System.Windows.Controls.TextBox, new System.Windows.FrameworkPropertyMetadata.$ctor8(System.Windows.FrameworkPropertyMetadataOptions.Inherits));
                    this.HorizontalScrollBarVisibilityProperty = System.Windows.Controls.ScrollViewer.HorizontalScrollBarVisibilityProperty.AddOwner(System.Windows.Controls.Primitives.TextBoxBase, new System.Windows.FrameworkPropertyMetadata.$ctor6(Bridge.box(System.Windows.Controls.ScrollBarVisibility.Hidden, System.Windows.Controls.ScrollBarVisibility, System.Enum.toStringFn(System.Windows.Controls.ScrollBarVisibility)), $asm.$.System.Windows.Controls.TextBox.f6));
                    this.VerticalScrollBarVisibilityProperty = System.Windows.Controls.ScrollViewer.VerticalScrollBarVisibilityProperty.AddOwner(System.Windows.Controls.Primitives.TextBoxBase, new System.Windows.FrameworkPropertyMetadata.$ctor6(Bridge.box(System.Windows.Controls.ScrollBarVisibility.Hidden, System.Windows.Controls.ScrollBarVisibility, System.Enum.toStringFn(System.Windows.Controls.ScrollBarVisibility)), $asm.$.System.Windows.Controls.TextBox.f7));
                },
                ctor: function () {
                    System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturnProperty.OverrideMetadata(System.Windows.Controls.TextBox, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.TextBox.f8));
                    System.Windows.Controls.Primitives.TextBoxBase.AcceptsTabProperty.OverrideMetadata(System.Windows.Controls.TextBox, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.TextBox.f9));
                    System.Windows.Controls.Primitives.TextBoxBase.IsReadOnlyProperty.OverrideMetadata(System.Windows.Controls.TextBox, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.TextBox.f10));
                    System.Windows.Controls.SpellCheck.IsEnabledProperty.OverrideMetadata(System.Windows.Controls.TextBox, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.TextBox.f11));
                    System.Windows.FrameworkElement.CursorProperty.OverrideMetadata(System.Windows.Controls.TextBox, new System.Windows.FrameworkPropertyMetadata.$ctor1(System.Windows.Input.Cursors.IBeam));
                    System.Windows.FrameworkElement.DefaultStyleKeyProperty.OverrideMetadata(System.Windows.Controls.TextBox, new System.Windows.FrameworkPropertyMetadata.$ctor1(new System.Windows.StyleKey(System.Windows.Controls.TextBox)));
                }
            }
        },
        fields: {
            textBoxView: null
        },
        props: {
            Text: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.TextBox.TextProperty), System.String);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.TextBox.TextProperty, value);
                }
            },
            CaretIndex: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.TextBox.CaretIndexProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.TextBox.CaretIndexProperty, Bridge.box(value, System.Int32));
                }
            },
            SelectionStart: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.TextBox.SelectionStartProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.TextBox.SelectionStartProperty, Bridge.box(value, System.Int32));
                }
            },
            SelectionLength: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.TextBox.SelectionLengthProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.TextBox.SelectionLengthProperty, Bridge.box(value, System.Int32));
                }
            },
            MaxLength: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.TextBox.MaxLengthProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.TextBox.MaxLengthProperty, Bridge.box(value, System.Int32));
                }
            },
            TextAlignment: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.TextBox.TextAlignmentProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.TextBox.TextAlignmentProperty, Bridge.box(value, System.Windows.TextAlignment, System.Enum.toStringFn(System.Windows.TextAlignment)));
                }
            },
            TextWrapping: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.TextBox.TextWrappingProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.TextBox.TextWrappingProperty, Bridge.box(value, System.Windows.TextWrapping, System.Enum.toStringFn(System.Windows.TextWrapping)));
                }
            },
            HorizontalScrollBarVisibility: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.TextBox.HorizontalScrollBarVisibilityProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.TextBox.HorizontalScrollBarVisibilityProperty, Bridge.box(value, System.Windows.Controls.ScrollBarVisibility, System.Enum.toStringFn(System.Windows.Controls.ScrollBarVisibility)));
                }
            },
            VerticalScrollBarVisibility: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.TextBox.VerticalScrollBarVisibilityProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.TextBox.VerticalScrollBarVisibilityProperty, Bridge.box(value, System.Windows.Controls.ScrollBarVisibility, System.Enum.toStringFn(System.Windows.Controls.ScrollBarVisibility)));
                }
            },
            LineCount: 0
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Controls.Primitives.TextBoxBase.ctor.call(this);
                this.textBoxView = new System.Windows.Controls.TextBoxView();
                this.textBoxView.HorizontalScrollBarVisibility = this.HorizontalScrollBarVisibility;
                this.textBoxView.VerticalScrollBarVisibility = this.VerticalScrollBarVisibility;
                this.textBoxView.SpellCheck = System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.SpellCheck.IsEnabledProperty)), System.Boolean));
                this.textBoxView.addTextChanged(Bridge.fn.bind(this, $asm.$.System.Windows.Controls.TextBox.f12));
                this.textBoxView.addCaretIndexChanged(Bridge.fn.bind(this, $asm.$.System.Windows.Controls.TextBox.f13));
                this.textBoxView.addSelectionStartChanged(Bridge.fn.bind(this, $asm.$.System.Windows.Controls.TextBox.f14));
                this.textBoxView.addSelectionLengthChanged(Bridge.fn.bind(this, $asm.$.System.Windows.Controls.TextBox.f15));
            }
        },
        methods: {
            GetTextBoxContent: function () {
                return this.textBoxView;
            },
            Clear: function () {
                this.Text = "";
            },
            Select: function (start, length) {
                this.textBoxView.SelectionStart = start;
                this.textBoxView.SelectionLength = length;
            },
            GetCharacterIndexFromLineIndex: function (lineIndex) {
                return Granular.Extensions.StringExtensions.GetCharacterIndexFromLineIndex(Granular.Extensions.StringExtensions.DefaultIfNullOrEmpty(this.Text), lineIndex);
            },
            GetLineIndexFromCharacterIndex: function (charIndex) {
                return Granular.Extensions.StringExtensions.GetLineIndexFromCharacterIndex(Granular.Extensions.StringExtensions.DefaultIfNullOrEmpty(this.Text), charIndex);
            },
            GetLineLength: function (lineIndex) {
                return Granular.Extensions.StringExtensions.GetLineLength(Granular.Extensions.StringExtensions.DefaultIfNullOrEmpty(this.Text), lineIndex);
            },
            GetLineText: function (lineIndex) {
                return Granular.Extensions.StringExtensions.GetLineText(Granular.Extensions.StringExtensions.DefaultIfNullOrEmpty(this.Text), lineIndex);
            },
            ScrollToLine: function (lineIndex) {
                var characterIndex = this.GetCharacterIndexFromLineIndex(lineIndex);

                if (characterIndex !== -1) {
                    this.Select(characterIndex, characterIndex);
                }
            },
            OnTextChanged: function (e) {
                this.textBoxView.Text = this.Text;
                this.RaiseEvent(new System.Windows.Controls.TextChangedEventArgs(System.Windows.Controls.Primitives.TextBoxBase.TextChangedEvent, this));
            },
            OnGotFocus: function (e) {
                this.textBoxView.FocusRenderElement();
            },
            OnLostFocus: function (e) {
                this.textBoxView.ClearFocusRenderElement();
            },
            OnKeyDown: function (e) {
                if (e.Key === System.Windows.Input.Key.Enter && !this.AcceptsReturn || e.Key === System.Windows.Input.Key.Tab && !this.AcceptsTab) {
                    return;
                }

                this.textBoxView.ProcessRenderElementKeyEvent(e);
            }
        }
    });

    Bridge.ns("System.Windows.Controls.TextBox", $asm.$);

    Bridge.apply($asm.$.System.Windows.Controls.TextBox, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.TextBox).OnTextChanged(e);
        },
        f2: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.TextBox).textBoxView.CaretIndex = System.Nullable.getValue(Bridge.cast(Bridge.unbox(e.NewValue), System.Int32));
        },
        f3: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.TextBox).textBoxView.SelectionStart = System.Nullable.getValue(Bridge.cast(Bridge.unbox(e.NewValue), System.Int32));
        },
        f4: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.TextBox).textBoxView.SelectionLength = System.Nullable.getValue(Bridge.cast(Bridge.unbox(e.NewValue), System.Int32));
        },
        f5: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.TextBox).textBoxView.MaxLength = System.Nullable.getValue(Bridge.cast(Bridge.unbox(e.NewValue), System.Int32));
        },
        f6: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.TextBox).textBoxView.HorizontalScrollBarVisibility = System.Nullable.getValue(Bridge.cast(Bridge.unbox(e.NewValue), System.Int32));
        },
        f7: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.TextBox).textBoxView.VerticalScrollBarVisibility = System.Nullable.getValue(Bridge.cast(Bridge.unbox(e.NewValue), System.Int32));
        },
        f8: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.TextBox).textBoxView.AcceptsReturn = System.Nullable.getValue(Bridge.cast(Bridge.unbox(e.NewValue), System.Boolean));
        },
        f9: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.TextBox).textBoxView.AcceptsTab = System.Nullable.getValue(Bridge.cast(Bridge.unbox(e.NewValue), System.Boolean));
        },
        f10: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.TextBox).textBoxView.IsReadOnly = Bridge.cast(sender, System.Windows.Controls.TextBox).IsReadOnly;
        },
        f11: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.TextBox).textBoxView.SpellCheck = System.Nullable.getValue(Bridge.cast(Bridge.unbox(e.NewValue), System.Boolean));
        },
        f12: function (sender, e) {
            this.Text = this.textBoxView.Text;
        },
        f13: function (sender, e) {
            this.CaretIndex = this.textBoxView.CaretIndex;
        },
        f14: function (sender, e) {
            this.SelectionStart = this.textBoxView.SelectionStart;
        },
        f15: function (sender, e) {
            this.SelectionLength = this.textBoxView.SelectionLength;
        }
    });

    Bridge.define("System.Windows.Controls.UserControl", {
        inherits: [System.Windows.Controls.ContentControl],
        statics: {
            ctors: {
                ctor: function () {
                    System.Windows.Controls.Control.IsTabStopProperty.OverrideMetadata(System.Windows.Controls.UserControl, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(false, System.Boolean, System.Boolean.toString)));
                    System.Windows.Controls.Control.HorizontalContentAlignmentProperty.OverrideMetadata(System.Windows.Controls.UserControl, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(System.Windows.HorizontalAlignment.Stretch, System.Windows.HorizontalAlignment, System.Enum.toStringFn(System.Windows.HorizontalAlignment))));
                    System.Windows.Controls.Control.VerticalContentAlignmentProperty.OverrideMetadata(System.Windows.Controls.UserControl, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(System.Windows.VerticalAlignment.Stretch, System.Windows.VerticalAlignment, System.Enum.toStringFn(System.Windows.VerticalAlignment))));
                    System.Windows.UIElement.FocusableProperty.OverrideMetadata(System.Windows.Controls.UserControl, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(false, System.Boolean, System.Boolean.toString)));
                }
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.ColorAnimation", {
        inherits: [System.Windows.Media.Animation.TransitionAnimationTimeline$1(System.Windows.Media.Color)],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Animation.TransitionAnimationTimeline$1(System.Windows.Media.Color).ctor.call(this, System.Windows.Media.Animation.ColorAnimationOperations.Default, true);
                //
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.ColorAnimationOperations", {
        inherits: [System.Windows.Media.Animation.IAnimationOperations$1(System.Windows.Media.Color)],
        statics: {
            fields: {
                Default: null
            },
            ctors: {
                init: function () {
                    this.Default = new System.Windows.Media.Animation.ColorAnimationOperations();
                }
            }
        },
        props: {
            Zero: {
                get: function () {
                    return System.Windows.Media.Color.FromUInt32(0);
                }
            }
        },
        alias: [
            "Zero", "System$Windows$Media$Animation$IAnimationOperations$1$System$Windows$Media$Color$Zero",
            "Add", "System$Windows$Media$Animation$IAnimationOperations$1$System$Windows$Media$Color$Add",
            "Subtract", "System$Windows$Media$Animation$IAnimationOperations$1$System$Windows$Media$Color$Subtract",
            "Scale", "System$Windows$Media$Animation$IAnimationOperations$1$System$Windows$Media$Color$Scale",
            "Interpolate", "System$Windows$Media$Animation$IAnimationOperations$1$System$Windows$Media$Color$Interpolate"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                //
            }
        },
        methods: {
            Add: function (value1, value2) {
                return System.Windows.Media.Color.op_Addition(value1, value2);
            },
            Subtract: function (value1, value2) {
                return System.Windows.Media.Color.op_Subtraction(value1, value2);
            },
            Scale: function (value, factor) {
                return System.Windows.Media.Color.op_Multiply(factor, value);
            },
            Interpolate: function (value1, value2, progress) {
                return System.Windows.Media.Color.op_Addition(System.Windows.Media.Color.op_Multiply((1 - progress), value1), System.Windows.Media.Color.op_Multiply(progress, value2));
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.ColorAnimationUsingKeyFrames", {
        inherits: [System.Windows.Media.Animation.KeyFramesAnimationTimeline$1(System.Windows.Media.Color)],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Animation.KeyFramesAnimationTimeline$1(System.Windows.Media.Color).ctor.call(this, System.Windows.Media.Animation.ColorAnimationOperations.Default, true);
                //
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.DiscreteColorKeyFrame", {
        inherits: [System.Windows.Media.Animation.DiscreteKeyFrame$1(System.Windows.Media.Color)],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Animation.DiscreteKeyFrame$1(System.Windows.Media.Color).ctor.call(this, System.Windows.Media.Animation.ColorAnimationOperations.Default);
                //
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.EasingColorKeyFrame", {
        inherits: [System.Windows.Media.Animation.EasingKeyFrame$1(System.Windows.Media.Color)],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Animation.EasingKeyFrame$1(System.Windows.Media.Color).ctor.call(this, System.Windows.Media.Animation.ColorAnimationOperations.Default);
                //
            }
        }
    });

    Bridge.define("System.Windows.Media.Animation.LinearColorKeyFrame", {
        inherits: [System.Windows.Media.Animation.LinearKeyFrame$1(System.Windows.Media.Color)],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Media.Animation.LinearKeyFrame$1(System.Windows.Media.Color).ctor.call(this, System.Windows.Media.Animation.ColorAnimationOperations.Default);
                //
            }
        }
    });

    Bridge.define("System.Windows.Window", {
        inherits: [System.Windows.Controls.ContentControl,System.Windows.Controls.IPopupLayerHost,System.Windows.Documents.IAdornerLayerHost,System.Windows.Controls.IRadioButtonGroupScope],
        statics: {
            fields: {
                TitleProperty: null
            },
            ctors: {
                init: function () {
                    this.TitleProperty = System.Windows.DependencyProperty.Register("Title", System.String, System.Windows.Window, new System.Windows.FrameworkPropertyMetadata.$ctor6("", $asm.$.System.Windows.Window.f1));
                },
                ctor: function () {
                    System.Windows.Controls.Control.IsTabStopProperty.OverrideMetadata(System.Windows.Window, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(false, System.Boolean, System.Boolean.toString)));
                    System.Windows.Input.KeyboardNavigation.DirectionalNavigationProperty.OverrideMetadata(System.Windows.Window, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(System.Windows.Input.KeyboardNavigationMode.Cycle, System.Windows.Input.KeyboardNavigationMode, System.Enum.toStringFn(System.Windows.Input.KeyboardNavigationMode))));
                    System.Windows.Input.KeyboardNavigation.TabNavigationProperty.OverrideMetadata(System.Windows.Window, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(System.Windows.Input.KeyboardNavigationMode.Cycle, System.Windows.Input.KeyboardNavigationMode, System.Enum.toStringFn(System.Windows.Input.KeyboardNavigationMode))));
                    System.Windows.Input.KeyboardNavigation.ControlTabNavigationProperty.OverrideMetadata(System.Windows.Window, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(System.Windows.Input.KeyboardNavigationMode.Cycle, System.Windows.Input.KeyboardNavigationMode, System.Enum.toStringFn(System.Windows.Input.KeyboardNavigationMode))));
                    System.Windows.Input.FocusManager.IsFocusScopeProperty.OverrideMetadata(System.Windows.Window, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(true, System.Boolean, System.Boolean.toString)));
                    System.Windows.FrameworkElement.DefaultStyleKeyProperty.OverrideMetadata(System.Windows.Window, new System.Windows.FrameworkPropertyMetadata.$ctor1(new System.Windows.StyleKey(System.Windows.Window)));
                }
            }
        },
        fields: {
            presentationSource: null,
            keyboardNavigation: null,
            radioButtonGroupScope: null
        },
        props: {
            Title: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Window.TitleProperty), System.String);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Window.TitleProperty, value);
                }
            },
            AdornerLayer: null,
            PopupLayer: null
        },
        alias: [
            "AdornerLayer", "System$Windows$Documents$IAdornerLayerHost$AdornerLayer",
            "PopupLayer", "System$Windows$Controls$IPopupLayerHost$PopupLayer",
            "GetRadioButtonGroup", "System$Windows$Controls$IRadioButtonGroupScope$GetRadioButtonGroup"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Controls.ContentControl.ctor.call(this);
                this.SetResourceInheritanceParent(System.Windows.Application.Current);

                this.AdornerLayer = new System.Windows.Documents.AdornerLayer();
                this.AddVisualChild(this.AdornerLayer);

                this.PopupLayer = new System.Windows.Controls.PopupLayer();
                this.AddVisualChild(this.PopupLayer);

                this.radioButtonGroupScope = new (System.Windows.Controls.SelectionGroupScope$1(System.Windows.Controls.RadioButton))();
            }
        },
        methods: {
            OnTemplateChildChanged: function () {
                this.SetVisualChildIndex(this.AdornerLayer, ((System.Linq.Enumerable.from(this.VisualChildren).count() - 2) | 0));
                this.SetVisualChildIndex(this.PopupLayer, ((System.Linq.Enumerable.from(this.VisualChildren).count() - 1) | 0));
            },
            Show: function () {
                if (this.presentationSource != null) {
                    return;
                }

                if (System.Windows.Application.Current.MainWindow == null) {
                    System.Windows.Application.Current.MainWindow = this;
                }

                this.presentationSource = System.Windows.ApplicationHost.Current.System$Windows$IApplicationHost$PresentationSourceFactory.System$Windows$IPresentationSourceFactory$CreatePresentationSource(this);
                this.presentationSource.System$Windows$IPresentationSource$Title = this.Title;

                this.keyboardNavigation = new System.Windows.Input.KeyboardNavigation(this.presentationSource);
            },
            GetRadioButtonGroup: function (groupName) {
                return this.radioButtonGroupScope.System$Windows$Controls$ISelectionGroupScope$1$System$Windows$Controls$RadioButton$GetSelectionGroup(groupName);
            },
            MeasureOverride: function (availableSize) {
                this.AdornerLayer.Measure(availableSize);
                this.PopupLayer.Measure(availableSize);
                return System.Windows.Controls.ContentControl.prototype.MeasureOverride.call(this, availableSize);
            },
            ArrangeOverride: function (finalSize) {
                this.AdornerLayer.Arrange(new System.Windows.Rect.$ctor3(finalSize));
                this.PopupLayer.Arrange(new System.Windows.Rect.$ctor3(finalSize));
                return System.Windows.Controls.ContentControl.prototype.ArrangeOverride.call(this, finalSize);
            },
            OnTitleChanged: function (e) {
                if (this.presentationSource != null) {
                    this.presentationSource.System$Windows$IPresentationSource$Title = this.Title;
                }
            }
        }
    });

    Bridge.ns("System.Windows.Window", $asm.$);

    Bridge.apply($asm.$.System.Windows.Window, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Window).OnTitleChanged(e);
        }
    });

    Bridge.define("System.Windows.Controls.Button", {
        inherits: [System.Windows.Controls.Primitives.ButtonBase],
        statics: {
            ctors: {
                ctor: function () {
                    System.Windows.FrameworkElement.DefaultStyleKeyProperty.OverrideMetadata(System.Windows.Controls.Button, new System.Windows.FrameworkPropertyMetadata.$ctor1(new System.Windows.StyleKey(System.Windows.Controls.Button)));
                }
            }
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.ToggleButton", {
        inherits: [System.Windows.Controls.Primitives.ButtonBase],
        statics: {
            fields: {
                CheckedEvent: null,
                UncheckedEvent: null,
                IndeterminateEvent: null,
                IsCheckedProperty: null,
                IsThreeStateProperty: null,
                CheckOnClickProperty: null
            },
            ctors: {
                init: function () {
                    this.CheckedEvent = System.Windows.EventManager.RegisterRoutedEvent("Checked", System.Windows.RoutingStrategy.Bubble, Function, System.Windows.Controls.Primitives.ToggleButton);
                    this.UncheckedEvent = System.Windows.EventManager.RegisterRoutedEvent("Unchecked", System.Windows.RoutingStrategy.Bubble, Function, System.Windows.Controls.Primitives.ToggleButton);
                    this.IndeterminateEvent = System.Windows.EventManager.RegisterRoutedEvent("Indeterminate", System.Windows.RoutingStrategy.Bubble, Function, System.Windows.Controls.Primitives.ToggleButton);
                    this.IsCheckedProperty = System.Windows.DependencyProperty.Register("IsChecked", System.Nullable$1(System.Boolean), System.Windows.Controls.Primitives.ToggleButton, new System.Windows.FrameworkPropertyMetadata.$ctor6(Bridge.box(false, System.Boolean, System.Boolean.toString), $asm.$.System.Windows.Controls.Primitives.ToggleButton.f1));
                    this.IsThreeStateProperty = System.Windows.DependencyProperty.Register("IsThreeState", System.Boolean, System.Windows.Controls.Primitives.ToggleButton, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.CheckOnClickProperty = System.Windows.DependencyProperty.Register("CheckOnClick", System.Boolean, System.Windows.Controls.Primitives.ToggleButton, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(true, System.Boolean, System.Boolean.toString)));
                },
                ctor: function () {
                    System.Windows.FrameworkElement.DefaultStyleKeyProperty.OverrideMetadata(System.Windows.Controls.Primitives.ToggleButton, new System.Windows.FrameworkPropertyMetadata.$ctor1(new System.Windows.StyleKey(System.Windows.Controls.Primitives.ToggleButton)));
                }
            },
            methods: {
                GetToggledState: function (currentState, isThreeState) {
                    // false -> true [-> null] -> false

                    if (System.Nullable.eq(currentState, false)) {
                        return true;
                    }

                    if (currentState == null || !isThreeState) {
                        return false;
                    }

                    return null;
                }
            }
        },
        props: {
            IsChecked: {
                get: function () {
                    return Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.ToggleButton.IsCheckedProperty)), System.Boolean, true);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.ToggleButton.IsCheckedProperty, Bridge.box(value, System.Boolean, System.Nullable.toStringFn(System.Boolean.toString), System.Nullable.getHashCode));
                }
            },
            IsThreeState: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.ToggleButton.IsThreeStateProperty)), System.Boolean));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.ToggleButton.IsThreeStateProperty, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            },
            CheckOnClick: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.ToggleButton.CheckOnClickProperty)), System.Boolean));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.ToggleButton.CheckOnClickProperty, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            }
        },
        methods: {
            addChecked: function (value) {
                this.AddHandler(System.Windows.Controls.Primitives.ToggleButton.CheckedEvent, value);
            },
            removeChecked: function (value) {
                this.RemoveHandler(System.Windows.Controls.Primitives.ToggleButton.CheckedEvent, value);
            },
            addUnchecked: function (value) {
                this.AddHandler(System.Windows.Controls.Primitives.ToggleButton.UncheckedEvent, value);
            },
            removeUnchecked: function (value) {
                this.RemoveHandler(System.Windows.Controls.Primitives.ToggleButton.UncheckedEvent, value);
            },
            addIndeterminate: function (value) {
                this.AddHandler(System.Windows.Controls.Primitives.ToggleButton.IndeterminateEvent, value);
            },
            removeIndeterminate: function (value) {
                this.RemoveHandler(System.Windows.Controls.Primitives.ToggleButton.IndeterminateEvent, value);
            },
            OnClick: function (e) {
                if (this.CheckOnClick) {
                    this.ToggleState();
                }
            },
            ToggleState: function () {
                this.SetCurrentValue(System.Windows.Controls.Primitives.ToggleButton.IsCheckedProperty, Bridge.box(System.Windows.Controls.Primitives.ToggleButton.GetToggledState(this.IsChecked, this.IsThreeState), System.Boolean, System.Nullable.toStringFn(System.Boolean.toString), System.Nullable.getHashCode));
            },
            OnIsCheckedChanged: function (e) {
                if (System.Nullable.hasValue(this.IsChecked) && System.Nullable.getValue(this.IsChecked)) {
                    this.RaiseEvent(new System.Windows.RoutedEventArgs(System.Windows.Controls.Primitives.ToggleButton.CheckedEvent, this));
                }

                if (System.Nullable.hasValue(this.IsChecked) && !System.Nullable.getValue(this.IsChecked)) {
                    this.RaiseEvent(new System.Windows.RoutedEventArgs(System.Windows.Controls.Primitives.ToggleButton.UncheckedEvent, this));
                }
            },
            UpdateVisualState: function (useTransitions) {
                System.Windows.Controls.Primitives.ButtonBase.prototype.UpdateVisualState.call(this, useTransitions);

                System.Windows.VisualStateManager.GoToState(this, this.GetCheckState(), useTransitions);
            },
            GetCheckState: function () {
                if (System.Nullable.hasValue(this.IsChecked)) {
                    return System.Nullable.getValue(this.IsChecked) ? System.Windows.Controls.VisualStates.CheckedState : System.Windows.Controls.VisualStates.UncheckedState;
                }

                return System.Windows.Controls.VisualStates.IndeterminateState;
            }
        }
    });

    Bridge.ns("System.Windows.Controls.Primitives.ToggleButton", $asm.$);

    Bridge.apply($asm.$.System.Windows.Controls.Primitives.ToggleButton, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.Primitives.ToggleButton).OnIsCheckedChanged(e);
        }
    });

    Bridge.define("System.Windows.Controls.Expander", {
        inherits: [System.Windows.Controls.HeaderedContentControl],
        statics: {
            fields: {
                ExpandedEvent: null,
                CollapsedEvent: null,
                ExpandDirectionProperty: null,
                IsExpandedProperty: null
            },
            ctors: {
                init: function () {
                    this.ExpandedEvent = System.Windows.EventManager.RegisterRoutedEvent("Expanded", System.Windows.RoutingStrategy.Bubble, Function, System.Windows.Controls.Expander);
                    this.CollapsedEvent = System.Windows.EventManager.RegisterRoutedEvent("Collapsed", System.Windows.RoutingStrategy.Bubble, Function, System.Windows.Controls.Expander);
                    this.ExpandDirectionProperty = System.Windows.DependencyProperty.Register("ExpandDirection", System.Windows.Controls.ExpandDirection, System.Windows.Controls.Expander, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.IsExpandedProperty = System.Windows.DependencyProperty.Register("IsExpanded", System.Boolean, System.Windows.Controls.Expander, new System.Windows.FrameworkPropertyMetadata.$ctor9(System.Windows.FrameworkPropertyMetadataOptions.AffectsVisualState, $asm.$.System.Windows.Controls.Expander.f1));
                },
                ctor: function () {
                    System.Windows.Controls.Control.IsTabStopProperty.OverrideMetadata(System.Windows.Controls.Expander, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(false, System.Boolean, System.Boolean.toString)));
                    System.Windows.FrameworkElement.DefaultStyleKeyProperty.OverrideMetadata(System.Windows.Controls.Expander, new System.Windows.FrameworkPropertyMetadata.$ctor1(new System.Windows.StyleKey(System.Windows.Controls.Expander)));
                }
            }
        },
        props: {
            ExpandDirection: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Expander.ExpandDirectionProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Expander.ExpandDirectionProperty, Bridge.box(value, System.Windows.Controls.ExpandDirection, System.Enum.toStringFn(System.Windows.Controls.ExpandDirection)));
                }
            },
            IsExpanded: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Expander.IsExpandedProperty)), System.Boolean));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Expander.IsExpandedProperty, Bridge.box(value, System.Boolean, System.Boolean.toString));
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Controls.HeaderedContentControl.ctor.call(this);
                //
            }
        },
        methods: {
            addExpanded: function (value) {
                this.AddHandler(System.Windows.Controls.Expander.ExpandedEvent, value);
            },
            removeExpanded: function (value) {
                this.RemoveHandler(System.Windows.Controls.Expander.ExpandedEvent, value);
            },
            addCollapsed: function (value) {
                this.AddHandler(System.Windows.Controls.Expander.CollapsedEvent, value);
            },
            removeCollapsed: function (value) {
                this.RemoveHandler(System.Windows.Controls.Expander.CollapsedEvent, value);
            },
            OnIsExpandedChanged: function (e) {
                if (System.Nullable.getValue(Bridge.cast(Bridge.unbox(e.NewValue), System.Boolean))) {
                    this.RaiseEvent(new System.Windows.RoutedEventArgs(System.Windows.Controls.Expander.ExpandedEvent, this));
                } else {
                    this.RaiseEvent(new System.Windows.RoutedEventArgs(System.Windows.Controls.Expander.CollapsedEvent, this));
                }
            },
            UpdateVisualState: function (useTransitions) {
                System.Windows.VisualStateManager.GoToState(this, this.GetCommonState(), useTransitions);
                System.Windows.VisualStateManager.GoToState(this, this.GetExpansionState(), useTransitions);
            },
            GetCommonState: function () {
                if (!this.IsEnabled) {
                    return System.Windows.Controls.VisualStates.DisabledState;
                }

                if (this.IsMouseOver) {
                    return System.Windows.Controls.VisualStates.MouseOverState;
                }

                return System.Windows.Controls.VisualStates.NormalState;
            },
            GetExpansionState: function () {
                return this.IsExpanded ? System.Windows.Controls.VisualStates.ExpandedState : System.Windows.Controls.VisualStates.CollapsedState;
            }
        }
    });

    Bridge.ns("System.Windows.Controls.Expander", $asm.$);

    Bridge.apply($asm.$.System.Windows.Controls.Expander, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.Expander).OnIsExpandedChanged(e);
        }
    });

    Bridge.define("System.Windows.Controls.ListBox", {
        inherits: [System.Windows.Controls.Primitives.Selector],
        statics: {
            fields: {
                SelectedItemsPropertyKey: null,
                SelectedItemsProperty: null,
                SelectionModeProperty: null
            },
            ctors: {
                init: function () {
                    this.SelectedItemsPropertyKey = System.Windows.DependencyProperty.RegisterReadOnly("SelectedItems", System.Collections.Generic.IEnumerable$1(System.Object), System.Windows.Controls.ListBox, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.SelectedItemsProperty = System.Windows.Controls.ListBox.SelectedItemsPropertyKey.DependencyProperty;
                    this.SelectionModeProperty = System.Windows.DependencyProperty.Register("SelectionMode", System.Windows.Controls.SelectionMode, System.Windows.Controls.ListBox, new System.Windows.FrameworkPropertyMetadata.$ctor6(Bridge.box(System.Windows.Controls.SelectionMode.Single, System.Windows.Controls.SelectionMode, System.Enum.toStringFn(System.Windows.Controls.SelectionMode)), $asm.$.System.Windows.Controls.ListBox.f1));
                },
                ctor: function () {
                    System.Windows.Controls.Control.IsTabStopProperty.OverrideMetadata(System.Windows.Controls.ListBox, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(false, System.Boolean, System.Boolean.toString)));
                    System.Windows.Input.KeyboardNavigation.DirectionalNavigationProperty.OverrideMetadata(System.Windows.Controls.ListBox, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(System.Windows.Input.KeyboardNavigationMode.Contained, System.Windows.Input.KeyboardNavigationMode, System.Enum.toStringFn(System.Windows.Input.KeyboardNavigationMode))));
                    System.Windows.Input.KeyboardNavigation.TabNavigationProperty.OverrideMetadata(System.Windows.Controls.ListBox, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(System.Windows.Input.KeyboardNavigationMode.Once, System.Windows.Input.KeyboardNavigationMode, System.Enum.toStringFn(System.Windows.Input.KeyboardNavigationMode))));
                    System.Windows.FrameworkElement.DefaultStyleKeyProperty.OverrideMetadata(System.Windows.Controls.ListBox, new System.Windows.FrameworkPropertyMetadata.$ctor1(new System.Windows.StyleKey(System.Windows.Controls.ListBox)));
                }
            },
            methods: {
                CreateSelectionBehavior: function (listBox, selectionMode) {
                    switch (selectionMode) {
                        case System.Windows.Controls.SelectionMode.Single: 
                            return new System.Windows.Controls.ListBox.SingleSelectionBehavior(listBox);
                        case System.Windows.Controls.SelectionMode.Multiple: 
                            return new System.Windows.Controls.ListBox.MultipleSelectionBehavior(listBox);
                        case System.Windows.Controls.SelectionMode.Extended: 
                            return new System.Windows.Controls.ListBox.ExtendedSelectionBehavior(listBox);
                    }

                    throw new Granular.Exception("Unexpected SelectionMode \"{0}\"", [Bridge.box(selectionMode, System.Windows.Controls.SelectionMode, System.Enum.toStringFn(System.Windows.Controls.SelectionMode))]);
                }
            }
        },
        fields: {
            selectionBehavior: null,
            selectionAnchor: null,
            isItemContainerBeingClicked: false
        },
        props: {
            SelectedItems: {
                get: function () {
                    return Bridge.cast(this.GetValue$1(System.Windows.Controls.ListBox.SelectedItemsPropertyKey), System.Collections.Generic.IEnumerable$1(System.Object));
                },
                set: function (value) {
                    this.SetValue$1(System.Windows.Controls.ListBox.SelectedItemsPropertyKey, value);
                }
            },
            SelectionMode: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.ListBox.SelectionModeProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.ListBox.SelectionModeProperty, Bridge.box(value, System.Windows.Controls.SelectionMode, System.Enum.toStringFn(System.Windows.Controls.SelectionMode)));
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Controls.Primitives.Selector.ctor.call(this);
                this.SetSelectionBehavior();
            }
        },
        methods: {
            IsItemItsOwnContainerOverride: function (item) {
                return Bridge.is(item, System.Windows.Controls.ListBoxItem);
            },
            GetContainerForItemOverride: function () {
                return new System.Windows.Controls.ListBoxItem();
            },
            OnPrepareContainerForItem: function (item, container) {
                container.addPreviewMouseDown(Bridge.fn.cacheBind(this, this.OnItemContainerPreviewMouseDown)); // handled too
                container.addMouseDown(Bridge.fn.cacheBind(this, this.OnItemContainerMouseDown));
                container.addKeyDown(Bridge.fn.cacheBind(this, this.OnItemContainerKeyDown));
                container.addGotKeyboardFocus(Bridge.fn.cacheBind(this, this.OnItemContainerGotKeyboardFocus));
            },
            OnClearContainerForItem: function (item, container) {
                container.removePreviewMouseDown(Bridge.fn.cacheBind(this, this.OnItemContainerPreviewMouseDown)); // handled too
                container.removeMouseDown(Bridge.fn.cacheBind(this, this.OnItemContainerMouseDown));
                container.removeKeyDown(Bridge.fn.cacheBind(this, this.OnItemContainerKeyDown));
                container.removeGotKeyboardFocus(Bridge.fn.cacheBind(this, this.OnItemContainerGotKeyboardFocus));
            },
            OnItemContainerPreviewMouseDown: function (sender, e) {
                if (e.ChangedButton === System.Windows.Input.MouseButton.Left || e.ChangedButton === System.Windows.Input.MouseButton.Right) {
                    this.isItemContainerBeingClicked = true;
                }
            },
            OnItemContainerMouseDown: function (sender, e) {
                if (e.ChangedButton === System.Windows.Input.MouseButton.Left || e.ChangedButton === System.Windows.Input.MouseButton.Right) {
                    this.selectionBehavior.System$Windows$Controls$ListBox$ISelectionBehavior$SetClickSelection(Bridge.cast(sender, System.Windows.Controls.ListBoxItem), System.Windows.ApplicationHostExtensions.GetKeyboardDeviceFromElement(System.Windows.ApplicationHost.Current, this).Modifiers);
                    this.isItemContainerBeingClicked = false;
                }
            },
            OnItemContainerKeyDown: function (sender, e) {
                if (e.Key === System.Windows.Input.Key.Space) {
                    this.selectionBehavior.System$Windows$Controls$ListBox$ISelectionBehavior$SetClickSelection(Bridge.cast(sender, System.Windows.Controls.ListBoxItem), e.KeyboardDevice.Modifiers);
                }
            },
            OnItemContainerGotKeyboardFocus: function (sender, e) {
                if (!this.isItemContainerBeingClicked) {
                    this.selectionBehavior.System$Windows$Controls$ListBox$ISelectionBehavior$SetFocusChangeSelection(Bridge.cast(sender, System.Windows.Controls.ListBoxItem), e.KeyboardDevice.Modifiers);
                }
            },
            SetSelectionBehavior: function () {
                this.selectionBehavior = System.Windows.Controls.ListBox.CreateSelectionBehavior(this, this.SelectionMode);
            },
            SetSelectionAnchor: function (item) {
                this.selectionAnchor = item;
            },
            SetSingleSelection: function (item) {
                this.SelectedItem = this.ItemContainerGenerator.System$Windows$Controls$Primitives$IItemContainerGenerator$ItemFromContainer(item);

                for (var i = 0; i < this.ItemContainerGenerator.System$Windows$Controls$Primitives$IItemContainerGenerator$ItemsCount; i = (i + 1) | 0) {
                    var itemContainer = this.ItemContainerGenerator.System$Windows$Controls$Primitives$IItemContainerGenerator$Generate(i);
                    itemContainer.SetCurrentValue(System.Windows.Controls.Primitives.Selector.IsSelectedProperty, Bridge.box(Bridge.referenceEquals(itemContainer, item), System.Boolean, System.Boolean.toString));
                }
            },
            SetRangeSelection: function (item) {
                var itemIndex = this.ItemContainerGenerator.System$Windows$Controls$Primitives$IItemContainerGenerator$IndexFromContainer(item);
                var selectionAnchorIndex = this.ItemContainerGenerator.System$Windows$Controls$Primitives$IItemContainerGenerator$IndexFromContainer(this.selectionAnchor);

                var rangeStartIndex = Granular.Extensions.IntExtensions.Min(itemIndex, selectionAnchorIndex);
                var rangeEndIndex = Granular.Extensions.IntExtensions.Max(itemIndex, selectionAnchorIndex);

                for (var i = 0; i < this.ItemContainerGenerator.System$Windows$Controls$Primitives$IItemContainerGenerator$ItemsCount; i = (i + 1) | 0) {
                    var itemContainer = this.ItemContainerGenerator.System$Windows$Controls$Primitives$IItemContainerGenerator$Generate(i);
                    itemContainer.SetCurrentValue(System.Windows.Controls.Primitives.Selector.IsSelectedProperty, Bridge.box(rangeStartIndex <= i && i <= rangeEndIndex, System.Boolean, System.Boolean.toString));
                }
            },
            ToggleSelection: function (item) {
                item.SetCurrentValue(System.Windows.Controls.Primitives.Selector.IsSelectedProperty, Bridge.box(!System.Nullable.getValue(Bridge.cast(Bridge.unbox(item.GetValue(System.Windows.Controls.Primitives.Selector.IsSelectedProperty)), System.Boolean)), System.Boolean, System.Boolean.toString));
            },
            ToggleSingleSelection: function (item) {
                var isSelected = !System.Nullable.getValue(Bridge.cast(Bridge.unbox(item.GetValue(System.Windows.Controls.Primitives.Selector.IsSelectedProperty)), System.Boolean));

                this.SelectedItem = isSelected ? this.ItemContainerGenerator.System$Windows$Controls$Primitives$IItemContainerGenerator$ItemFromContainer(item) : null;

                for (var i = 0; i < this.ItemContainerGenerator.System$Windows$Controls$Primitives$IItemContainerGenerator$ItemsCount; i = (i + 1) | 0) {
                    var itemContainer = this.ItemContainerGenerator.System$Windows$Controls$Primitives$IItemContainerGenerator$Generate(i);
                    itemContainer.SetCurrentValue(System.Windows.Controls.Primitives.Selector.IsSelectedProperty, Bridge.box(Bridge.referenceEquals(itemContainer, item) && isSelected, System.Boolean, System.Boolean.toString));
                }
            }
        }
    });

    Bridge.ns("System.Windows.Controls.ListBox", $asm.$);

    Bridge.apply($asm.$.System.Windows.Controls.ListBox, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.ListBox).SetSelectionBehavior();
        }
    });

    Bridge.define("System.Windows.Controls.Primitives.RepeatButton", {
        inherits: [System.Windows.Controls.Primitives.ButtonBase],
        statics: {
            fields: {
                DelayProperty: null,
                IntervalProperty: null
            },
            ctors: {
                init: function () {
                    this.DelayProperty = System.Windows.DependencyProperty.Register("Delay", System.Int32, System.Windows.Controls.Primitives.RepeatButton, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(500, System.Int32)));
                    this.IntervalProperty = System.Windows.DependencyProperty.Register("Interval", System.Int32, System.Windows.Controls.Primitives.RepeatButton, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(33, System.Int32)));
                },
                ctor: function () {
                    System.Windows.Controls.Primitives.ButtonBase.ClickModeProperty.OverrideMetadata(System.Windows.Controls.Primitives.RepeatButton, new System.Windows.FrameworkPropertyMetadata.$ctor1(Bridge.box(System.Windows.Controls.ClickMode.Press, System.Windows.Controls.ClickMode, System.Enum.toStringFn(System.Windows.Controls.ClickMode))));
                    System.Windows.FrameworkElement.DefaultStyleKeyProperty.OverrideMetadata(System.Windows.Controls.Primitives.RepeatButton, new System.Windows.FrameworkPropertyMetadata.$ctor1(new System.Windows.StyleKey(System.Windows.Controls.Primitives.RepeatButton)));
                }
            }
        },
        fields: {
            timer: null
        },
        props: {
            Delay: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.RepeatButton.DelayProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.RepeatButton.DelayProperty, Bridge.box(value, System.Int32));
                }
            },
            Interval: {
                get: function () {
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(this.GetValue(System.Windows.Controls.Primitives.RepeatButton.IntervalProperty)), System.Int32));
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.Primitives.RepeatButton.IntervalProperty, Bridge.box(value, System.Int32));
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Controls.Primitives.ButtonBase.ctor.call(this);
                this.timer = new System.Windows.Threading.DispatcherTimer.ctor();
                this.timer.addTick(Bridge.fn.cacheBind(this, this.OnTimerTick));
            }
        },
        methods: {
            OnPressStarted: function () {
                this.timer.Interval = System.TimeSpan.fromMilliseconds(this.Delay > 0 ? this.Delay : this.Interval);
                this.timer.Start();
            },
            OnPressEnded: function () {
                this.timer.Stop();
            },
            OnTimerTick: function (sender, e) {
                // the first interval can be different
                if (this.timer.Interval.getTotalMilliseconds() !== this.Interval) {
                    this.timer.Stop();
                    this.timer.Interval = System.TimeSpan.fromMilliseconds(this.Interval);
                    this.timer.Start();
                }

                if (this.IsPressed) {
                    this.RaiseClick();
                }
            }
        }
    });

    Bridge.define("System.Windows.Controls.CheckBox", {
        inherits: [System.Windows.Controls.Primitives.ToggleButton],
        statics: {
            ctors: {
                ctor: function () {
                    System.Windows.FrameworkElement.DefaultStyleKeyProperty.OverrideMetadata(System.Windows.Controls.CheckBox, new System.Windows.FrameworkPropertyMetadata.$ctor1(new System.Windows.StyleKey(System.Windows.Controls.CheckBox)));
                }
            }
        }
    });

    Bridge.define("System.Windows.Controls.RadioButton", {
        inherits: [System.Windows.Controls.Primitives.ToggleButton],
        statics: {
            fields: {
                SelectionGroupProperty: null,
                GroupNameProperty: null
            },
            ctors: {
                init: function () {
                    this.SelectionGroupProperty = System.Windows.DependencyProperty.RegisterAttached("SelectionGroup", System.Windows.Controls.ISelectionGroup$1(System.Windows.Controls.RadioButton), System.Windows.Controls.RadioButton, new System.Windows.FrameworkPropertyMetadata.ctor());
                    this.GroupNameProperty = System.Windows.DependencyProperty.Register("GroupName", System.String, System.Windows.Controls.RadioButton, new System.Windows.FrameworkPropertyMetadata.$ctor11($asm.$.System.Windows.Controls.RadioButton.f1));
                },
                ctor: function () {
                    System.Windows.FrameworkElement.DefaultStyleKeyProperty.OverrideMetadata(System.Windows.Controls.RadioButton, new System.Windows.FrameworkPropertyMetadata.$ctor1(new System.Windows.StyleKey(System.Windows.Controls.RadioButton)));
                }
            },
            methods: {
                GetSelectionGroupScope: function (visual) {
                    while (visual != null) {
                        if (Bridge.is(visual, System.Windows.Controls.IRadioButtonGroupScope)) {
                            return Bridge.cast(visual, System.Windows.Controls.IRadioButtonGroupScope);
                        }

                        visual = visual.VisualParent;
                    }

                    return null;
                }
            }
        },
        fields: {
            currentGroup: null
        },
        props: {
            GroupName: {
                get: function () {
                    return Bridge.cast(this.GetValue(System.Windows.Controls.RadioButton.GroupNameProperty), System.String);
                },
                set: function (value) {
                    this.SetValue(System.Windows.Controls.RadioButton.GroupNameProperty, value);
                }
            },
            CurrentGroup: {
                get: function () {
                    return this.currentGroup;
                },
                set: function (value) {
                    if (Bridge.referenceEquals(this.currentGroup, value)) {
                        return;
                    }

                    if (this.currentGroup != null) {
                        if (Bridge.referenceEquals(this.currentGroup.System$Windows$Controls$ISelectionGroup$1$System$Windows$Controls$RadioButton$Selection, this)) {
                            this.currentGroup.System$Windows$Controls$ISelectionGroup$1$System$Windows$Controls$RadioButton$Selection = null;
                        }

                        this.currentGroup.System$Windows$Controls$ISelectionGroup$1$System$Windows$Controls$RadioButton$removeSelectionChanged(Bridge.fn.cacheBind(this, this.OnCurrentSelectionGroupChanged));
                    }

                    this.currentGroup = value;

                    if (this.currentGroup != null) {
                        this.currentGroup.System$Windows$Controls$ISelectionGroup$1$System$Windows$Controls$RadioButton$addSelectionChanged(Bridge.fn.cacheBind(this, this.OnCurrentSelectionGroupChanged));

                        if (this.currentGroup.System$Windows$Controls$ISelectionGroup$1$System$Windows$Controls$RadioButton$Selection == null && System.Nullable.eq(this.IsChecked, true)) {
                            this.currentGroup.System$Windows$Controls$ISelectionGroup$1$System$Windows$Controls$RadioButton$Selection = this;
                        } else {
                            this.IsChecked = Bridge.referenceEquals(this.currentGroup.System$Windows$Controls$ISelectionGroup$1$System$Windows$Controls$RadioButton$Selection, this);
                        }
                    }
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Windows.Controls.Primitives.ToggleButton.ctor.call(this);
                //
            }
        },
        methods: {
            ToggleState: function () {
                this.IsChecked = true;
            },
            OnVisualAncestorChanged: function () {
                System.Windows.Controls.Primitives.ToggleButton.prototype.OnVisualAncestorChanged.call(this);

                this.SetCurrentGroup();
            },
            OnGroupNameChanged: function (e) {
                this.SetCurrentGroup();
            },
            SetCurrentGroup: function () {
                this.CurrentGroup = !Granular.Extensions.StringExtensions.IsNullOrEmpty(this.GroupName) ? this.GetGroup(this.GroupName) : this.GetDefaultGroup();
            },
            OnIsCheckedChanged: function (e) {
                System.Windows.Controls.Primitives.ToggleButton.prototype.OnIsCheckedChanged.call(this, e);

                if (System.Nullable.eq(this.IsChecked, true) && this.CurrentGroup != null) {
                    this.CurrentGroup.System$Windows$Controls$ISelectionGroup$1$System$Windows$Controls$RadioButton$Selection = this;
                }
            },
            OnCurrentSelectionGroupChanged: function (sender, e) {
                this.IsChecked = Bridge.referenceEquals(this.CurrentGroup.System$Windows$Controls$ISelectionGroup$1$System$Windows$Controls$RadioButton$Selection, this);
            },
            GetGroup: function (name) {
                var scope = System.Windows.Controls.RadioButton.GetSelectionGroupScope(this);
                return scope != null ? scope.System$Windows$Controls$IRadioButtonGroupScope$GetRadioButtonGroup(name) : null;
            },
            GetDefaultGroup: function () {
                if (this.LogicalParent == null) {
                    return null;
                }

                var group = Bridge.cast(this.LogicalParent.GetValue(System.Windows.Controls.RadioButton.SelectionGroupProperty), System.Windows.Controls.ISelectionGroup$1(System.Windows.Controls.RadioButton));

                if (group == null) {
                    group = new (System.Windows.Controls.SelectionGroup$1(System.Windows.Controls.RadioButton))();
                    this.LogicalParent.SetValue(System.Windows.Controls.RadioButton.SelectionGroupProperty, group);
                }

                return group;
            }
        }
    });

    Bridge.ns("System.Windows.Controls.RadioButton", $asm.$);

    Bridge.apply($asm.$.System.Windows.Controls.RadioButton, {
        f1: function (sender, e) {
            Bridge.cast(sender, System.Windows.Controls.RadioButton).OnGroupNameChanged(e);
        }
    });
});
